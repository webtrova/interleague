"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/tournament/page",{

/***/ "(app-pages-browser)/./types/tournament/matches.ts":
/*!*************************************!*\
  !*** ./types/tournament/matches.ts ***!
  \*************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   advanceToNextRound: function() { return /* binding */ advanceToNextRound; },\n/* harmony export */   createInitialRounds: function() { return /* binding */ createInitialRounds; },\n/* harmony export */   createMatch: function() { return /* binding */ createMatch; },\n/* harmony export */   updateMatchScore: function() { return /* binding */ updateMatchScore; }\n/* harmony export */ });\n/* harmony import */ var _logTournamentState__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./logTournamentState */ \"(app-pages-browser)/./types/tournament/logTournamentState.ts\");\n\nconst createMatch = function(id, roundNumber, team1, team2) {\n    let isBye = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : false, bracket = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : \"winners\", nextMatchId = arguments.length > 6 ? arguments[6] : void 0, nextLoserMatchId = arguments.length > 7 ? arguments[7] : void 0;\n    var _ref;\n    return {\n        id,\n        roundNumber,\n        team1,\n        team2,\n        isCompleted: isBye,\n        isBye,\n        bracket,\n        winner: isBye ? (_ref = team1 !== null && team1 !== void 0 ? team1 : team2) !== null && _ref !== void 0 ? _ref : undefined : undefined,\n        loser: isBye ? undefined : undefined,\n        score: {\n            team1Score: 0,\n            team2Score: 0\n        },\n        nextMatchId,\n        nextLoserMatchId,\n        eliminatedLabel: undefined\n    };\n};\nconst createInitialRounds = (teams)=>{\n    const numTeams = teams.length;\n    const matches = [];\n    const numRounds = Math.ceil(Math.log2(numTeams));\n    const firstRoundMatches = Math.pow(2, numRounds - 1);\n    let matchCounter = 1;\n    for(let i = 0; i < firstRoundMatches; i++){\n        const team1 = teams[i * 2] || null;\n        const team2 = teams[i * 2 + 1] || null;\n        const isBye = !team1 || !team2;\n        const matchId = \"W1-\".concat(matchCounter);\n        const nextMatchId = \"W2-\".concat(Math.ceil(matchCounter / 2));\n        const nextLoserMatchId = \"L1-\".concat(Math.ceil(matchCounter / 2));\n        matches.push(createMatch(matchId, 1, team1, team2, isBye, \"winners\", nextMatchId, nextLoserMatchId));\n        matchCounter++;\n    }\n    return {\n        rounds: [\n            {\n                roundNumber: 1,\n                matches,\n                isDoubleElimination: true,\n                isChampionshipRound: false\n            }\n        ],\n        currentRound: 1,\n        eliminatedTeams: [],\n        championshipMatchesPlayed: 0\n    };\n};\nconst updateMatchScore = (match, newScore)=>{\n    const isCompleted = newScore.team1Score !== newScore.team2Score;\n    let winner = undefined;\n    let loser = undefined;\n    if (isCompleted) {\n        if (newScore.team1Score > newScore.team2Score) {\n            var _match_team1_wins, _match_team1_losses;\n            winner = match.team1 ? {\n                ...match.team1,\n                wins: ((_match_team1_wins = match.team1.wins) !== null && _match_team1_wins !== void 0 ? _match_team1_wins : 0) + 1,\n                losses: (_match_team1_losses = match.team1.losses) !== null && _match_team1_losses !== void 0 ? _match_team1_losses : 0\n            } : undefined;\n            var _match_team2_wins, _match_team2_losses;\n            loser = match.team2 ? {\n                ...match.team2,\n                wins: (_match_team2_wins = match.team2.wins) !== null && _match_team2_wins !== void 0 ? _match_team2_wins : 0,\n                losses: ((_match_team2_losses = match.team2.losses) !== null && _match_team2_losses !== void 0 ? _match_team2_losses : 0) + 1\n            } : undefined;\n        } else {\n            var _match_team2_wins1, _match_team2_losses1;\n            winner = match.team2 ? {\n                ...match.team2,\n                wins: ((_match_team2_wins1 = match.team2.wins) !== null && _match_team2_wins1 !== void 0 ? _match_team2_wins1 : 0) + 1,\n                losses: (_match_team2_losses1 = match.team2.losses) !== null && _match_team2_losses1 !== void 0 ? _match_team2_losses1 : 0\n            } : undefined;\n            var _match_team1_wins1, _match_team1_losses1;\n            loser = match.team1 ? {\n                ...match.team1,\n                wins: (_match_team1_wins1 = match.team1.wins) !== null && _match_team1_wins1 !== void 0 ? _match_team1_wins1 : 0,\n                losses: ((_match_team1_losses1 = match.team1.losses) !== null && _match_team1_losses1 !== void 0 ? _match_team1_losses1 : 0) + 1\n            } : undefined;\n        }\n    }\n    return {\n        ...match,\n        score: newScore,\n        isCompleted,\n        winner,\n        loser\n    };\n};\n// Helper to deduplicate teams by ID\nfunction dedupeTeams(teams) {\n    const seen = new Set();\n    return teams.filter((team)=>{\n        if (!team) return false;\n        if (seen.has(team.id)) return false;\n        seen.add(team.id);\n        return true;\n    });\n}\n// Helper: get all teams with exactly N losses\nfunction teamsWithLosses(lossCounts, n) {\n    return Object.keys(lossCounts).filter((teamId)=>lossCounts[teamId] === n);\n}\nconst advanceToNextRound = (tournament)=>{\n    const currentRound = tournament.rounds[tournament.rounds.length - 1];\n    const nextRoundNumber = tournament.currentRound + 1;\n    // Track all losses and wins across the tournament\n    const lossCounts = {};\n    const winsCounts = {};\n    tournament.rounds.forEach((round)=>{\n        round.matches.forEach((match)=>{\n            if (match.isCompleted && match.loser) {\n                lossCounts[match.loser.id] = (lossCounts[match.loser.id] || 0) + 1;\n            }\n            if (match.isCompleted && match.winner) {\n                winsCounts[match.winner.id] = (winsCounts[match.winner.id] || 0) + 1;\n            }\n        });\n    });\n    // WINNER GUARD: If a winner has already been determined, do not create any more rounds\n    if (tournament.winner) {\n        return {\n            ...tournament,\n            currentRound: tournament.currentRound\n        };\n    }\n    // Gather all teams ever in the tournament, attaching wins\n    const allTeams = [];\n    const teamIds = new Set();\n    for (const round of tournament.rounds){\n        for (const match of round.matches){\n            if (match.team1 && !teamIds.has(match.team1.id)) {\n                allTeams.push({\n                    ...match.team1,\n                    wins: winsCounts[match.team1.id] || 0,\n                    losses: lossCounts[match.team1.id] || 0\n                });\n                teamIds.add(match.team1.id);\n            }\n            if (match.team2 && !teamIds.has(match.team2.id)) {\n                allTeams.push({\n                    ...match.team2,\n                    wins: winsCounts[match.team2.id] || 0,\n                    losses: lossCounts[match.team2.id] || 0\n                });\n                teamIds.add(match.team2.id);\n            }\n        }\n    }\n    // Identify newly eliminated teams (2 losses)\n    const newlyEliminated = [];\n    for (const team of allTeams){\n        if ((lossCounts[team.id] || 0) >= 2 && !tournament.eliminatedTeams.some((t)=>t.id === team.id)) {\n            newlyEliminated.push(team);\n        }\n    }\n    // Winners: teams with 0 losses and not eliminated\n    const winnersBracketTeams = allTeams.filter((team)=>(lossCounts[team.id] || 0) === 0 && !tournament.eliminatedTeams.some((t)=>t.id === team.id) && !newlyEliminated.some((t)=>t.id === team.id) && !team.id.startsWith(\"tbd-\") // Exclude phantom TBD teams\n    ).map((team)=>({\n            ...team,\n            losses: lossCounts[team.id] || 0,\n            wins: winsCounts[team.id] || 0\n        }));\n    // Losers: teams with 1 loss and not eliminated\n    const losersBracketTeams = allTeams.filter((team)=>(lossCounts[team.id] || 0) === 1 && !tournament.eliminatedTeams.some((t)=>t.id === team.id) && !newlyEliminated.some((t)=>t.id === team.id) && // Don't include the winners bracket final loser in regular losers bracket teams\n        !(tournament.winnersBracketFinalLoser && tournament.winnersBracketFinalLoser.id === team.id)).map((team)=>({\n            ...team,\n            losses: lossCounts[team.id] || 0,\n            wins: winsCounts[team.id] || 0\n        }));\n    let isChampionshipRound = false;\n    let championshipMatches = [];\n    let nextRoundMatches = [];\n    const prevChampionshipMatches = tournament.rounds.filter((r)=>r.isChampionshipRound).flatMap((r)=>r.matches).filter((m)=>m.bracket === \"championship\");\n    // --- CHAMPIONSHIP LOGIC ---\n    // Check if a championship match already happened and was completed\n    if (prevChampionshipMatches.length >= 1 && prevChampionshipMatches[prevChampionshipMatches.length - 1].isCompleted) {\n        var _lastChampMatch_winner;\n        const lastChampMatch = prevChampionshipMatches[prevChampionshipMatches.length - 1];\n        const winnersBracketTeam = lastChampMatch.team1;\n        const losersBracketTeam = lastChampMatch.team2;\n        // If loser's bracket team won the first championship match, winner's bracket team gets another chance\n        if (((_lastChampMatch_winner = lastChampMatch.winner) === null || _lastChampMatch_winner === void 0 ? void 0 : _lastChampMatch_winner.id) === (losersBracketTeam === null || losersBracketTeam === void 0 ? void 0 : losersBracketTeam.id) && tournament.championshipMatchesPlayed === 1) {\n            isChampionshipRound = true;\n            // Create the \"reset\" match\n            championshipMatches.push(createMatch(\"C\".concat(nextRoundNumber, \"-1\"), nextRoundNumber, winnersBracketTeam, losersBracketTeam, false, \"championship\"));\n        } else {\n            // Either winner's bracket team won first match, or this was the reset match\n            isChampionshipRound = true;\n        // No new matches, winner will be determined in winner detection logic\n        }\n    } else if (winnersBracketTeams.length === 1 && losersBracketTeams.length === 1 && currentRound.matches.some((m)=>(m.bracket === \"losers\" || m.id.includes(\"LosersLast\")) && m.isCompleted && m.winner && (losersBracketTeams.some((t)=>t.id === m.winner.id) || tournament.winnersBracketFinalLoser && m.winner.id === tournament.winnersBracketFinalLoser.id))) {\n        // Find the winner of the losers bracket final\n        const losersBracketWinner = currentRound.matches.filter((m)=>(m.bracket === \"losers\" || m.id.includes(\"LosersLast\")) && m.isCompleted && m.winner).map((m)=>m.winner).pop();\n        if (losersBracketWinner) {\n            // Only schedule the championship if there is no winnersBracketFinalLoser waiting to play\n            if (!tournament.winnersBracketFinalLoser) {\n                // Schedule championship match immediately (no extra round)\n                nextRoundMatches.push(createMatch(\"C\".concat(nextRoundNumber, \"-1\"), nextRoundNumber, winnersBracketTeams[0], losersBracketWinner, false, \"championship\"));\n                isChampionshipRound = true;\n            // Do NOT schedule any waiting cards\n            } else {\n                // Instead, schedule the losers bracket final (LLWB vs LWLB), and show the winners bracket champion as waiting\n                nextRoundMatches.push(createMatch(\"LosersLast-\".concat(nextRoundNumber), nextRoundNumber, tournament.winnersBracketFinalLoser, losersBracketTeams[0], false, \"losers\"));\n                nextRoundMatches.push(createMatch(\"WinnersBracketChampion-waiting-\".concat(nextRoundNumber), nextRoundNumber, winnersBracketTeams[0], null, true, \"winners\"));\n            }\n        }\n    } else if (winnersBracketTeams.length === 1 && tournament.winnersBracketFinalLoser) {\n        if (losersBracketTeams.length === 1) {\n            // Prevent duplicate losers bracket final: check all previous rounds for this match\n            let alreadyPlayed = false;\n            for (let round of tournament.rounds){\n                if (!round.matches) continue;\n                for (let m of round.matches){\n                    var _m_team1, _m_team2;\n                    const ids = [\n                        (_m_team1 = m.team1) === null || _m_team1 === void 0 ? void 0 : _m_team1.id,\n                        (_m_team2 = m.team2) === null || _m_team2 === void 0 ? void 0 : _m_team2.id\n                    ].filter(Boolean).sort();\n                    const currIds = [\n                        tournament.winnersBracketFinalLoser.id,\n                        losersBracketTeams[0].id\n                    ].sort();\n                    if (ids.length === 2 && ids[0] === currIds[0] && ids[1] === currIds[1]) {\n                        alreadyPlayed = true;\n                        break;\n                    }\n                }\n                if (alreadyPlayed) break;\n            }\n            if (!alreadyPlayed) {\n                // Only now schedule WBFL vs LBL\n                nextRoundMatches.push(createMatch(\"LosersLast-\".concat(nextRoundNumber), nextRoundNumber, tournament.winnersBracketFinalLoser, losersBracketTeams[0], false, \"losers\"));\n            }\n        // If match already played, do not schedule again; championship logic will handle next step\n        } else if (losersBracketTeams.length === 2) {\n            // Schedule the match between the last two losers bracket teams\n            nextRoundMatches.push(createMatch(\"L\".concat(nextRoundNumber, \"-1\"), nextRoundNumber, losersBracketTeams[0], losersBracketTeams[1], false, \"losers\"));\n            // WBFL is waiting for the winner\n            nextRoundMatches.push(createMatch(\"WinnersFinalLoser-waiting-\".concat(nextRoundNumber), nextRoundNumber, tournament.winnersBracketFinalLoser, null, true, \"losers\"));\n        } else if (losersBracketTeams.length > 2) {\n            // More than 2 teams: pair off as usual, WBFL waits\n            for(let i = 0; i < losersBracketTeams.length; i += 2){\n                const team1 = losersBracketTeams[i];\n                var _losersBracketTeams_;\n                const team2 = (_losersBracketTeams_ = losersBracketTeams[i + 1]) !== null && _losersBracketTeams_ !== void 0 ? _losersBracketTeams_ : null;\n                nextRoundMatches.push(createMatch(\"L\".concat(nextRoundNumber, \"-\").concat(Math.floor(i / 2) + 1), nextRoundNumber, team1, team2, !team2, \"losers\"));\n            }\n            nextRoundMatches.push(createMatch(\"WinnersFinalLoser-waiting-\".concat(nextRoundNumber), nextRoundNumber, tournament.winnersBracketFinalLoser, null, true, \"losers\"));\n        } else {\n            // WBFL is waiting for the losers bracket to resolve\n            nextRoundMatches.push(createMatch(\"WinnersFinalLoser-waiting-\".concat(nextRoundNumber), nextRoundNumber, tournament.winnersBracketFinalLoser, null, true, \"losers\"));\n        }\n        // Always show a waiting card for the winners bracket champion if not in championship\n        nextRoundMatches.push(createMatch(\"WinnersBracketChampion-waiting-\".concat(nextRoundNumber), nextRoundNumber, winnersBracketTeams[0], null, true, \"winners\"));\n    } else if (winnersBracketTeams.length === 2) {\n        // Create the winner's bracket final match\n        nextRoundMatches.push(createMatch(\"W\".concat(nextRoundNumber, \"-1\"), nextRoundNumber, winnersBracketTeams[0], winnersBracketTeams[1], false, \"winners\"));\n        // Continue with losers bracket matches separately\n        createLosersBracketMatches();\n    } else {\n        createStandardBracketMatches();\n    }\n    // Helper function to create standard bracket matches\n    function createStandardBracketMatches() {\n        // --- Winners Bracket Matches ---\n        let matchCounter = 1;\n        for(let i = 0; i < winnersBracketTeams.length; i += 2){\n            const team1 = winnersBracketTeams[i];\n            var _winnersBracketTeams_;\n            const team2 = (_winnersBracketTeams_ = winnersBracketTeams[i + 1]) !== null && _winnersBracketTeams_ !== void 0 ? _winnersBracketTeams_ : null;\n            const isBye = !team2;\n            nextRoundMatches.push(createMatch(\"W\".concat(nextRoundNumber, \"-\").concat(matchCounter), nextRoundNumber, team1, team2, isBye, \"winners\"));\n            matchCounter++;\n        }\n        // Create losers bracket matches separately\n        createLosersBracketMatches();\n    }\n    // Helper function to create losers bracket matches\n    function createLosersBracketMatches() {\n        // --- Losers Bracket Matches ---\n        const eligibleLosers = allTeams.filter((team)=>(lossCounts[team.id] || 0) === 1 && !tournament.eliminatedTeams.some((t)=>t.id === team.id) && !newlyEliminated.some((t)=>t.id === team.id) && // Exclude winner's bracket final loser if it exists\n            !(tournament.winnersBracketFinalLoser && tournament.winnersBracketFinalLoser.id === team.id));\n        // Find teams recently dropped from winners bracket\n        const justDroppedFromWinners = currentRound.matches.filter((m)=>m.bracket === \"winners\" && m.loser && m.isCompleted).map((m)=>m.loser).filter((loser)=>eligibleLosers.some((t)=>t.id === loser.id));\n        // If this is the winner's bracket final, store the loser for later use\n        if (currentRound.matches.some((m)=>m.bracket === \"winners\" && winnersBracketTeams.length === 1 && m.loser && m.isCompleted)) {\n            // This is a special case - we found the winner's bracket final loser\n            const winnersFinalLoser = currentRound.matches.filter((m)=>m.bracket === \"winners\" && m.isCompleted && m.loser).map((m)=>m.loser).pop();\n            if (winnersFinalLoser && !tournament.eliminatedTeams.some((t)=>t.id === winnersFinalLoser.id)) {\n                tournament.winnersBracketFinalLoser = winnersFinalLoser;\n            }\n        }\n        // Existing losers bracket teams\n        const existingLosers = eligibleLosers.filter((t)=>!justDroppedFromWinners.some((jd)=>jd.id === t.id));\n        // Order: most recent drop(s) first\n        const orderedLosers = [\n            ...justDroppedFromWinners,\n            ...existingLosers\n        ];\n        if (orderedLosers.length > 0) {\n            if (orderedLosers.length % 2 === 1) {\n                // Odd: bye goes to the most recent team dropped from winners bracket\n                let teamWithBye = null;\n                if (justDroppedFromWinners.length > 0) {\n                    teamWithBye = justDroppedFromWinners[justDroppedFromWinners.length - 1];\n                    // Remove the bye team from orderedLosers\n                    const byeIndex = orderedLosers.findIndex((t)=>t.id === teamWithBye.id);\n                    if (byeIndex !== -1) orderedLosers.splice(byeIndex, 1);\n                } else {\n                    // Defensive: fallback to first team if no recent drop\n                    teamWithBye = orderedLosers.shift();\n                }\n                nextRoundMatches.push(createMatch(\"L\".concat(nextRoundNumber, \"-1\"), nextRoundNumber, teamWithBye, null, true, \"losers\"));\n                // Pair the rest\n                for(let i = 0; i < orderedLosers.length; i += 2){\n                    const team1 = orderedLosers[i];\n                    var _orderedLosers_;\n                    const team2 = (_orderedLosers_ = orderedLosers[i + 1]) !== null && _orderedLosers_ !== void 0 ? _orderedLosers_ : null;\n                    nextRoundMatches.push(createMatch(\"L\".concat(nextRoundNumber, \"-\").concat(Math.floor(i / 2) + 2), nextRoundNumber, team1, team2, !team2, \"losers\"));\n                }\n            } else {\n                // Even number: pair all\n                for(let i = 0; i < orderedLosers.length; i += 2){\n                    const team1 = orderedLosers[i];\n                    var _orderedLosers_1;\n                    const team2 = (_orderedLosers_1 = orderedLosers[i + 1]) !== null && _orderedLosers_1 !== void 0 ? _orderedLosers_1 : null;\n                    nextRoundMatches.push(createMatch(\"L\".concat(nextRoundNumber, \"-\").concat(Math.floor(i / 2) + 1), nextRoundNumber, team1, team2, !team2, \"losers\"));\n                }\n            }\n        }\n    }\n    // --- Winner detection logic ---\n    let winner = tournament.winner;\n    if (isChampionshipRound) {\n        // Find the last championship match played\n        const lastChampMatch = championshipMatches[0] || prevChampionshipMatches[prevChampionshipMatches.length - 1];\n        if (lastChampMatch && lastChampMatch.isCompleted && lastChampMatch.winner && lastChampMatch.loser) {\n            const winnersBracketTeam = lastChampMatch.team1;\n            const losersBracketTeam = lastChampMatch.team2;\n            const losersBracketTeamWon = losersBracketTeam && lastChampMatch.winner.id === losersBracketTeam.id;\n            // If loser's bracket team won first championship match, winner's bracket team gets another chance\n            if (losersBracketTeamWon && tournament.championshipMatchesPlayed === 1) {\n                winner = undefined; // No winner yet, need reset match\n            } else {\n                // Either winner's bracket team won first match, or this was the reset match\n                winner = lastChampMatch.winner;\n            }\n        }\n    }\n    // --- INFINITE RECURSION GUARD ---\n    const noMoreMatches = isChampionshipRound && championshipMatches.length === 0 || !isChampionshipRound && nextRoundMatches.length === 0;\n    if (noMoreMatches) {\n        // Tournament is over, do not advance further\n        return {\n            ...tournament,\n            winner,\n            currentRound: tournament.currentRound\n        };\n    }\n    // Debug log before returning the new tournament object\n    (0,_logTournamentState__WEBPACK_IMPORTED_MODULE_0__.logTournamentState)({\n        roundNumber: nextRoundNumber,\n        winnersBracketTeams,\n        losersBracketTeams,\n        matches: isChampionshipRound ? championshipMatches : nextRoundMatches,\n        winnersBracketFinalLoser: tournament.winnersBracketFinalLoser\n    });\n    // Compose the new tournament object\n    return {\n        ...tournament,\n        rounds: [\n            ...tournament.rounds,\n            {\n                roundNumber: nextRoundNumber,\n                matches: isChampionshipRound ? championshipMatches : nextRoundMatches,\n                isDoubleElimination: true,\n                isChampionshipRound\n            }\n        ],\n        currentRound: nextRoundNumber,\n        eliminatedTeams: [\n            ...tournament.eliminatedTeams,\n            ...newlyEliminated.filter((t)=>!tournament.eliminatedTeams.some((et)=>et.id === t.id))\n        ],\n        championshipMatchesPlayed: isChampionshipRound ? tournament.championshipMatchesPlayed + 1 : tournament.championshipMatchesPlayed,\n        winnersBracketFinalLoser: tournament.winnersBracketFinalLoser,\n        winner\n    };\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3R5cGVzL3RvdXJuYW1lbnQvbWF0Y2hlcy50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUMwRDtBQW1DbkQsTUFBTUMsY0FBYyxTQUN6QkMsSUFDQUMsYUFDQUMsT0FDQUM7UUFDQUMseUVBQWlCLE9BQ2pCQywyRUFBaUQsV0FDakRDLDREQUNBQztRQVNpQkw7V0FSTjtRQUNYRjtRQUNBQztRQUNBQztRQUNBQztRQUNBSyxhQUFhSjtRQUNiQTtRQUNBQztRQUNBSSxRQUFRTCxRQUFTRixDQUFBQSxPQUFBQSxrQkFBQUEsbUJBQUFBLFFBQVNDLG1CQUFURCxrQkFBQUEsT0FBa0JRLFlBQWFBO1FBQ2hEQyxPQUFPUCxRQUFRTSxZQUFZQTtRQUMzQkUsT0FBTztZQUFFQyxZQUFZO1lBQUdDLFlBQVk7UUFBRTtRQUN0Q1I7UUFDQUM7UUFDQVEsaUJBQWlCTDtJQUNuQjtBQUFBLEVBQUc7QUFFSSxNQUFNTSxzQkFBc0IsQ0FBQ0M7SUFDbEMsTUFBTUMsV0FBV0QsTUFBTUUsTUFBTTtJQUM3QixNQUFNQyxVQUFtQixFQUFFO0lBQzNCLE1BQU1DLFlBQVlDLEtBQUtDLElBQUksQ0FBQ0QsS0FBS0UsSUFBSSxDQUFDTjtJQUV0QyxNQUFNTyxvQkFBb0JILEtBQUtJLEdBQUcsQ0FBQyxHQUFHTCxZQUFZO0lBQ2xELElBQUlNLGVBQWU7SUFFbkIsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlILG1CQUFtQkcsSUFBSztRQUMxQyxNQUFNMUIsUUFBUWUsS0FBSyxDQUFDVyxJQUFJLEVBQUUsSUFBSTtRQUM5QixNQUFNekIsUUFBUWMsS0FBSyxDQUFDVyxJQUFJLElBQUksRUFBRSxJQUFJO1FBQ2xDLE1BQU14QixRQUFRLENBQUNGLFNBQVMsQ0FBQ0M7UUFFekIsTUFBTTBCLFVBQVUsTUFBbUIsT0FBYkY7UUFDdEIsTUFBTXJCLGNBQWMsTUFBa0MsT0FBNUJnQixLQUFLQyxJQUFJLENBQUNJLGVBQWU7UUFDbkQsTUFBTXBCLG1CQUFtQixN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QUFDLENBQUN3QyxLQUFPQSxHQUFHeEcsRUFBRSxLQUFLaUUsRUFBRWpFLEVBQUU7U0FFakU7UUFDRG9DLDJCQUEyQkgsc0JBQ3ZCdUIsV0FBV3BCLHlCQUF5QixHQUFHLElBQ3ZDb0IsV0FBV3BCLHlCQUF5QjtRQUN4Q2tDLDBCQUEwQmQsV0FBV2Msd0JBQXdCO1FBQzdEN0Q7SUFDRjtBQUNGLEVBQUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vdHlwZXMvdG91cm5hbWVudC9tYXRjaGVzLnRzP2RhMjIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUgeyBUZWFtIH0gZnJvbSBcIi4vbWxiLXRlYW1zXCI7XG5pbXBvcnQgeyBsb2dUb3VybmFtZW50U3RhdGUgfSBmcm9tIFwiLi9sb2dUb3VybmFtZW50U3RhdGVcIjtcblxuZXhwb3J0IGludGVyZmFjZSBNYXRjaCB7XG4gIGlkOiBzdHJpbmc7XG4gIHJvdW5kTnVtYmVyOiBudW1iZXI7XG4gIHRlYW0xOiBUZWFtIHwgbnVsbDtcbiAgdGVhbTI6IFRlYW0gfCBudWxsO1xuICBpc0NvbXBsZXRlZDogYm9vbGVhbjtcbiAgaXNCeWU/OiBib29sZWFuO1xuICB3aW5uZXI/OiBUZWFtO1xuICBsb3Nlcj86IFRlYW07XG4gIGJyYWNrZXQ6IFwid2lubmVyc1wiIHwgXCJsb3NlcnNcIiB8IFwiY2hhbXBpb25zaGlwXCI7XG4gIHNjb3JlOiB7IHRlYW0xU2NvcmU6IG51bWJlcjsgdGVhbTJTY29yZTogbnVtYmVyIH07XG4gIG5leHRNYXRjaElkPzogc3RyaW5nO1xuICBuZXh0TG9zZXJNYXRjaElkPzogc3RyaW5nO1xuICBlbGltaW5hdGVkTGFiZWw/OiBzdHJpbmc7IC8vIGxhYmVsIGZvciBlbGltaW5hdGVkIHRlYW1zIGluIGxvc2VycyBicmFja2V0XG4gIHJlcXVpcmVzUmVtYXRjaD86IGJvb2xlYW47IC8vIGluZGljYXRlcyBpZiBhIGNoYW1waW9uc2hpcCByZW1hdGNoIGlzIHJlcXVpcmVkXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUm91bmQge1xuICByb3VuZE51bWJlcjogbnVtYmVyO1xuICBtYXRjaGVzOiBNYXRjaFtdO1xuICBpc0RvdWJsZUVsaW1pbmF0aW9uOiBib29sZWFuO1xuICBpc0NoYW1waW9uc2hpcFJvdW5kOiBib29sZWFuO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFRvdXJuYW1lbnQge1xuICByb3VuZHM6IFJvdW5kW107XG4gIGN1cnJlbnRSb3VuZDogbnVtYmVyO1xuICBlbGltaW5hdGVkVGVhbXM6IFRlYW1bXTtcbiAgY2hhbXBpb25zaGlwTWF0Y2hlc1BsYXllZDogbnVtYmVyO1xuICB3aW5uZXI/OiBUZWFtO1xuICB3aW5uZXJzQnJhY2tldEZpbmFsTG9zZXI/OiBUZWFtOyAvLyB0cmFja3MgdGhlIHdpbm5lcidzIGJyYWNrZXQgZmluYWwgbG9zZXIgZm9yIGNoYW1waW9uc2hpcCByZW1hdGNoIGxvZ2ljXG59XG5cbmV4cG9ydCBjb25zdCBjcmVhdGVNYXRjaCA9IChcbiAgaWQ6IHN0cmluZyxcbiAgcm91bmROdW1iZXI6IG51bWJlcixcbiAgdGVhbTE6IFRlYW0gfCBudWxsLFxuICB0ZWFtMjogVGVhbSB8IG51bGwsXG4gIGlzQnllOiBib29sZWFuID0gZmFsc2UsXG4gIGJyYWNrZXQ6IFwid2lubmVyc1wiIHwgXCJsb3NlcnNcIiB8IFwiY2hhbXBpb25zaGlwXCIgPSBcIndpbm5lcnNcIixcbiAgbmV4dE1hdGNoSWQ/OiBzdHJpbmcsXG4gIG5leHRMb3Nlck1hdGNoSWQ/OiBzdHJpbmdcbik6IE1hdGNoID0+ICh7XG4gIGlkLFxuICByb3VuZE51bWJlcixcbiAgdGVhbTEsXG4gIHRlYW0yLFxuICBpc0NvbXBsZXRlZDogaXNCeWUsXG4gIGlzQnllLFxuICBicmFja2V0LFxuICB3aW5uZXI6IGlzQnllID8gKHRlYW0xID8/IHRlYW0yID8/IHVuZGVmaW5lZCkgOiB1bmRlZmluZWQsXG4gIGxvc2VyOiBpc0J5ZSA/IHVuZGVmaW5lZCA6IHVuZGVmaW5lZCxcbiAgc2NvcmU6IHsgdGVhbTFTY29yZTogMCwgdGVhbTJTY29yZTogMCB9LFxuICBuZXh0TWF0Y2hJZCxcbiAgbmV4dExvc2VyTWF0Y2hJZCxcbiAgZWxpbWluYXRlZExhYmVsOiB1bmRlZmluZWRcbn0pO1xuXG5leHBvcnQgY29uc3QgY3JlYXRlSW5pdGlhbFJvdW5kcyA9ICh0ZWFtczogVGVhbVtdKTogVG91cm5hbWVudCA9PiB7XG4gIGNvbnN0IG51bVRlYW1zID0gdGVhbXMubGVuZ3RoO1xuICBjb25zdCBtYXRjaGVzOiBNYXRjaFtdID0gW107XG4gIGNvbnN0IG51bVJvdW5kcyA9IE1hdGguY2VpbChNYXRoLmxvZzIobnVtVGVhbXMpKTtcblxuICBjb25zdCBmaXJzdFJvdW5kTWF0Y2hlcyA9IE1hdGgucG93KDIsIG51bVJvdW5kcyAtIDEpO1xuICBsZXQgbWF0Y2hDb3VudGVyID0gMTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGZpcnN0Um91bmRNYXRjaGVzOyBpKyspIHtcbiAgICBjb25zdCB0ZWFtMSA9IHRlYW1zW2kgKiAyXSB8fCBudWxsO1xuICAgIGNvbnN0IHRlYW0yID0gdGVhbXNbaSAqIDIgKyAxXSB8fCBudWxsO1xuICAgIGNvbnN0IGlzQnllID0gIXRlYW0xIHx8ICF0ZWFtMjtcblxuICAgIGNvbnN0IG1hdGNoSWQgPSBgVzEtJHttYXRjaENvdW50ZXJ9YDtcbiAgICBjb25zdCBuZXh0TWF0Y2hJZCA9IGBXMi0ke01hdGguY2VpbChtYXRjaENvdW50ZXIgLyAyKX1gO1xuICAgIGNvbnN0IG5leHRMb3Nlck1hdGNoSWQgPSBgTDEtJHtNYXRoLmNlaWwobWF0Y2hDb3VudGVyIC8gMil9YDtcblxuICAgIG1hdGNoZXMucHVzaChcbiAgICAgIGNyZWF0ZU1hdGNoKFxuICAgICAgICBtYXRjaElkLFxuICAgICAgICAxLFxuICAgICAgICB0ZWFtMSxcbiAgICAgICAgdGVhbTIsXG4gICAgICAgIGlzQnllLFxuICAgICAgICBcIndpbm5lcnNcIixcbiAgICAgICAgbmV4dE1hdGNoSWQsXG4gICAgICAgIG5leHRMb3Nlck1hdGNoSWRcbiAgICAgIClcbiAgICApO1xuICAgIG1hdGNoQ291bnRlcisrO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICByb3VuZHM6IFtcbiAgICAgIHtcbiAgICAgICAgcm91bmROdW1iZXI6IDEsXG4gICAgICAgIG1hdGNoZXMsXG4gICAgICAgIGlzRG91YmxlRWxpbWluYXRpb246IHRydWUsXG4gICAgICAgIGlzQ2hhbXBpb25zaGlwUm91bmQ6IGZhbHNlXG4gICAgICB9XG4gICAgXSxcbiAgICBjdXJyZW50Um91bmQ6IDEsXG4gICAgZWxpbWluYXRlZFRlYW1zOiBbXSxcbiAgICBjaGFtcGlvbnNoaXBNYXRjaGVzUGxheWVkOiAwXG4gIH07XG59O1xuXG5leHBvcnQgY29uc3QgdXBkYXRlTWF0Y2hTY29yZSA9IChcbiAgbWF0Y2g6IE1hdGNoLFxuICBuZXdTY29yZTogeyB0ZWFtMVNjb3JlOiBudW1iZXI7IHRlYW0yU2NvcmU6IG51bWJlciB9XG4pOiBNYXRjaCA9PiB7XG4gIGNvbnN0IGlzQ29tcGxldGVkID0gbmV3U2NvcmUudGVhbTFTY29yZSAhPT0gbmV3U2NvcmUudGVhbTJTY29yZTtcbiAgbGV0IHdpbm5lcjogVGVhbSB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcbiAgbGV0IGxvc2VyOiBUZWFtIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuICBpZiAoaXNDb21wbGV0ZWQpIHtcbiAgICBpZiAobmV3U2NvcmUudGVhbTFTY29yZSA+IG5ld1Njb3JlLnRlYW0yU2NvcmUpIHtcbiAgICAgIHdpbm5lciA9IG1hdGNoLnRlYW0xID8geyAuLi5tYXRjaC50ZWFtMSwgd2luczogKG1hdGNoLnRlYW0xLndpbnMgPz8gMCkgKyAxLCBsb3NzZXM6IG1hdGNoLnRlYW0xLmxvc3NlcyA/PyAwIH0gOiB1bmRlZmluZWQ7XG4gICAgICBsb3NlciA9IG1hdGNoLnRlYW0yID8geyAuLi5tYXRjaC50ZWFtMiwgd2luczogbWF0Y2gudGVhbTIud2lucyA/PyAwLCBsb3NzZXM6IChtYXRjaC50ZWFtMi5sb3NzZXMgPz8gMCkgKyAxIH0gOiB1bmRlZmluZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdpbm5lciA9IG1hdGNoLnRlYW0yID8geyAuLi5tYXRjaC50ZWFtMiwgd2luczogKG1hdGNoLnRlYW0yLndpbnMgPz8gMCkgKyAxLCBsb3NzZXM6IG1hdGNoLnRlYW0yLmxvc3NlcyA/PyAwIH0gOiB1bmRlZmluZWQ7XG4gICAgICBsb3NlciA9IG1hdGNoLnRlYW0xID8geyAuLi5tYXRjaC50ZWFtMSwgd2luczogbWF0Y2gudGVhbTEud2lucyA/PyAwLCBsb3NzZXM6IChtYXRjaC50ZWFtMS5sb3NzZXMgPz8gMCkgKyAxIH0gOiB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgLi4ubWF0Y2gsXG4gICAgc2NvcmU6IG5ld1Njb3JlLFxuICAgIGlzQ29tcGxldGVkLFxuICAgIHdpbm5lcixcbiAgICBsb3NlclxuICB9O1xufTtcblxuLy8gSGVscGVyIHRvIGRlZHVwbGljYXRlIHRlYW1zIGJ5IElEXG5mdW5jdGlvbiBkZWR1cGVUZWFtcyh0ZWFtczogVGVhbVtdKTogVGVhbVtdIHtcbiAgY29uc3Qgc2VlbiA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuICByZXR1cm4gdGVhbXMuZmlsdGVyKHRlYW0gPT4ge1xuICAgIGlmICghdGVhbSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChzZWVuLmhhcyh0ZWFtLmlkKSkgcmV0dXJuIGZhbHNlO1xuICAgIHNlZW4uYWRkKHRlYW0uaWQpO1xuICAgIHJldHVybiB0cnVlO1xuICB9KTtcbn1cblxuLy8gSGVscGVyOiBnZXQgYWxsIHRlYW1zIHdpdGggZXhhY3RseSBOIGxvc3Nlc1xuZnVuY3Rpb24gdGVhbXNXaXRoTG9zc2VzKGxvc3NDb3VudHM6IFJlY29yZDxzdHJpbmcsIG51bWJlcj4sIG46IG51bWJlcik6IHN0cmluZ1tdIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKGxvc3NDb3VudHMpLmZpbHRlcih0ZWFtSWQgPT4gbG9zc0NvdW50c1t0ZWFtSWRdID09PSBuKTtcbn1cbmV4cG9ydCBjb25zdCBhZHZhbmNlVG9OZXh0Um91bmQgPSAodG91cm5hbWVudDogVG91cm5hbWVudCk6IFRvdXJuYW1lbnQgPT4ge1xuICBjb25zdCBjdXJyZW50Um91bmQgPSB0b3VybmFtZW50LnJvdW5kc1t0b3VybmFtZW50LnJvdW5kcy5sZW5ndGggLSAxXTtcbiAgY29uc3QgbmV4dFJvdW5kTnVtYmVyID0gdG91cm5hbWVudC5jdXJyZW50Um91bmQgKyAxO1xuXG4gIC8vIFRyYWNrIGFsbCBsb3NzZXMgYW5kIHdpbnMgYWNyb3NzIHRoZSB0b3VybmFtZW50XG4gIGNvbnN0IGxvc3NDb3VudHM6IFJlY29yZDxzdHJpbmcsIG51bWJlcj4gPSB7fTtcbiAgY29uc3Qgd2luc0NvdW50czogUmVjb3JkPHN0cmluZywgbnVtYmVyPiA9IHt9O1xuICB0b3VybmFtZW50LnJvdW5kcy5mb3JFYWNoKChyb3VuZCkgPT4ge1xuICAgIHJvdW5kLm1hdGNoZXMuZm9yRWFjaCgobWF0Y2gpID0+IHtcbiAgICAgIGlmIChtYXRjaC5pc0NvbXBsZXRlZCAmJiBtYXRjaC5sb3Nlcikge1xuICAgICAgICBsb3NzQ291bnRzW21hdGNoLmxvc2VyLmlkXSA9IChsb3NzQ291bnRzW21hdGNoLmxvc2VyLmlkXSB8fCAwKSArIDE7XG4gICAgICB9XG4gICAgICBpZiAobWF0Y2guaXNDb21wbGV0ZWQgJiYgbWF0Y2gud2lubmVyKSB7XG4gICAgICAgIHdpbnNDb3VudHNbbWF0Y2gud2lubmVyLmlkXSA9ICh3aW5zQ291bnRzW21hdGNoLndpbm5lci5pZF0gfHwgMCkgKyAxO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcblxuICAvLyBXSU5ORVIgR1VBUkQ6IElmIGEgd2lubmVyIGhhcyBhbHJlYWR5IGJlZW4gZGV0ZXJtaW5lZCwgZG8gbm90IGNyZWF0ZSBhbnkgbW9yZSByb3VuZHNcbiAgaWYgKHRvdXJuYW1lbnQud2lubmVyKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnRvdXJuYW1lbnQsXG4gICAgICBjdXJyZW50Um91bmQ6IHRvdXJuYW1lbnQuY3VycmVudFJvdW5kXG4gICAgfTtcbiAgfVxuXG4gIC8vIEdhdGhlciBhbGwgdGVhbXMgZXZlciBpbiB0aGUgdG91cm5hbWVudCwgYXR0YWNoaW5nIHdpbnNcbiAgY29uc3QgYWxsVGVhbXM6IFRlYW1bXSA9IFtdO1xuICBjb25zdCB0ZWFtSWRzID0gbmV3IFNldDxzdHJpbmc+KCk7XG4gIGZvciAoY29uc3Qgcm91bmQgb2YgdG91cm5hbWVudC5yb3VuZHMpIHtcbiAgICBmb3IgKGNvbnN0IG1hdGNoIG9mIHJvdW5kLm1hdGNoZXMpIHtcbiAgICAgIGlmIChtYXRjaC50ZWFtMSAmJiAhdGVhbUlkcy5oYXMobWF0Y2gudGVhbTEuaWQpKSB7XG4gICAgICAgIGFsbFRlYW1zLnB1c2goe1xuICAgICAgICAgIC4uLm1hdGNoLnRlYW0xLFxuICAgICAgICAgIHdpbnM6IHdpbnNDb3VudHNbbWF0Y2gudGVhbTEuaWRdIHx8IDAsXG4gICAgICAgICAgbG9zc2VzOiBsb3NzQ291bnRzW21hdGNoLnRlYW0xLmlkXSB8fCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0ZWFtSWRzLmFkZChtYXRjaC50ZWFtMS5pZCk7XG4gICAgICB9XG4gICAgICBpZiAobWF0Y2gudGVhbTIgJiYgIXRlYW1JZHMuaGFzKG1hdGNoLnRlYW0yLmlkKSkge1xuICAgICAgICBhbGxUZWFtcy5wdXNoKHtcbiAgICAgICAgICAuLi5tYXRjaC50ZWFtMixcbiAgICAgICAgICB3aW5zOiB3aW5zQ291bnRzW21hdGNoLnRlYW0yLmlkXSB8fCAwLFxuICAgICAgICAgIGxvc3NlczogbG9zc0NvdW50c1ttYXRjaC50ZWFtMi5pZF0gfHwgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGVhbUlkcy5hZGQobWF0Y2gudGVhbTIuaWQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIElkZW50aWZ5IG5ld2x5IGVsaW1pbmF0ZWQgdGVhbXMgKDIgbG9zc2VzKVxuICBjb25zdCBuZXdseUVsaW1pbmF0ZWQ6IFRlYW1bXSA9IFtdO1xuICBmb3IgKGNvbnN0IHRlYW0gb2YgYWxsVGVhbXMpIHtcbiAgICBpZiAoXG4gICAgICAobG9zc0NvdW50c1t0ZWFtLmlkXSB8fCAwKSA+PSAyICYmXG4gICAgICAhdG91cm5hbWVudC5lbGltaW5hdGVkVGVhbXMuc29tZSgodCkgPT4gdC5pZCA9PT0gdGVhbS5pZClcbiAgICApIHtcbiAgICAgIG5ld2x5RWxpbWluYXRlZC5wdXNoKHRlYW0pO1xuICAgIH1cbiAgfVxuXG4gIC8vIFdpbm5lcnM6IHRlYW1zIHdpdGggMCBsb3NzZXMgYW5kIG5vdCBlbGltaW5hdGVkXG4gIGNvbnN0IHdpbm5lcnNCcmFja2V0VGVhbXMgPSBhbGxUZWFtc1xuICAgIC5maWx0ZXIoXG4gICAgICAodGVhbSkgPT5cbiAgICAgICAgKGxvc3NDb3VudHNbdGVhbS5pZF0gfHwgMCkgPT09IDAgJiZcbiAgICAgICAgIXRvdXJuYW1lbnQuZWxpbWluYXRlZFRlYW1zLnNvbWUoKHQpID0+IHQuaWQgPT09IHRlYW0uaWQpICYmXG4gICAgICAgICFuZXdseUVsaW1pbmF0ZWQuc29tZSgodCkgPT4gdC5pZCA9PT0gdGVhbS5pZCkgJiZcbiAgICAgICAgIXRlYW0uaWQuc3RhcnRzV2l0aChcInRiZC1cIikgLy8gRXhjbHVkZSBwaGFudG9tIFRCRCB0ZWFtc1xuICAgIClcbiAgICAubWFwKCh0ZWFtKSA9PiAoe1xuICAgICAgLi4udGVhbSxcbiAgICAgIGxvc3NlczogbG9zc0NvdW50c1t0ZWFtLmlkXSB8fCAwLFxuICAgICAgd2luczogd2luc0NvdW50c1t0ZWFtLmlkXSB8fCAwXG4gICAgfSkpO1xuXG4gIC8vIExvc2VyczogdGVhbXMgd2l0aCAxIGxvc3MgYW5kIG5vdCBlbGltaW5hdGVkXG4gIGNvbnN0IGxvc2Vyc0JyYWNrZXRUZWFtcyA9IGFsbFRlYW1zXG4gICAgLmZpbHRlcihcbiAgICAgICh0ZWFtKSA9PlxuICAgICAgICAobG9zc0NvdW50c1t0ZWFtLmlkXSB8fCAwKSA9PT0gMSAmJlxuICAgICAgICAhdG91cm5hbWVudC5lbGltaW5hdGVkVGVhbXMuc29tZSgodCkgPT4gdC5pZCA9PT0gdGVhbS5pZCkgJiZcbiAgICAgICAgIW5ld2x5RWxpbWluYXRlZC5zb21lKCh0KSA9PiB0LmlkID09PSB0ZWFtLmlkKSAmJlxuICAgICAgICAvLyBEb24ndCBpbmNsdWRlIHRoZSB3aW5uZXJzIGJyYWNrZXQgZmluYWwgbG9zZXIgaW4gcmVndWxhciBsb3NlcnMgYnJhY2tldCB0ZWFtc1xuICAgICAgICAhKFxuICAgICAgICAgIHRvdXJuYW1lbnQud2lubmVyc0JyYWNrZXRGaW5hbExvc2VyICYmXG4gICAgICAgICAgdG91cm5hbWVudC53aW5uZXJzQnJhY2tldEZpbmFsTG9zZXIuaWQgPT09IHRlYW0uaWRcbiAgICAgICAgKVxuICAgIClcbiAgICAubWFwKCh0ZWFtKSA9PiAoe1xuICAgICAgLi4udGVhbSxcbiAgICAgIGxvc3NlczogbG9zc0NvdW50c1t0ZWFtLmlkXSB8fCAwLFxuICAgICAgd2luczogd2luc0NvdW50c1t0ZWFtLmlkXSB8fCAwXG4gICAgfSkpO1xuXG4gIGxldCBpc0NoYW1waW9uc2hpcFJvdW5kID0gZmFsc2U7XG4gIGxldCBjaGFtcGlvbnNoaXBNYXRjaGVzOiBNYXRjaFtdID0gW107XG4gIGxldCBuZXh0Um91bmRNYXRjaGVzOiBNYXRjaFtdID0gW107XG5cbiAgY29uc3QgcHJldkNoYW1waW9uc2hpcE1hdGNoZXMgPSB0b3VybmFtZW50LnJvdW5kc1xuICAgIC5maWx0ZXIoKHIpID0+IHIuaXNDaGFtcGlvbnNoaXBSb3VuZClcbiAgICAuZmxhdE1hcCgocikgPT4gci5tYXRjaGVzKVxuICAgIC5maWx0ZXIoKG0pID0+IG0uYnJhY2tldCA9PT0gXCJjaGFtcGlvbnNoaXBcIik7XG5cbiAgLy8gLS0tIENIQU1QSU9OU0hJUCBMT0dJQyAtLS1cblxuICAvLyBDaGVjayBpZiBhIGNoYW1waW9uc2hpcCBtYXRjaCBhbHJlYWR5IGhhcHBlbmVkIGFuZCB3YXMgY29tcGxldGVkXG4gIGlmIChcbiAgICBwcmV2Q2hhbXBpb25zaGlwTWF0Y2hlcy5sZW5ndGggPj0gMSAmJlxuICAgIHByZXZDaGFtcGlvbnNoaXBNYXRjaGVzW3ByZXZDaGFtcGlvbnNoaXBNYXRjaGVzLmxlbmd0aCAtIDFdLmlzQ29tcGxldGVkXG4gICkge1xuICAgIGNvbnN0IGxhc3RDaGFtcE1hdGNoID1cbiAgICAgIHByZXZDaGFtcGlvbnNoaXBNYXRjaGVzW3ByZXZDaGFtcGlvbnNoaXBNYXRjaGVzLmxlbmd0aCAtIDFdO1xuICAgIGNvbnN0IHdpbm5lcnNCcmFja2V0VGVhbSA9IGxhc3RDaGFtcE1hdGNoLnRlYW0xO1xuICAgIGNvbnN0IGxvc2Vyc0JyYWNrZXRUZWFtID0gbGFzdENoYW1wTWF0Y2gudGVhbTI7XG5cbiAgICAvLyBJZiBsb3NlcidzIGJyYWNrZXQgdGVhbSB3b24gdGhlIGZpcnN0IGNoYW1waW9uc2hpcCBtYXRjaCwgd2lubmVyJ3MgYnJhY2tldCB0ZWFtIGdldHMgYW5vdGhlciBjaGFuY2VcbiAgICBpZiAoXG4gICAgICBsYXN0Q2hhbXBNYXRjaC53aW5uZXI/LmlkID09PSBsb3NlcnNCcmFja2V0VGVhbT8uaWQgJiZcbiAgICAgIHRvdXJuYW1lbnQuY2hhbXBpb25zaGlwTWF0Y2hlc1BsYXllZCA9PT0gMVxuICAgICkge1xuICAgICAgaXNDaGFtcGlvbnNoaXBSb3VuZCA9IHRydWU7XG4gICAgICAvLyBDcmVhdGUgdGhlIFwicmVzZXRcIiBtYXRjaFxuICAgICAgY2hhbXBpb25zaGlwTWF0Y2hlcy5wdXNoKFxuICAgICAgICBjcmVhdGVNYXRjaChcbiAgICAgICAgICBgQyR7bmV4dFJvdW5kTnVtYmVyfS0xYCxcbiAgICAgICAgICBuZXh0Um91bmROdW1iZXIsXG4gICAgICAgICAgd2lubmVyc0JyYWNrZXRUZWFtLFxuICAgICAgICAgIGxvc2Vyc0JyYWNrZXRUZWFtLFxuICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgIFwiY2hhbXBpb25zaGlwXCJcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRWl0aGVyIHdpbm5lcidzIGJyYWNrZXQgdGVhbSB3b24gZmlyc3QgbWF0Y2gsIG9yIHRoaXMgd2FzIHRoZSByZXNldCBtYXRjaFxuICAgICAgaXNDaGFtcGlvbnNoaXBSb3VuZCA9IHRydWU7XG4gICAgICAvLyBObyBuZXcgbWF0Y2hlcywgd2lubmVyIHdpbGwgYmUgZGV0ZXJtaW5lZCBpbiB3aW5uZXIgZGV0ZWN0aW9uIGxvZ2ljXG4gICAgfVxuICB9XG4gIC8vIENoZWNrIGlmIHdlJ3JlIHJlYWR5IGZvciB0aGUgY2hhbXBpb25zaGlwIG1hdGNoIC0gb25lIHRlYW0gaW4gZWFjaCBicmFja2V0IGFuZCBsb3NlcidzIGZpbmFsIGlzIGNvbXBsZXRlXG4gIGVsc2UgaWYgKFxuICAgIHdpbm5lcnNCcmFja2V0VGVhbXMubGVuZ3RoID09PSAxICYmXG4gICAgbG9zZXJzQnJhY2tldFRlYW1zLmxlbmd0aCA9PT0gMSAmJlxuICAgIGN1cnJlbnRSb3VuZC5tYXRjaGVzLnNvbWUoXG4gICAgICAobSkgPT5cbiAgICAgICAgKG0uYnJhY2tldCA9PT0gXCJsb3NlcnNcIiB8fCBtLmlkLmluY2x1ZGVzKFwiTG9zZXJzTGFzdFwiKSkgJiZcbiAgICAgICAgbS5pc0NvbXBsZXRlZCAmJlxuICAgICAgICBtLndpbm5lciAmJlxuICAgICAgICAobG9zZXJzQnJhY2tldFRlYW1zLnNvbWUoKHQpID0+IHQuaWQgPT09IG0ud2lubmVyIS5pZCkgfHxcbiAgICAgICAgICAodG91cm5hbWVudC53aW5uZXJzQnJhY2tldEZpbmFsTG9zZXIgJiZcbiAgICAgICAgICAgIG0ud2lubmVyIS5pZCA9PT0gdG91cm5hbWVudC53aW5uZXJzQnJhY2tldEZpbmFsTG9zZXIuaWQpKVxuICAgIClcbiAgKSB7XG4gICAgLy8gRmluZCB0aGUgd2lubmVyIG9mIHRoZSBsb3NlcnMgYnJhY2tldCBmaW5hbFxuICAgIGNvbnN0IGxvc2Vyc0JyYWNrZXRXaW5uZXIgPSBjdXJyZW50Um91bmQubWF0Y2hlc1xuICAgICAgLmZpbHRlcihcbiAgICAgICAgKG0pID0+XG4gICAgICAgICAgKG0uYnJhY2tldCA9PT0gXCJsb3NlcnNcIiB8fCBtLmlkLmluY2x1ZGVzKFwiTG9zZXJzTGFzdFwiKSkgJiZcbiAgICAgICAgICBtLmlzQ29tcGxldGVkICYmXG4gICAgICAgICAgbS53aW5uZXJcbiAgICAgIClcbiAgICAgIC5tYXAoKG0pID0+IG0ud2lubmVyISlcbiAgICAgIC5wb3AoKTtcblxuICAgIGlmIChsb3NlcnNCcmFja2V0V2lubmVyKSB7XG4gICAgICAvLyBPbmx5IHNjaGVkdWxlIHRoZSBjaGFtcGlvbnNoaXAgaWYgdGhlcmUgaXMgbm8gd2lubmVyc0JyYWNrZXRGaW5hbExvc2VyIHdhaXRpbmcgdG8gcGxheVxuICAgICAgaWYgKCF0b3VybmFtZW50Lndpbm5lcnNCcmFja2V0RmluYWxMb3Nlcikge1xuICAgICAgICAvLyBTY2hlZHVsZSBjaGFtcGlvbnNoaXAgbWF0Y2ggaW1tZWRpYXRlbHkgKG5vIGV4dHJhIHJvdW5kKVxuICAgICAgICBuZXh0Um91bmRNYXRjaGVzLnB1c2goXG4gICAgICAgICAgY3JlYXRlTWF0Y2goXG4gICAgICAgICAgICBgQyR7bmV4dFJvdW5kTnVtYmVyfS0xYCxcbiAgICAgICAgICAgIG5leHRSb3VuZE51bWJlcixcbiAgICAgICAgICAgIHdpbm5lcnNCcmFja2V0VGVhbXNbMF0sIC8vIFdpbm5lcidzIGJyYWNrZXQgY2hhbXBpb25cbiAgICAgICAgICAgIGxvc2Vyc0JyYWNrZXRXaW5uZXIsIC8vIExvc2VyJ3MgYnJhY2tldCBjaGFtcGlvblxuICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICBcImNoYW1waW9uc2hpcFwiXG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgICBpc0NoYW1waW9uc2hpcFJvdW5kID0gdHJ1ZTtcbiAgICAgICAgLy8gRG8gTk9UIHNjaGVkdWxlIGFueSB3YWl0aW5nIGNhcmRzXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBJbnN0ZWFkLCBzY2hlZHVsZSB0aGUgbG9zZXJzIGJyYWNrZXQgZmluYWwgKExMV0IgdnMgTFdMQiksIGFuZCBzaG93IHRoZSB3aW5uZXJzIGJyYWNrZXQgY2hhbXBpb24gYXMgd2FpdGluZ1xuICAgICAgICBuZXh0Um91bmRNYXRjaGVzLnB1c2goXG4gICAgICAgICAgY3JlYXRlTWF0Y2goXG4gICAgICAgICAgICBgTG9zZXJzTGFzdC0ke25leHRSb3VuZE51bWJlcn1gLFxuICAgICAgICAgICAgbmV4dFJvdW5kTnVtYmVyLFxuICAgICAgICAgICAgdG91cm5hbWVudC53aW5uZXJzQnJhY2tldEZpbmFsTG9zZXIsXG4gICAgICAgICAgICBsb3NlcnNCcmFja2V0VGVhbXNbMF0sXG4gICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgIFwibG9zZXJzXCJcbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICAgIG5leHRSb3VuZE1hdGNoZXMucHVzaChcbiAgICAgICAgICBjcmVhdGVNYXRjaChcbiAgICAgICAgICAgIGBXaW5uZXJzQnJhY2tldENoYW1waW9uLXdhaXRpbmctJHtuZXh0Um91bmROdW1iZXJ9YCxcbiAgICAgICAgICAgIG5leHRSb3VuZE51bWJlcixcbiAgICAgICAgICAgIHdpbm5lcnNCcmFja2V0VGVhbXNbMF0sXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAgIFwid2lubmVyc1wiXG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvLyBDaGVjayBpZiB3ZSBuZWVkIHRvIGNyZWF0ZSB0aGUgZmluYWwgbG9zZXJzIGJyYWNrZXQgbWF0Y2ggKHdpbm5lcnMgYnJhY2tldCBmaW5hbCBsb3NlciB2cyBsb3NlcnMgYnJhY2tldCB3aW5uZXIpXG4gIGVsc2UgaWYgKFxuICAgIHdpbm5lcnNCcmFja2V0VGVhbXMubGVuZ3RoID09PSAxICYmXG4gICAgdG91cm5hbWVudC53aW5uZXJzQnJhY2tldEZpbmFsTG9zZXJcbiAgKSB7XG4gICAgaWYgKGxvc2Vyc0JyYWNrZXRUZWFtcy5sZW5ndGggPT09IDEpIHtcbiAgICAgIC8vIFByZXZlbnQgZHVwbGljYXRlIGxvc2VycyBicmFja2V0IGZpbmFsOiBjaGVjayBhbGwgcHJldmlvdXMgcm91bmRzIGZvciB0aGlzIG1hdGNoXG4gICAgICBsZXQgYWxyZWFkeVBsYXllZCA9IGZhbHNlO1xuICAgICAgZm9yIChsZXQgcm91bmQgb2YgdG91cm5hbWVudC5yb3VuZHMpIHtcbiAgICAgICAgaWYgKCFyb3VuZC5tYXRjaGVzKSBjb250aW51ZTtcbiAgICAgICAgZm9yIChsZXQgbSBvZiByb3VuZC5tYXRjaGVzKSB7XG4gICAgICAgICAgY29uc3QgaWRzID0gW20udGVhbTE/LmlkLCBtLnRlYW0yPy5pZF0uZmlsdGVyKEJvb2xlYW4pLnNvcnQoKTtcbiAgICAgICAgICBjb25zdCBjdXJySWRzID0gW3RvdXJuYW1lbnQud2lubmVyc0JyYWNrZXRGaW5hbExvc2VyLmlkLCBsb3NlcnNCcmFja2V0VGVhbXNbMF0uaWRdLnNvcnQoKTtcbiAgICAgICAgICBpZiAoaWRzLmxlbmd0aCA9PT0gMiAmJiBpZHNbMF0gPT09IGN1cnJJZHNbMF0gJiYgaWRzWzFdID09PSBjdXJySWRzWzFdKSB7XG4gICAgICAgICAgICBhbHJlYWR5UGxheWVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYWxyZWFkeVBsYXllZCkgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoIWFscmVhZHlQbGF5ZWQpIHtcbiAgICAgICAgLy8gT25seSBub3cgc2NoZWR1bGUgV0JGTCB2cyBMQkxcbiAgICAgICAgbmV4dFJvdW5kTWF0Y2hlcy5wdXNoKFxuICAgICAgICAgIGNyZWF0ZU1hdGNoKFxuICAgICAgICAgICAgYExvc2Vyc0xhc3QtJHtuZXh0Um91bmROdW1iZXJ9YCxcbiAgICAgICAgICAgIG5leHRSb3VuZE51bWJlcixcbiAgICAgICAgICAgIHRvdXJuYW1lbnQud2lubmVyc0JyYWNrZXRGaW5hbExvc2VyLFxuICAgICAgICAgICAgbG9zZXJzQnJhY2tldFRlYW1zWzBdLFxuICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICBcImxvc2Vyc1wiXG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgLy8gSWYgbWF0Y2ggYWxyZWFkeSBwbGF5ZWQsIGRvIG5vdCBzY2hlZHVsZSBhZ2FpbjsgY2hhbXBpb25zaGlwIGxvZ2ljIHdpbGwgaGFuZGxlIG5leHQgc3RlcFxuICAgIH0gZWxzZSBpZiAobG9zZXJzQnJhY2tldFRlYW1zLmxlbmd0aCA9PT0gMikge1xuICAgICAgLy8gU2NoZWR1bGUgdGhlIG1hdGNoIGJldHdlZW4gdGhlIGxhc3QgdHdvIGxvc2VycyBicmFja2V0IHRlYW1zXG4gICAgICBuZXh0Um91bmRNYXRjaGVzLnB1c2goXG4gICAgICAgIGNyZWF0ZU1hdGNoKFxuICAgICAgICAgIGBMJHtuZXh0Um91bmROdW1iZXJ9LTFgLFxuICAgICAgICAgIG5leHRSb3VuZE51bWJlcixcbiAgICAgICAgICBsb3NlcnNCcmFja2V0VGVhbXNbMF0sXG4gICAgICAgICAgbG9zZXJzQnJhY2tldFRlYW1zWzFdLFxuICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgIFwibG9zZXJzXCJcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICAgIC8vIFdCRkwgaXMgd2FpdGluZyBmb3IgdGhlIHdpbm5lclxuICAgICAgbmV4dFJvdW5kTWF0Y2hlcy5wdXNoKFxuICAgICAgICBjcmVhdGVNYXRjaChcbiAgICAgICAgICBgV2lubmVyc0ZpbmFsTG9zZXItd2FpdGluZy0ke25leHRSb3VuZE51bWJlcn1gLFxuICAgICAgICAgIG5leHRSb3VuZE51bWJlcixcbiAgICAgICAgICB0b3VybmFtZW50Lndpbm5lcnNCcmFja2V0RmluYWxMb3NlcixcbiAgICAgICAgICBudWxsLFxuICAgICAgICAgIHRydWUsXG4gICAgICAgICAgXCJsb3NlcnNcIlxuICAgICAgICApXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAobG9zZXJzQnJhY2tldFRlYW1zLmxlbmd0aCA+IDIpIHtcbiAgICAgIC8vIE1vcmUgdGhhbiAyIHRlYW1zOiBwYWlyIG9mZiBhcyB1c3VhbCwgV0JGTCB3YWl0c1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsb3NlcnNCcmFja2V0VGVhbXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgY29uc3QgdGVhbTEgPSBsb3NlcnNCcmFja2V0VGVhbXNbaV07XG4gICAgICAgIGNvbnN0IHRlYW0yID0gbG9zZXJzQnJhY2tldFRlYW1zW2kgKyAxXSA/PyBudWxsO1xuICAgICAgICBuZXh0Um91bmRNYXRjaGVzLnB1c2goXG4gICAgICAgICAgY3JlYXRlTWF0Y2goXG4gICAgICAgICAgICBgTCR7bmV4dFJvdW5kTnVtYmVyfS0ke01hdGguZmxvb3IoaSAvIDIpICsgMX1gLFxuICAgICAgICAgICAgbmV4dFJvdW5kTnVtYmVyLFxuICAgICAgICAgICAgdGVhbTEsXG4gICAgICAgICAgICB0ZWFtMixcbiAgICAgICAgICAgICF0ZWFtMixcbiAgICAgICAgICAgIFwibG9zZXJzXCJcbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBuZXh0Um91bmRNYXRjaGVzLnB1c2goXG4gICAgICAgIGNyZWF0ZU1hdGNoKFxuICAgICAgICAgIGBXaW5uZXJzRmluYWxMb3Nlci13YWl0aW5nLSR7bmV4dFJvdW5kTnVtYmVyfWAsXG4gICAgICAgICAgbmV4dFJvdW5kTnVtYmVyLFxuICAgICAgICAgIHRvdXJuYW1lbnQud2lubmVyc0JyYWNrZXRGaW5hbExvc2VyLFxuICAgICAgICAgIG51bGwsXG4gICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICBcImxvc2Vyc1wiXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFdCRkwgaXMgd2FpdGluZyBmb3IgdGhlIGxvc2VycyBicmFja2V0IHRvIHJlc29sdmVcbiAgICAgIG5leHRSb3VuZE1hdGNoZXMucHVzaChcbiAgICAgICAgY3JlYXRlTWF0Y2goXG4gICAgICAgICAgYFdpbm5lcnNGaW5hbExvc2VyLXdhaXRpbmctJHtuZXh0Um91bmROdW1iZXJ9YCxcbiAgICAgICAgICBuZXh0Um91bmROdW1iZXIsXG4gICAgICAgICAgdG91cm5hbWVudC53aW5uZXJzQnJhY2tldEZpbmFsTG9zZXIsXG4gICAgICAgICAgbnVsbCxcbiAgICAgICAgICB0cnVlLFxuICAgICAgICAgIFwibG9zZXJzXCJcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9XG4gICAgLy8gQWx3YXlzIHNob3cgYSB3YWl0aW5nIGNhcmQgZm9yIHRoZSB3aW5uZXJzIGJyYWNrZXQgY2hhbXBpb24gaWYgbm90IGluIGNoYW1waW9uc2hpcFxuICAgIG5leHRSb3VuZE1hdGNoZXMucHVzaChcbiAgICAgIGNyZWF0ZU1hdGNoKFxuICAgICAgICBgV2lubmVyc0JyYWNrZXRDaGFtcGlvbi13YWl0aW5nLSR7bmV4dFJvdW5kTnVtYmVyfWAsXG4gICAgICAgIG5leHRSb3VuZE51bWJlcixcbiAgICAgICAgd2lubmVyc0JyYWNrZXRUZWFtc1swXSxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgdHJ1ZSxcbiAgICAgICAgXCJ3aW5uZXJzXCJcbiAgICAgIClcbiAgICApO1xuICB9XG4gIC8vIENoZWNrIGlmIHRoaXMgaXMgdGhlIHdpbm5lcidzIGJyYWNrZXQgZmluYWwgKGV4YWN0bHkgMiB0ZWFtcyBpbiB3aW5uZXIncyBicmFja2V0KVxuICBlbHNlIGlmICh3aW5uZXJzQnJhY2tldFRlYW1zLmxlbmd0aCA9PT0gMikge1xuICAgIC8vIENyZWF0ZSB0aGUgd2lubmVyJ3MgYnJhY2tldCBmaW5hbCBtYXRjaFxuICAgIG5leHRSb3VuZE1hdGNoZXMucHVzaChcbiAgICAgIGNyZWF0ZU1hdGNoKFxuICAgICAgICBgVyR7bmV4dFJvdW5kTnVtYmVyfS0xYCxcbiAgICAgICAgbmV4dFJvdW5kTnVtYmVyLFxuICAgICAgICB3aW5uZXJzQnJhY2tldFRlYW1zWzBdLFxuICAgICAgICB3aW5uZXJzQnJhY2tldFRlYW1zWzFdLFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgXCJ3aW5uZXJzXCJcbiAgICAgIClcbiAgICApO1xuXG4gICAgLy8gQ29udGludWUgd2l0aCBsb3NlcnMgYnJhY2tldCBtYXRjaGVzIHNlcGFyYXRlbHlcbiAgICBjcmVhdGVMb3NlcnNCcmFja2V0TWF0Y2hlcygpO1xuICB9XG4gIC8vIE90aGVyd2lzZSwgY29udGludWUgd2l0aCBub3JtYWwgYnJhY2tldCBwbGF5XG4gIGVsc2Uge1xuICAgIGNyZWF0ZVN0YW5kYXJkQnJhY2tldE1hdGNoZXMoKTtcbiAgfVxuXG4gIC8vIEhlbHBlciBmdW5jdGlvbiB0byBjcmVhdGUgc3RhbmRhcmQgYnJhY2tldCBtYXRjaGVzXG4gIGZ1bmN0aW9uIGNyZWF0ZVN0YW5kYXJkQnJhY2tldE1hdGNoZXMoKSB7XG4gICAgLy8gLS0tIFdpbm5lcnMgQnJhY2tldCBNYXRjaGVzIC0tLVxuICAgIGxldCBtYXRjaENvdW50ZXIgPSAxO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgd2lubmVyc0JyYWNrZXRUZWFtcy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgY29uc3QgdGVhbTEgPSB3aW5uZXJzQnJhY2tldFRlYW1zW2ldO1xuICAgICAgY29uc3QgdGVhbTIgPSB3aW5uZXJzQnJhY2tldFRlYW1zW2kgKyAxXSA/PyBudWxsO1xuICAgICAgY29uc3QgaXNCeWUgPSAhdGVhbTI7XG4gICAgICBuZXh0Um91bmRNYXRjaGVzLnB1c2goXG4gICAgICAgIGNyZWF0ZU1hdGNoKFxuICAgICAgICAgIGBXJHtuZXh0Um91bmROdW1iZXJ9LSR7bWF0Y2hDb3VudGVyfWAsXG4gICAgICAgICAgbmV4dFJvdW5kTnVtYmVyLFxuICAgICAgICAgIHRlYW0xLFxuICAgICAgICAgIHRlYW0yLFxuICAgICAgICAgIGlzQnllLFxuICAgICAgICAgIFwid2lubmVyc1wiXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgICBtYXRjaENvdW50ZXIrKztcbiAgICB9XG5cbiAgICAvLyBDcmVhdGUgbG9zZXJzIGJyYWNrZXQgbWF0Y2hlcyBzZXBhcmF0ZWx5XG4gICAgY3JlYXRlTG9zZXJzQnJhY2tldE1hdGNoZXMoKTtcbiAgfVxuXG4gIC8vIEhlbHBlciBmdW5jdGlvbiB0byBjcmVhdGUgbG9zZXJzIGJyYWNrZXQgbWF0Y2hlc1xuICBmdW5jdGlvbiBjcmVhdGVMb3NlcnNCcmFja2V0TWF0Y2hlcygpIHtcbiAgICAvLyAtLS0gTG9zZXJzIEJyYWNrZXQgTWF0Y2hlcyAtLS1cbiAgICBjb25zdCBlbGlnaWJsZUxvc2VycyA9IGFsbFRlYW1zLmZpbHRlcihcbiAgICAgICh0ZWFtKSA9PlxuICAgICAgICAobG9zc0NvdW50c1t0ZWFtLmlkXSB8fCAwKSA9PT0gMSAmJlxuICAgICAgICAhdG91cm5hbWVudC5lbGltaW5hdGVkVGVhbXMuc29tZSgodCkgPT4gdC5pZCA9PT0gdGVhbS5pZCkgJiZcbiAgICAgICAgIW5ld2x5RWxpbWluYXRlZC5zb21lKCh0KSA9PiB0LmlkID09PSB0ZWFtLmlkKSAmJlxuICAgICAgICAvLyBFeGNsdWRlIHdpbm5lcidzIGJyYWNrZXQgZmluYWwgbG9zZXIgaWYgaXQgZXhpc3RzXG4gICAgICAgICEoXG4gICAgICAgICAgdG91cm5hbWVudC53aW5uZXJzQnJhY2tldEZpbmFsTG9zZXIgJiZcbiAgICAgICAgICB0b3VybmFtZW50Lndpbm5lcnNCcmFja2V0RmluYWxMb3Nlci5pZCA9PT0gdGVhbS5pZFxuICAgICAgICApXG4gICAgKTtcblxuICAgIC8vIEZpbmQgdGVhbXMgcmVjZW50bHkgZHJvcHBlZCBmcm9tIHdpbm5lcnMgYnJhY2tldFxuICAgIGNvbnN0IGp1c3REcm9wcGVkRnJvbVdpbm5lcnMgPSBjdXJyZW50Um91bmQubWF0Y2hlc1xuICAgICAgLmZpbHRlcigobSkgPT4gbS5icmFja2V0ID09PSBcIndpbm5lcnNcIiAmJiBtLmxvc2VyICYmIG0uaXNDb21wbGV0ZWQpXG4gICAgICAubWFwKChtKSA9PiBtLmxvc2VyISlcbiAgICAgIC5maWx0ZXIoKGxvc2VyKSA9PiBlbGlnaWJsZUxvc2Vycy5zb21lKCh0KSA9PiB0LmlkID09PSBsb3Nlci5pZCkpO1xuXG4gICAgLy8gSWYgdGhpcyBpcyB0aGUgd2lubmVyJ3MgYnJhY2tldCBmaW5hbCwgc3RvcmUgdGhlIGxvc2VyIGZvciBsYXRlciB1c2VcbiAgICBpZiAoXG4gICAgICBjdXJyZW50Um91bmQubWF0Y2hlcy5zb21lKFxuICAgICAgICAobSkgPT5cbiAgICAgICAgICBtLmJyYWNrZXQgPT09IFwid2lubmVyc1wiICYmXG4gICAgICAgICAgd2lubmVyc0JyYWNrZXRUZWFtcy5sZW5ndGggPT09IDEgJiZcbiAgICAgICAgICBtLmxvc2VyICYmXG4gICAgICAgICAgbS5pc0NvbXBsZXRlZFxuICAgICAgKVxuICAgICkge1xuICAgICAgLy8gVGhpcyBpcyBhIHNwZWNpYWwgY2FzZSAtIHdlIGZvdW5kIHRoZSB3aW5uZXIncyBicmFja2V0IGZpbmFsIGxvc2VyXG4gICAgICBjb25zdCB3aW5uZXJzRmluYWxMb3NlciA9IGN1cnJlbnRSb3VuZC5tYXRjaGVzXG4gICAgICAgIC5maWx0ZXIoKG0pID0+IG0uYnJhY2tldCA9PT0gXCJ3aW5uZXJzXCIgJiYgbS5pc0NvbXBsZXRlZCAmJiBtLmxvc2VyKVxuICAgICAgICAubWFwKChtKSA9PiBtLmxvc2VyISlcbiAgICAgICAgLnBvcCgpO1xuXG4gICAgICBpZiAoXG4gICAgICAgIHdpbm5lcnNGaW5hbExvc2VyICYmXG4gICAgICAgICF0b3VybmFtZW50LmVsaW1pbmF0ZWRUZWFtcy5zb21lKCh0KSA9PiB0LmlkID09PSB3aW5uZXJzRmluYWxMb3Nlci5pZClcbiAgICAgICkge1xuICAgICAgICB0b3VybmFtZW50Lndpbm5lcnNCcmFja2V0RmluYWxMb3NlciA9IHdpbm5lcnNGaW5hbExvc2VyO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEV4aXN0aW5nIGxvc2VycyBicmFja2V0IHRlYW1zXG4gICAgY29uc3QgZXhpc3RpbmdMb3NlcnMgPSBlbGlnaWJsZUxvc2Vycy5maWx0ZXIoXG4gICAgICAodCkgPT4gIWp1c3REcm9wcGVkRnJvbVdpbm5lcnMuc29tZSgoamQpID0+IGpkLmlkID09PSB0LmlkKVxuICAgICk7XG5cbiAgICAvLyBPcmRlcjogbW9zdCByZWNlbnQgZHJvcChzKSBmaXJzdFxuICAgIGNvbnN0IG9yZGVyZWRMb3NlcnMgPSBbLi4uanVzdERyb3BwZWRGcm9tV2lubmVycywgLi4uZXhpc3RpbmdMb3NlcnNdO1xuXG4gICAgaWYgKG9yZGVyZWRMb3NlcnMubGVuZ3RoID4gMCkge1xuICAgICAgaWYgKG9yZGVyZWRMb3NlcnMubGVuZ3RoICUgMiA9PT0gMSkge1xuICAgICAgICAvLyBPZGQ6IGJ5ZSBnb2VzIHRvIHRoZSBtb3N0IHJlY2VudCB0ZWFtIGRyb3BwZWQgZnJvbSB3aW5uZXJzIGJyYWNrZXRcbiAgICAgICAgbGV0IHRlYW1XaXRoQnllOiBUZWFtIHwgbnVsbCA9IG51bGw7XG4gICAgICAgIGlmIChqdXN0RHJvcHBlZEZyb21XaW5uZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICB0ZWFtV2l0aEJ5ZSA9XG4gICAgICAgICAgICBqdXN0RHJvcHBlZEZyb21XaW5uZXJzW2p1c3REcm9wcGVkRnJvbVdpbm5lcnMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgLy8gUmVtb3ZlIHRoZSBieWUgdGVhbSBmcm9tIG9yZGVyZWRMb3NlcnNcbiAgICAgICAgICBjb25zdCBieWVJbmRleCA9IG9yZGVyZWRMb3NlcnMuZmluZEluZGV4KFxuICAgICAgICAgICAgKHQpID0+IHQuaWQgPT09IHRlYW1XaXRoQnllIS5pZFxuICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKGJ5ZUluZGV4ICE9PSAtMSkgb3JkZXJlZExvc2Vycy5zcGxpY2UoYnllSW5kZXgsIDEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIERlZmVuc2l2ZTogZmFsbGJhY2sgdG8gZmlyc3QgdGVhbSBpZiBubyByZWNlbnQgZHJvcFxuICAgICAgICAgIHRlYW1XaXRoQnllID0gb3JkZXJlZExvc2Vycy5zaGlmdCgpITtcbiAgICAgICAgfVxuICAgICAgICBuZXh0Um91bmRNYXRjaGVzLnB1c2goXG4gICAgICAgICAgY3JlYXRlTWF0Y2goXG4gICAgICAgICAgICBgTCR7bmV4dFJvdW5kTnVtYmVyfS0xYCxcbiAgICAgICAgICAgIG5leHRSb3VuZE51bWJlcixcbiAgICAgICAgICAgIHRlYW1XaXRoQnllLFxuICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgIHRydWUsXG4gICAgICAgICAgICBcImxvc2Vyc1wiXG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgICAvLyBQYWlyIHRoZSByZXN0XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3JkZXJlZExvc2Vycy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgIGNvbnN0IHRlYW0xID0gb3JkZXJlZExvc2Vyc1tpXTtcbiAgICAgICAgICBjb25zdCB0ZWFtMiA9IG9yZGVyZWRMb3NlcnNbaSArIDFdID8/IG51bGw7XG4gICAgICAgICAgbmV4dFJvdW5kTWF0Y2hlcy5wdXNoKFxuICAgICAgICAgICAgY3JlYXRlTWF0Y2goXG4gICAgICAgICAgICAgIGBMJHtuZXh0Um91bmROdW1iZXJ9LSR7TWF0aC5mbG9vcihpIC8gMikgKyAyfWAsXG4gICAgICAgICAgICAgIG5leHRSb3VuZE51bWJlcixcbiAgICAgICAgICAgICAgdGVhbTEsXG4gICAgICAgICAgICAgIHRlYW0yLFxuICAgICAgICAgICAgICAhdGVhbTIsXG4gICAgICAgICAgICAgIFwibG9zZXJzXCJcbiAgICAgICAgICAgIClcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBFdmVuIG51bWJlcjogcGFpciBhbGxcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvcmRlcmVkTG9zZXJzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgY29uc3QgdGVhbTEgPSBvcmRlcmVkTG9zZXJzW2ldO1xuICAgICAgICAgIGNvbnN0IHRlYW0yID0gb3JkZXJlZExvc2Vyc1tpICsgMV0gPz8gbnVsbDtcbiAgICAgICAgICBuZXh0Um91bmRNYXRjaGVzLnB1c2goXG4gICAgICAgICAgICBjcmVhdGVNYXRjaChcbiAgICAgICAgICAgICAgYEwke25leHRSb3VuZE51bWJlcn0tJHtNYXRoLmZsb29yKGkgLyAyKSArIDF9YCxcbiAgICAgICAgICAgICAgbmV4dFJvdW5kTnVtYmVyLFxuICAgICAgICAgICAgICB0ZWFtMSxcbiAgICAgICAgICAgICAgdGVhbTIsXG4gICAgICAgICAgICAgICF0ZWFtMixcbiAgICAgICAgICAgICAgXCJsb3NlcnNcIlxuICAgICAgICAgICAgKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyAtLS0gV2lubmVyIGRldGVjdGlvbiBsb2dpYyAtLS1cbiAgbGV0IHdpbm5lcjogVGVhbSB8IHVuZGVmaW5lZCA9IHRvdXJuYW1lbnQud2lubmVyO1xuXG4gIGlmIChpc0NoYW1waW9uc2hpcFJvdW5kKSB7XG4gICAgLy8gRmluZCB0aGUgbGFzdCBjaGFtcGlvbnNoaXAgbWF0Y2ggcGxheWVkXG4gICAgY29uc3QgbGFzdENoYW1wTWF0Y2ggPVxuICAgICAgY2hhbXBpb25zaGlwTWF0Y2hlc1swXSB8fFxuICAgICAgcHJldkNoYW1waW9uc2hpcE1hdGNoZXNbcHJldkNoYW1waW9uc2hpcE1hdGNoZXMubGVuZ3RoIC0gMV07XG5cbiAgICBpZiAoXG4gICAgICBsYXN0Q2hhbXBNYXRjaCAmJlxuICAgICAgbGFzdENoYW1wTWF0Y2guaXNDb21wbGV0ZWQgJiZcbiAgICAgIGxhc3RDaGFtcE1hdGNoLndpbm5lciAmJlxuICAgICAgbGFzdENoYW1wTWF0Y2gubG9zZXJcbiAgICApIHtcbiAgICAgIGNvbnN0IHdpbm5lcnNCcmFja2V0VGVhbSA9IGxhc3RDaGFtcE1hdGNoLnRlYW0xO1xuICAgICAgY29uc3QgbG9zZXJzQnJhY2tldFRlYW0gPSBsYXN0Q2hhbXBNYXRjaC50ZWFtMjtcbiAgICAgIGNvbnN0IGxvc2Vyc0JyYWNrZXRUZWFtV29uID1cbiAgICAgICAgbG9zZXJzQnJhY2tldFRlYW0gJiYgbGFzdENoYW1wTWF0Y2gud2lubmVyLmlkID09PSBsb3NlcnNCcmFja2V0VGVhbS5pZDtcblxuICAgICAgLy8gSWYgbG9zZXIncyBicmFja2V0IHRlYW0gd29uIGZpcnN0IGNoYW1waW9uc2hpcCBtYXRjaCwgd2lubmVyJ3MgYnJhY2tldCB0ZWFtIGdldHMgYW5vdGhlciBjaGFuY2VcbiAgICAgIGlmIChsb3NlcnNCcmFja2V0VGVhbVdvbiAmJiB0b3VybmFtZW50LmNoYW1waW9uc2hpcE1hdGNoZXNQbGF5ZWQgPT09IDEpIHtcbiAgICAgICAgd2lubmVyID0gdW5kZWZpbmVkOyAvLyBObyB3aW5uZXIgeWV0LCBuZWVkIHJlc2V0IG1hdGNoXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBFaXRoZXIgd2lubmVyJ3MgYnJhY2tldCB0ZWFtIHdvbiBmaXJzdCBtYXRjaCwgb3IgdGhpcyB3YXMgdGhlIHJlc2V0IG1hdGNoXG4gICAgICAgIHdpbm5lciA9IGxhc3RDaGFtcE1hdGNoLndpbm5lcjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyAtLS0gSU5GSU5JVEUgUkVDVVJTSU9OIEdVQVJEIC0tLVxuICBjb25zdCBub01vcmVNYXRjaGVzID1cbiAgICAoaXNDaGFtcGlvbnNoaXBSb3VuZCAmJiBjaGFtcGlvbnNoaXBNYXRjaGVzLmxlbmd0aCA9PT0gMCkgfHxcbiAgICAoIWlzQ2hhbXBpb25zaGlwUm91bmQgJiYgbmV4dFJvdW5kTWF0Y2hlcy5sZW5ndGggPT09IDApO1xuXG4gIGlmIChub01vcmVNYXRjaGVzKSB7XG4gICAgLy8gVG91cm5hbWVudCBpcyBvdmVyLCBkbyBub3QgYWR2YW5jZSBmdXJ0aGVyXG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnRvdXJuYW1lbnQsXG4gICAgICB3aW5uZXIsXG4gICAgICBjdXJyZW50Um91bmQ6IHRvdXJuYW1lbnQuY3VycmVudFJvdW5kXG4gICAgfTtcbiAgfVxuXG4gIC8vIERlYnVnIGxvZyBiZWZvcmUgcmV0dXJuaW5nIHRoZSBuZXcgdG91cm5hbWVudCBvYmplY3RcbiAgbG9nVG91cm5hbWVudFN0YXRlKHtcbiAgICByb3VuZE51bWJlcjogbmV4dFJvdW5kTnVtYmVyLFxuICAgIHdpbm5lcnNCcmFja2V0VGVhbXMsXG4gICAgbG9zZXJzQnJhY2tldFRlYW1zLFxuICAgIG1hdGNoZXM6IGlzQ2hhbXBpb25zaGlwUm91bmQgPyBjaGFtcGlvbnNoaXBNYXRjaGVzIDogbmV4dFJvdW5kTWF0Y2hlcyxcbiAgICB3aW5uZXJzQnJhY2tldEZpbmFsTG9zZXI6IHRvdXJuYW1lbnQud2lubmVyc0JyYWNrZXRGaW5hbExvc2VyXG4gIH0pO1xuXG4gIC8vIENvbXBvc2UgdGhlIG5ldyB0b3VybmFtZW50IG9iamVjdFxuICByZXR1cm4ge1xuICAgIC4uLnRvdXJuYW1lbnQsXG4gICAgcm91bmRzOiBbXG4gICAgICAuLi50b3VybmFtZW50LnJvdW5kcyxcbiAgICAgIHtcbiAgICAgICAgcm91bmROdW1iZXI6IG5leHRSb3VuZE51bWJlcixcbiAgICAgICAgbWF0Y2hlczogaXNDaGFtcGlvbnNoaXBSb3VuZCA/IGNoYW1waW9uc2hpcE1hdGNoZXMgOiBuZXh0Um91bmRNYXRjaGVzLFxuICAgICAgICBpc0RvdWJsZUVsaW1pbmF0aW9uOiB0cnVlLFxuICAgICAgICBpc0NoYW1waW9uc2hpcFJvdW5kXG4gICAgICB9XG4gICAgXSxcbiAgICBjdXJyZW50Um91bmQ6IG5leHRSb3VuZE51bWJlcixcbiAgICBlbGltaW5hdGVkVGVhbXM6IFtcbiAgICAgIC4uLnRvdXJuYW1lbnQuZWxpbWluYXRlZFRlYW1zLFxuICAgICAgLi4ubmV3bHlFbGltaW5hdGVkLmZpbHRlcihcbiAgICAgICAgKHQpID0+ICF0b3VybmFtZW50LmVsaW1pbmF0ZWRUZWFtcy5zb21lKChldCkgPT4gZXQuaWQgPT09IHQuaWQpXG4gICAgICApXG4gICAgXSxcbiAgICBjaGFtcGlvbnNoaXBNYXRjaGVzUGxheWVkOiBpc0NoYW1waW9uc2hpcFJvdW5kXG4gICAgICA/IHRvdXJuYW1lbnQuY2hhbXBpb25zaGlwTWF0Y2hlc1BsYXllZCArIDFcbiAgICAgIDogdG91cm5hbWVudC5jaGFtcGlvbnNoaXBNYXRjaGVzUGxheWVkLFxuICAgIHdpbm5lcnNCcmFja2V0RmluYWxMb3NlcjogdG91cm5hbWVudC53aW5uZXJzQnJhY2tldEZpbmFsTG9zZXIsXG4gICAgd2lubmVyXG4gIH07XG59O1xuXG5cbiJdLCJuYW1lcyI6WyJsb2dUb3VybmFtZW50U3RhdGUiLCJjcmVhdGVNYXRjaCIsImlkIiwicm91bmROdW1iZXIiLCJ0ZWFtMSIsInRlYW0yIiwiaXNCeWUiLCJicmFja2V0IiwibmV4dE1hdGNoSWQiLCJuZXh0TG9zZXJNYXRjaElkIiwiaXNDb21wbGV0ZWQiLCJ3aW5uZXIiLCJ1bmRlZmluZWQiLCJsb3NlciIsInNjb3JlIiwidGVhbTFTY29yZSIsInRlYW0yU2NvcmUiLCJlbGltaW5hdGVkTGFiZWwiLCJjcmVhdGVJbml0aWFsUm91bmRzIiwidGVhbXMiLCJudW1UZWFtcyIsImxlbmd0aCIsIm1hdGNoZXMiLCJudW1Sb3VuZHMiLCJNYXRoIiwiY2VpbCIsImxvZzIiLCJmaXJzdFJvdW5kTWF0Y2hlcyIsInBvdyIsIm1hdGNoQ291bnRlciIsImkiLCJtYXRjaElkIiwicHVzaCIsInJvdW5kcyIsImlzRG91YmxlRWxpbWluYXRpb24iLCJpc0NoYW1waW9uc2hpcFJvdW5kIiwiY3VycmVudFJvdW5kIiwiZWxpbWluYXRlZFRlYW1zIiwiY2hhbXBpb25zaGlwTWF0Y2hlc1BsYXllZCIsInVwZGF0ZU1hdGNoU2NvcmUiLCJtYXRjaCIsIm5ld1Njb3JlIiwid2lucyIsImxvc3NlcyIsImRlZHVwZVRlYW1zIiwic2VlbiIsIlNldCIsImZpbHRlciIsInRlYW0iLCJoYXMiLCJhZGQiLCJ0ZWFtc1dpdGhMb3NzZXMiLCJsb3NzQ291bnRzIiwibiIsIk9iamVjdCIsImtleXMiLCJ0ZWFtSWQiLCJhZHZhbmNlVG9OZXh0Um91bmQiLCJ0b3VybmFtZW50IiwibmV4dFJvdW5kTnVtYmVyIiwid2luc0NvdW50cyIsImZvckVhY2giLCJyb3VuZCIsImFsbFRlYW1zIiwidGVhbUlkcyIsIm5ld2x5RWxpbWluYXRlZCIsInNvbWUiLCJ0Iiwid2lubmVyc0JyYWNrZXRUZWFtcyIsInN0YXJ0c1dpdGgiLCJtYXAiLCJsb3NlcnNCcmFja2V0VGVhbXMiLCJ3aW5uZXJzQnJhY2tldEZpbmFsTG9zZXIiLCJjaGFtcGlvbnNoaXBNYXRjaGVzIiwibmV4dFJvdW5kTWF0Y2hlcyIsInByZXZDaGFtcGlvbnNoaXBNYXRjaGVzIiwiciIsImZsYXRNYXAiLCJtIiwibGFzdENoYW1wTWF0Y2giLCJ3aW5uZXJzQnJhY2tldFRlYW0iLCJsb3NlcnNCcmFja2V0VGVhbSIsImluY2x1ZGVzIiwibG9zZXJzQnJhY2tldFdpbm5lciIsInBvcCIsImFscmVhZHlQbGF5ZWQiLCJpZHMiLCJCb29sZWFuIiwic29ydCIsImN1cnJJZHMiLCJmbG9vciIsImNyZWF0ZUxvc2Vyc0JyYWNrZXRNYXRjaGVzIiwiY3JlYXRlU3RhbmRhcmRCcmFja2V0TWF0Y2hlcyIsImVsaWdpYmxlTG9zZXJzIiwianVzdERyb3BwZWRGcm9tV2lubmVycyIsIndpbm5lcnNGaW5hbExvc2VyIiwiZXhpc3RpbmdMb3NlcnMiLCJqZCIsIm9yZGVyZWRMb3NlcnMiLCJ0ZWFtV2l0aEJ5ZSIsImJ5ZUluZGV4IiwiZmluZEluZGV4Iiwic3BsaWNlIiwic2hpZnQiLCJsb3NlcnNCcmFja2V0VGVhbVdvbiIsIm5vTW9yZU1hdGNoZXMiLCJldCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./types/tournament/matches.ts\n"));

/***/ })

});
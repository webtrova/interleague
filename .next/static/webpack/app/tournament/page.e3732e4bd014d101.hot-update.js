"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/tournament/page",{

/***/ "(app-pages-browser)/./types/tournament/matches.ts":
/*!*************************************!*\
  !*** ./types/tournament/matches.ts ***!
  \*************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   advanceToNextRound: function() { return /* binding */ advanceToNextRound; },\n/* harmony export */   createInitialRounds: function() { return /* binding */ createInitialRounds; },\n/* harmony export */   createMatch: function() { return /* binding */ createMatch; },\n/* harmony export */   updateMatchScore: function() { return /* binding */ updateMatchScore; }\n/* harmony export */ });\n/* harmony import */ var _logTournamentState__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./logTournamentState */ \"(app-pages-browser)/./types/tournament/logTournamentState.ts\");\n\nconst createMatch = function(id, roundNumber, team1, team2) {\n    let isBye = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : false, bracket = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : \"winners\", nextMatchId = arguments.length > 6 ? arguments[6] : void 0, nextLoserMatchId = arguments.length > 7 ? arguments[7] : void 0;\n    var _ref;\n    return {\n        id,\n        roundNumber,\n        team1,\n        team2,\n        isCompleted: isBye,\n        isBye,\n        bracket,\n        winner: isBye ? (_ref = team1 !== null && team1 !== void 0 ? team1 : team2) !== null && _ref !== void 0 ? _ref : undefined : undefined,\n        loser: isBye ? undefined : undefined,\n        score: {\n            team1Score: 0,\n            team2Score: 0\n        },\n        nextMatchId,\n        nextLoserMatchId,\n        eliminatedLabel: undefined\n    };\n};\nconst createInitialRounds = (teams)=>{\n    const numTeams = teams.length;\n    const matches = [];\n    const numRounds = Math.ceil(Math.log2(numTeams));\n    const firstRoundMatches = Math.pow(2, numRounds - 1);\n    let matchCounter = 1;\n    for(let i = 0; i < firstRoundMatches; i++){\n        const team1 = teams[i * 2] || null;\n        const team2 = teams[i * 2 + 1] || null;\n        const isBye = !team1 || !team2;\n        const matchId = \"W1-\".concat(matchCounter);\n        const nextMatchId = \"W2-\".concat(Math.ceil(matchCounter / 2));\n        const nextLoserMatchId = \"L1-\".concat(Math.ceil(matchCounter / 2));\n        matches.push(createMatch(matchId, 1, team1, team2, isBye, \"winners\", nextMatchId, nextLoserMatchId));\n        matchCounter++;\n    }\n    return {\n        rounds: [\n            {\n                roundNumber: 1,\n                matches,\n                isDoubleElimination: true,\n                isChampionshipRound: false\n            }\n        ],\n        currentRound: 1,\n        eliminatedTeams: [],\n        championshipMatchesPlayed: 0\n    };\n};\nconst updateMatchScore = (match, newScore)=>{\n    const isCompleted = newScore.team1Score !== newScore.team2Score;\n    let winner = undefined;\n    let loser = undefined;\n    if (isCompleted) {\n        if (newScore.team1Score > newScore.team2Score) {\n            var _match_team1_wins, _match_team1_losses;\n            winner = match.team1 ? {\n                ...match.team1,\n                wins: ((_match_team1_wins = match.team1.wins) !== null && _match_team1_wins !== void 0 ? _match_team1_wins : 0) + 1,\n                losses: (_match_team1_losses = match.team1.losses) !== null && _match_team1_losses !== void 0 ? _match_team1_losses : 0\n            } : undefined;\n            var _match_team2_wins, _match_team2_losses;\n            loser = match.team2 ? {\n                ...match.team2,\n                wins: (_match_team2_wins = match.team2.wins) !== null && _match_team2_wins !== void 0 ? _match_team2_wins : 0,\n                losses: ((_match_team2_losses = match.team2.losses) !== null && _match_team2_losses !== void 0 ? _match_team2_losses : 0) + 1\n            } : undefined;\n        } else {\n            var _match_team2_wins1, _match_team2_losses1;\n            winner = match.team2 ? {\n                ...match.team2,\n                wins: ((_match_team2_wins1 = match.team2.wins) !== null && _match_team2_wins1 !== void 0 ? _match_team2_wins1 : 0) + 1,\n                losses: (_match_team2_losses1 = match.team2.losses) !== null && _match_team2_losses1 !== void 0 ? _match_team2_losses1 : 0\n            } : undefined;\n            var _match_team1_wins1, _match_team1_losses1;\n            loser = match.team1 ? {\n                ...match.team1,\n                wins: (_match_team1_wins1 = match.team1.wins) !== null && _match_team1_wins1 !== void 0 ? _match_team1_wins1 : 0,\n                losses: ((_match_team1_losses1 = match.team1.losses) !== null && _match_team1_losses1 !== void 0 ? _match_team1_losses1 : 0) + 1\n            } : undefined;\n        }\n    }\n    return {\n        ...match,\n        score: newScore,\n        isCompleted,\n        winner,\n        loser\n    };\n};\n// Helper to deduplicate teams by ID\nfunction dedupeTeams(teams) {\n    const seen = new Set();\n    return teams.filter((team)=>{\n        if (!team) return false;\n        if (seen.has(team.id)) return false;\n        seen.add(team.id);\n        return true;\n    });\n}\n// Helper: get all teams with exactly N losses\nfunction teamsWithLosses(lossCounts, n) {\n    return Object.keys(lossCounts).filter((teamId)=>lossCounts[teamId] === n);\n}\nconst advanceToNextRound = (tournament)=>{\n    const currentRound = tournament.rounds[tournament.rounds.length - 1];\n    const nextRoundNumber = tournament.currentRound + 1;\n    // WINNER GUARD: If a winner has already been determined, do not create any more rounds\n    if (tournament.winner) {\n        return {\n            ...tournament,\n            currentRound: tournament.currentRound\n        };\n    }\n    // Track all losses and wins across the tournament\n    const lossCounts = {};\n    const winsCounts = {};\n    tournament.rounds.forEach((round)=>{\n        round.matches.forEach((match)=>{\n            if (match.isCompleted && match.loser) {\n                lossCounts[match.loser.id] = (lossCounts[match.loser.id] || 0) + 1;\n            }\n            if (match.isCompleted && match.winner) {\n                winsCounts[match.winner.id] = (winsCounts[match.winner.id] || 0) + 1;\n            }\n        });\n    });\n    // Gather all teams ever in the tournament, attaching wins and losses\n    const allTeams = [];\n    const teamIds = new Set();\n    for (const round of tournament.rounds){\n        for (const match of round.matches){\n            if (match.team1 && !teamIds.has(match.team1.id)) {\n                allTeams.push({\n                    ...match.team1,\n                    wins: winsCounts[match.team1.id] || 0,\n                    losses: lossCounts[match.team1.id] || 0\n                });\n                teamIds.add(match.team1.id);\n            }\n            if (match.team2 && !teamIds.has(match.team2.id)) {\n                allTeams.push({\n                    ...match.team2,\n                    wins: winsCounts[match.team2.id] || 0,\n                    losses: lossCounts[match.team2.id] || 0\n                });\n                teamIds.add(match.team2.id);\n            }\n        }\n    }\n    // Identify newly eliminated teams (2 losses)\n    const newlyEliminated = [];\n    for (const team of allTeams){\n        if ((lossCounts[team.id] || 0) >= 2 && !tournament.eliminatedTeams.some((t)=>t.id === team.id)) {\n            newlyEliminated.push(team);\n        }\n    }\n    // Winners: teams with 0 losses and not eliminated\n    const winnersBracketTeams = allTeams.filter((team)=>(lossCounts[team.id] || 0) === 0 && !tournament.eliminatedTeams.some((t)=>t.id === team.id) && !newlyEliminated.some((t)=>t.id === team.id) && !team.id.startsWith(\"tbd-\") // Exclude phantom TBD teams\n    );\n    // Losers: teams with 1 loss and not eliminated\n    const losersBracketTeams = allTeams.filter((team)=>(lossCounts[team.id] || 0) === 1 && !tournament.eliminatedTeams.some((t)=>t.id === team.id) && !newlyEliminated.some((t)=>t.id === team.id) && // Don't include the winners bracket final loser in regular losers bracket teams\n        !(tournament.winnersBracketFinalLoser && tournament.winnersBracketFinalLoser.id === team.id));\n    let isChampionshipRound = false;\n    let championshipMatches = [];\n    let nextRoundMatches = [];\n    // Get previous championship matches\n    const prevChampionshipMatches = tournament.rounds.filter((r)=>r.isChampionshipRound).flatMap((r)=>r.matches).filter((m)=>m.bracket === \"championship\");\n    // --- CHAMPIONSHIP LOGIC ---\n    // Check if a championship match already happened and was completed\n    if (prevChampionshipMatches.length >= 1 && prevChampionshipMatches[prevChampionshipMatches.length - 1].isCompleted) {\n        var _lastChampMatch_winner;\n        const lastChampMatch = prevChampionshipMatches[prevChampionshipMatches.length - 1];\n        const winnersBracketTeam = lastChampMatch.team1;\n        const losersBracketTeam = lastChampMatch.team2;\n        // If loser's bracket team won the first championship match, winner's bracket team gets another chance\n        if (((_lastChampMatch_winner = lastChampMatch.winner) === null || _lastChampMatch_winner === void 0 ? void 0 : _lastChampMatch_winner.id) === (losersBracketTeam === null || losersBracketTeam === void 0 ? void 0 : losersBracketTeam.id) && tournament.championshipMatchesPlayed === 1) {\n            isChampionshipRound = true;\n            // Create the \"reset\" match\n            championshipMatches.push(createMatch(\"C\".concat(nextRoundNumber, \"-1\"), nextRoundNumber, winnersBracketTeam, losersBracketTeam, false, \"championship\"));\n        } else {\n            // Either winner's bracket team won first match, or this was the reset match\n            // Tournament is over, winner will be determined in winner detection logic\n            isChampionshipRound = true;\n        }\n    } else if (winnersBracketTeams.length === 1 && // We have a winner's bracket champion\n    losersBracketTeams.length === 0 && // No teams in regular losers bracket\n    tournament.winnersBracketFinalLoser // We have the winner's bracket final loser\n    ) {\n        // Find the winner of the losers bracket final (WBFL vs someone)\n        const losersBracketFinalMatch = currentRound.matches.find((m)=>{\n            var _m_team1, _m_team2;\n            return m.bracket === \"losers\" && m.isCompleted && (((_m_team1 = m.team1) === null || _m_team1 === void 0 ? void 0 : _m_team1.id) === tournament.winnersBracketFinalLoser.id || ((_m_team2 = m.team2) === null || _m_team2 === void 0 ? void 0 : _m_team2.id) === tournament.winnersBracketFinalLoser.id);\n        });\n        if (losersBracketFinalMatch && losersBracketFinalMatch.winner) {\n            // We have a winner from the losers bracket final - create championship match\n            isChampionshipRound = true;\n            championshipMatches.push(createMatch(\"C\".concat(nextRoundNumber, \"-1\"), nextRoundNumber, winnersBracketTeams[0], losersBracketFinalMatch.winner, false, \"championship\"));\n        }\n    } else if (winnersBracketTeams.length === 1 && // We have a winner's bracket champion\n    tournament.winnersBracketFinalLoser && // We have the winner's bracket final loser\n    losersBracketTeams.length === 1 // We have one team in losers bracket\n    ) {\n        // Create the losers bracket final match\n        nextRoundMatches.push(createMatch(\"LosersLast-\".concat(nextRoundNumber), nextRoundNumber, losersBracketTeams[0], tournament.winnersBracketFinalLoser, false, \"losers\"));\n        // Show a waiting card for the winners bracket champion\n        nextRoundMatches.push(createMatch(\"WinnersBracketChampion-waiting-\".concat(nextRoundNumber), nextRoundNumber, winnersBracketTeams[0], null, true, \"winners\"));\n    } else if (winnersBracketTeams.length === 2) {\n        // Create the winner's bracket final match\n        nextRoundMatches.push(createMatch(\"W\".concat(nextRoundNumber, \"-1\"), nextRoundNumber, winnersBracketTeams[0], winnersBracketTeams[1], false, \"winners\"));\n        // Continue with losers bracket matches\n        createLosersBracketMatches();\n    } else {\n        createStandardBracketMatches();\n    }\n    // Helper function to create standard bracket matches\n    function createStandardBracketMatches() {\n        // --- Winners Bracket Matches ---\n        let matchCounter = 1;\n        for(let i = 0; i < winnersBracketTeams.length; i += 2){\n            const team1 = winnersBracketTeams[i];\n            var _winnersBracketTeams_;\n            const team2 = (_winnersBracketTeams_ = winnersBracketTeams[i + 1]) !== null && _winnersBracketTeams_ !== void 0 ? _winnersBracketTeams_ : null;\n            const isBye = !team2;\n            nextRoundMatches.push(createMatch(\"W\".concat(nextRoundNumber, \"-\").concat(matchCounter), nextRoundNumber, team1, team2, isBye, \"winners\"));\n            matchCounter++;\n        }\n        // Create losers bracket matches\n        createLosersBracketMatches();\n    }\n    // Helper function to create losers bracket matches\n    function createLosersBracketMatches() {\n        // Find teams recently dropped from winners bracket\n        const justDroppedFromWinners = currentRound.matches.filter((m)=>m.bracket === \"winners\" && m.loser && m.isCompleted).map((m)=>m.loser).filter((loser)=>!tournament.eliminatedTeams.some((t)=>t.id === loser.id) && !newlyEliminated.some((t)=>t.id === loser.id));\n        // If this is the winner's bracket final, store the loser for later use\n        if (currentRound.matches.some((m)=>m.bracket === \"winners\" && winnersBracketTeams.length === 1 && m.loser && m.isCompleted)) {\n            // This is a special case - we found the winner's bracket final loser\n            const winnersFinalLoser = currentRound.matches.filter((m)=>m.bracket === \"winners\" && m.isCompleted && m.loser).map((m)=>m.loser).pop();\n            if (winnersFinalLoser && !tournament.eliminatedTeams.some((t)=>t.id === winnersFinalLoser.id)) {\n                tournament.winnersBracketFinalLoser = winnersFinalLoser;\n            }\n        }\n        // Combine all eligible losers bracket teams\n        const orderedLosers = [\n            ...justDroppedFromWinners,\n            ...losersBracketTeams\n        ];\n        if (orderedLosers.length > 0) {\n            if (orderedLosers.length % 2 === 1) {\n                // Odd number of teams: give bye to most recent team from winners bracket\n                let teamWithBye = null;\n                if (justDroppedFromWinners.length > 0) {\n                    teamWithBye = justDroppedFromWinners[justDroppedFromWinners.length - 1];\n                    // Remove the bye team from orderedLosers\n                    const byeIndex = orderedLosers.findIndex((t)=>t.id === teamWithBye.id);\n                    if (byeIndex !== -1) orderedLosers.splice(byeIndex, 1);\n                } else {\n                    // Fallback to first team if no recent drop\n                    teamWithBye = orderedLosers.shift();\n                }\n                nextRoundMatches.push(createMatch(\"L\".concat(nextRoundNumber, \"-1\"), nextRoundNumber, teamWithBye, null, true, \"losers\"));\n                // Pair the rest\n                for(let i = 0; i < orderedLosers.length; i += 2){\n                    const team1 = orderedLosers[i];\n                    var _orderedLosers_;\n                    const team2 = (_orderedLosers_ = orderedLosers[i + 1]) !== null && _orderedLosers_ !== void 0 ? _orderedLosers_ : null;\n                    nextRoundMatches.push(createMatch(\"L\".concat(nextRoundNumber, \"-\").concat(Math.floor(i / 2) + 2), nextRoundNumber, team1, team2, !team2, \"losers\"));\n                }\n            } else {\n                // Even number: pair all teams\n                for(let i = 0; i < orderedLosers.length; i += 2){\n                    const team1 = orderedLosers[i];\n                    var _orderedLosers_1;\n                    const team2 = (_orderedLosers_1 = orderedLosers[i + 1]) !== null && _orderedLosers_1 !== void 0 ? _orderedLosers_1 : null;\n                    nextRoundMatches.push(createMatch(\"L\".concat(nextRoundNumber, \"-\").concat(Math.floor(i / 2) + 1), nextRoundNumber, team1, team2, !team2, \"losers\"));\n                }\n            }\n        }\n    }\n    // --- Winner detection logic ---\n    let winner = tournament.winner;\n    if (isChampionshipRound) {\n        // Find the last championship match played\n        const lastChampMatch = championshipMatches[0] || prevChampionshipMatches[prevChampionshipMatches.length - 1];\n        if (lastChampMatch && lastChampMatch.isCompleted && lastChampMatch.winner) {\n            const winnersBracketTeam = lastChampMatch.team1;\n            const losersBracketTeam = lastChampMatch.team2;\n            const losersBracketTeamWon = losersBracketTeam && lastChampMatch.winner.id === losersBracketTeam.id;\n            // If loser's bracket team won first championship match, winner's bracket team gets another chance\n            if (losersBracketTeamWon && tournament.championshipMatchesPlayed === 1) {\n                winner = undefined; // No winner yet, need reset match\n            } else {\n                // Either winner's bracket team won first match, or this was the reset match\n                winner = lastChampMatch.winner;\n            }\n        }\n    }\n    // --- INFINITE RECURSION GUARD ---\n    const noMoreMatches = isChampionshipRound && championshipMatches.length === 0 || !isChampionshipRound && nextRoundMatches.length === 0;\n    if (noMoreMatches) {\n        // Tournament is over, do not advance further\n        return {\n            ...tournament,\n            winner,\n            currentRound: tournament.currentRound\n        };\n    }\n    // Debug log before returning the new tournament object\n    (0,_logTournamentState__WEBPACK_IMPORTED_MODULE_0__.logTournamentState)({\n        roundNumber: nextRoundNumber,\n        winnersBracketTeams,\n        losersBracketTeams,\n        matches: isChampionshipRound ? championshipMatches : nextRoundMatches,\n        winnersBracketFinalLoser: tournament.winnersBracketFinalLoser\n    });\n    // Return the new tournament state\n    return {\n        ...tournament,\n        rounds: [\n            ...tournament.rounds,\n            {\n                roundNumber: nextRoundNumber,\n                matches: isChampionshipRound ? championshipMatches : nextRoundMatches,\n                isDoubleElimination: true,\n                isChampionshipRound\n            }\n        ],\n        currentRound: nextRoundNumber,\n        eliminatedTeams: [\n            ...tournament.eliminatedTeams,\n            ...newlyEliminated.filter((t)=>!tournament.eliminatedTeams.some((et)=>et.id === t.id))\n        ],\n        championshipMatchesPlayed: isChampionshipRound ? tournament.championshipMatchesPlayed + 1 : tournament.championshipMatchesPlayed,\n        winnersBracketFinalLoser: tournament.winnersBracketFinalLoser,\n        winner\n    };\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3R5cGVzL3RvdXJuYW1lbnQvbWF0Y2hlcy50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUMwRDtBQW1DbkQsTUFBTUMsY0FBYyxTQUN6QkMsSUFDQUMsYUFDQUMsT0FDQUM7UUFDQUMseUVBQWlCLE9BQ2pCQywyRUFBaUQsV0FDakRDLDREQUNBQztRQVNpQkw7V0FSTjtRQUNYRjtRQUNBQztRQUNBQztRQUNBQztRQUNBSyxhQUFhSjtRQUNiQTtRQUNBQztRQUNBSSxRQUFRTCxRQUFTRixDQUFBQSxPQUFBQSxrQkFBQUEsbUJBQUFBLFFBQVNDLG1CQUFURCxrQkFBQUEsT0FBa0JRLFlBQWFBO1FBQ2hEQyxPQUFPUCxRQUFRTSxZQUFZQTtRQUMzQkUsT0FBTztZQUFFQyxZQUFZO1lBQUdDLFlBQVk7UUFBRTtRQUN0Q1I7UUFDQUM7UUFDQVEsaUJBQWlCTDtJQUNuQjtBQUFBLEVBQUc7QUFFSSxNQUFNTSxzQkFBc0IsQ0FBQ0M7SUFDbEMsTUFBTUMsV0FBV0QsTUFBTUUsTUFBTTtJQUM3QixNQUFNQyxVQUFtQixFQUFFO0lBQzNCLE1BQU1DLFlBQVlDLEtBQUtDLElBQUksQ0FBQ0QsS0FBS0UsSUFBSSxDQUFDTjtJQUV0QyxNQUFNTyxvQkFBb0JILEtBQUtJLEdBQUcsQ0FBQyxHQUFHTCxZQUFZO0lBQ2xELElBQUlNLGVBQWU7SUFFbkIsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlILG1CQUFtQkcsSUFBSztRQUMxQyxNQUFNMUIsUUFBUWUsS0FBSyxDQUFDVyxJQUFJLEVBQUUsSUFBSTtRQUM5QixNQUFNekIsUUFBUWMsS0FBSyxDQUFDVyxJQUFJLElBQUksRUFBRSxJQUFJO1FBQ2xDLE1BQU14QixRQUFRLENBQUNGLFNBQVMsQ0FBQ0M7UUFFekIsTUFBTTBCLFVBQVUsTUFBbUIsT0FBYkY7UUFDdEIsTUFBTXJCLGNBQWMsTUFBa0MsT0FBNUJnQixLQUFLQyxJQUFJLENBQUNJLGVBQWU7UUFDbkQsTUFBTXBCLG1CQUFtQixN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QUNvQixJQUFNLENBQUNULFdBQVdyQixlQUFlLENBQUM2QixJQUFJLENBQUMsQ0FBQ2dDLEtBQU9BLEdBQUdoRyxFQUFFLEtBQUtpRSxFQUFFakUsRUFBRTtTQUVqRTtRQUNEb0MsMkJBQTJCSCxzQkFDdkJ1QixXQUFXcEIseUJBQXlCLEdBQUcsSUFDdkNvQixXQUFXcEIseUJBQXlCO1FBQ3hDaUMsMEJBQTBCYixXQUFXYSx3QkFBd0I7UUFDN0Q1RDtJQUNGO0FBQ0YsRUFBRSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi90eXBlcy90b3VybmFtZW50L21hdGNoZXMudHM/ZGEyMiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7IFRlYW0gfSBmcm9tIFwiLi9tbGItdGVhbXNcIjtcbmltcG9ydCB7IGxvZ1RvdXJuYW1lbnRTdGF0ZSB9IGZyb20gXCIuL2xvZ1RvdXJuYW1lbnRTdGF0ZVwiO1xuXG5leHBvcnQgaW50ZXJmYWNlIE1hdGNoIHtcbiAgaWQ6IHN0cmluZztcbiAgcm91bmROdW1iZXI6IG51bWJlcjtcbiAgdGVhbTE6IFRlYW0gfCBudWxsO1xuICB0ZWFtMjogVGVhbSB8IG51bGw7XG4gIGlzQ29tcGxldGVkOiBib29sZWFuO1xuICBpc0J5ZT86IGJvb2xlYW47XG4gIHdpbm5lcj86IFRlYW07XG4gIGxvc2VyPzogVGVhbTtcbiAgYnJhY2tldDogXCJ3aW5uZXJzXCIgfCBcImxvc2Vyc1wiIHwgXCJjaGFtcGlvbnNoaXBcIjtcbiAgc2NvcmU6IHsgdGVhbTFTY29yZTogbnVtYmVyOyB0ZWFtMlNjb3JlOiBudW1iZXIgfTtcbiAgbmV4dE1hdGNoSWQ/OiBzdHJpbmc7XG4gIG5leHRMb3Nlck1hdGNoSWQ/OiBzdHJpbmc7XG4gIGVsaW1pbmF0ZWRMYWJlbD86IHN0cmluZzsgLy8gbGFiZWwgZm9yIGVsaW1pbmF0ZWQgdGVhbXMgaW4gbG9zZXJzIGJyYWNrZXRcbiAgcmVxdWlyZXNSZW1hdGNoPzogYm9vbGVhbjsgLy8gaW5kaWNhdGVzIGlmIGEgY2hhbXBpb25zaGlwIHJlbWF0Y2ggaXMgcmVxdWlyZWRcbn1cblxuZXhwb3J0IGludGVyZmFjZSBSb3VuZCB7XG4gIHJvdW5kTnVtYmVyOiBudW1iZXI7XG4gIG1hdGNoZXM6IE1hdGNoW107XG4gIGlzRG91YmxlRWxpbWluYXRpb246IGJvb2xlYW47XG4gIGlzQ2hhbXBpb25zaGlwUm91bmQ6IGJvb2xlYW47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVG91cm5hbWVudCB7XG4gIHJvdW5kczogUm91bmRbXTtcbiAgY3VycmVudFJvdW5kOiBudW1iZXI7XG4gIGVsaW1pbmF0ZWRUZWFtczogVGVhbVtdO1xuICBjaGFtcGlvbnNoaXBNYXRjaGVzUGxheWVkOiBudW1iZXI7XG4gIHdpbm5lcj86IFRlYW07XG4gIHdpbm5lcnNCcmFja2V0RmluYWxMb3Nlcj86IFRlYW07IC8vIHRyYWNrcyB0aGUgd2lubmVyJ3MgYnJhY2tldCBmaW5hbCBsb3NlciBmb3IgY2hhbXBpb25zaGlwIHJlbWF0Y2ggbG9naWNcbn1cblxuZXhwb3J0IGNvbnN0IGNyZWF0ZU1hdGNoID0gKFxuICBpZDogc3RyaW5nLFxuICByb3VuZE51bWJlcjogbnVtYmVyLFxuICB0ZWFtMTogVGVhbSB8IG51bGwsXG4gIHRlYW0yOiBUZWFtIHwgbnVsbCxcbiAgaXNCeWU6IGJvb2xlYW4gPSBmYWxzZSxcbiAgYnJhY2tldDogXCJ3aW5uZXJzXCIgfCBcImxvc2Vyc1wiIHwgXCJjaGFtcGlvbnNoaXBcIiA9IFwid2lubmVyc1wiLFxuICBuZXh0TWF0Y2hJZD86IHN0cmluZyxcbiAgbmV4dExvc2VyTWF0Y2hJZD86IHN0cmluZ1xuKTogTWF0Y2ggPT4gKHtcbiAgaWQsXG4gIHJvdW5kTnVtYmVyLFxuICB0ZWFtMSxcbiAgdGVhbTIsXG4gIGlzQ29tcGxldGVkOiBpc0J5ZSxcbiAgaXNCeWUsXG4gIGJyYWNrZXQsXG4gIHdpbm5lcjogaXNCeWUgPyAodGVhbTEgPz8gdGVhbTIgPz8gdW5kZWZpbmVkKSA6IHVuZGVmaW5lZCxcbiAgbG9zZXI6IGlzQnllID8gdW5kZWZpbmVkIDogdW5kZWZpbmVkLFxuICBzY29yZTogeyB0ZWFtMVNjb3JlOiAwLCB0ZWFtMlNjb3JlOiAwIH0sXG4gIG5leHRNYXRjaElkLFxuICBuZXh0TG9zZXJNYXRjaElkLFxuICBlbGltaW5hdGVkTGFiZWw6IHVuZGVmaW5lZFxufSk7XG5cbmV4cG9ydCBjb25zdCBjcmVhdGVJbml0aWFsUm91bmRzID0gKHRlYW1zOiBUZWFtW10pOiBUb3VybmFtZW50ID0+IHtcbiAgY29uc3QgbnVtVGVhbXMgPSB0ZWFtcy5sZW5ndGg7XG4gIGNvbnN0IG1hdGNoZXM6IE1hdGNoW10gPSBbXTtcbiAgY29uc3QgbnVtUm91bmRzID0gTWF0aC5jZWlsKE1hdGgubG9nMihudW1UZWFtcykpO1xuXG4gIGNvbnN0IGZpcnN0Um91bmRNYXRjaGVzID0gTWF0aC5wb3coMiwgbnVtUm91bmRzIC0gMSk7XG4gIGxldCBtYXRjaENvdW50ZXIgPSAxO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZmlyc3RSb3VuZE1hdGNoZXM7IGkrKykge1xuICAgIGNvbnN0IHRlYW0xID0gdGVhbXNbaSAqIDJdIHx8IG51bGw7XG4gICAgY29uc3QgdGVhbTIgPSB0ZWFtc1tpICogMiArIDFdIHx8IG51bGw7XG4gICAgY29uc3QgaXNCeWUgPSAhdGVhbTEgfHwgIXRlYW0yO1xuXG4gICAgY29uc3QgbWF0Y2hJZCA9IGBXMS0ke21hdGNoQ291bnRlcn1gO1xuICAgIGNvbnN0IG5leHRNYXRjaElkID0gYFcyLSR7TWF0aC5jZWlsKG1hdGNoQ291bnRlciAvIDIpfWA7XG4gICAgY29uc3QgbmV4dExvc2VyTWF0Y2hJZCA9IGBMMS0ke01hdGguY2VpbChtYXRjaENvdW50ZXIgLyAyKX1gO1xuXG4gICAgbWF0Y2hlcy5wdXNoKFxuICAgICAgY3JlYXRlTWF0Y2goXG4gICAgICAgIG1hdGNoSWQsXG4gICAgICAgIDEsXG4gICAgICAgIHRlYW0xLFxuICAgICAgICB0ZWFtMixcbiAgICAgICAgaXNCeWUsXG4gICAgICAgIFwid2lubmVyc1wiLFxuICAgICAgICBuZXh0TWF0Y2hJZCxcbiAgICAgICAgbmV4dExvc2VyTWF0Y2hJZFxuICAgICAgKVxuICAgICk7XG4gICAgbWF0Y2hDb3VudGVyKys7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHJvdW5kczogW1xuICAgICAge1xuICAgICAgICByb3VuZE51bWJlcjogMSxcbiAgICAgICAgbWF0Y2hlcyxcbiAgICAgICAgaXNEb3VibGVFbGltaW5hdGlvbjogdHJ1ZSxcbiAgICAgICAgaXNDaGFtcGlvbnNoaXBSb3VuZDogZmFsc2VcbiAgICAgIH1cbiAgICBdLFxuICAgIGN1cnJlbnRSb3VuZDogMSxcbiAgICBlbGltaW5hdGVkVGVhbXM6IFtdLFxuICAgIGNoYW1waW9uc2hpcE1hdGNoZXNQbGF5ZWQ6IDBcbiAgfTtcbn07XG5cbmV4cG9ydCBjb25zdCB1cGRhdGVNYXRjaFNjb3JlID0gKFxuICBtYXRjaDogTWF0Y2gsXG4gIG5ld1Njb3JlOiB7IHRlYW0xU2NvcmU6IG51bWJlcjsgdGVhbTJTY29yZTogbnVtYmVyIH1cbik6IE1hdGNoID0+IHtcbiAgY29uc3QgaXNDb21wbGV0ZWQgPSBuZXdTY29yZS50ZWFtMVNjb3JlICE9PSBuZXdTY29yZS50ZWFtMlNjb3JlO1xuICBsZXQgd2lubmVyOiBUZWFtIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuICBsZXQgbG9zZXI6IFRlYW0gfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG4gIGlmIChpc0NvbXBsZXRlZCkge1xuICAgIGlmIChuZXdTY29yZS50ZWFtMVNjb3JlID4gbmV3U2NvcmUudGVhbTJTY29yZSkge1xuICAgICAgd2lubmVyID0gbWF0Y2gudGVhbTEgPyB7IC4uLm1hdGNoLnRlYW0xLCB3aW5zOiAobWF0Y2gudGVhbTEud2lucyA/PyAwKSArIDEsIGxvc3NlczogbWF0Y2gudGVhbTEubG9zc2VzID8/IDAgfSA6IHVuZGVmaW5lZDtcbiAgICAgIGxvc2VyID0gbWF0Y2gudGVhbTIgPyB7IC4uLm1hdGNoLnRlYW0yLCB3aW5zOiBtYXRjaC50ZWFtMi53aW5zID8/IDAsIGxvc3NlczogKG1hdGNoLnRlYW0yLmxvc3NlcyA/PyAwKSArIDEgfSA6IHVuZGVmaW5lZDtcbiAgICB9IGVsc2Uge1xuICAgICAgd2lubmVyID0gbWF0Y2gudGVhbTIgPyB7IC4uLm1hdGNoLnRlYW0yLCB3aW5zOiAobWF0Y2gudGVhbTIud2lucyA/PyAwKSArIDEsIGxvc3NlczogbWF0Y2gudGVhbTIubG9zc2VzID8/IDAgfSA6IHVuZGVmaW5lZDtcbiAgICAgIGxvc2VyID0gbWF0Y2gudGVhbTEgPyB7IC4uLm1hdGNoLnRlYW0xLCB3aW5zOiBtYXRjaC50ZWFtMS53aW5zID8/IDAsIGxvc3NlczogKG1hdGNoLnRlYW0xLmxvc3NlcyA/PyAwKSArIDEgfSA6IHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICAuLi5tYXRjaCxcbiAgICBzY29yZTogbmV3U2NvcmUsXG4gICAgaXNDb21wbGV0ZWQsXG4gICAgd2lubmVyLFxuICAgIGxvc2VyXG4gIH07XG59O1xuXG4vLyBIZWxwZXIgdG8gZGVkdXBsaWNhdGUgdGVhbXMgYnkgSURcbmZ1bmN0aW9uIGRlZHVwZVRlYW1zKHRlYW1zOiBUZWFtW10pOiBUZWFtW10ge1xuICBjb25zdCBzZWVuID0gbmV3IFNldDxzdHJpbmc+KCk7XG4gIHJldHVybiB0ZWFtcy5maWx0ZXIodGVhbSA9PiB7XG4gICAgaWYgKCF0ZWFtKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKHNlZW4uaGFzKHRlYW0uaWQpKSByZXR1cm4gZmFsc2U7XG4gICAgc2Vlbi5hZGQodGVhbS5pZCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0pO1xufVxuXG4vLyBIZWxwZXI6IGdldCBhbGwgdGVhbXMgd2l0aCBleGFjdGx5IE4gbG9zc2VzXG5mdW5jdGlvbiB0ZWFtc1dpdGhMb3NzZXMobG9zc0NvdW50czogUmVjb3JkPHN0cmluZywgbnVtYmVyPiwgbjogbnVtYmVyKTogc3RyaW5nW10ge1xuICByZXR1cm4gT2JqZWN0LmtleXMobG9zc0NvdW50cykuZmlsdGVyKHRlYW1JZCA9PiBsb3NzQ291bnRzW3RlYW1JZF0gPT09IG4pO1xufVxuZXhwb3J0IGNvbnN0IGFkdmFuY2VUb05leHRSb3VuZCA9ICh0b3VybmFtZW50OiBUb3VybmFtZW50KTogVG91cm5hbWVudCA9PiB7XG4gIGNvbnN0IGN1cnJlbnRSb3VuZCA9IHRvdXJuYW1lbnQucm91bmRzW3RvdXJuYW1lbnQucm91bmRzLmxlbmd0aCAtIDFdO1xuICBjb25zdCBuZXh0Um91bmROdW1iZXIgPSB0b3VybmFtZW50LmN1cnJlbnRSb3VuZCArIDE7XG5cbiAgLy8gV0lOTkVSIEdVQVJEOiBJZiBhIHdpbm5lciBoYXMgYWxyZWFkeSBiZWVuIGRldGVybWluZWQsIGRvIG5vdCBjcmVhdGUgYW55IG1vcmUgcm91bmRzXG4gIGlmICh0b3VybmFtZW50Lndpbm5lcikge1xuICAgIHJldHVybiB7XG4gICAgICAuLi50b3VybmFtZW50LFxuICAgICAgY3VycmVudFJvdW5kOiB0b3VybmFtZW50LmN1cnJlbnRSb3VuZFxuICAgIH07XG4gIH1cblxuICAvLyBUcmFjayBhbGwgbG9zc2VzIGFuZCB3aW5zIGFjcm9zcyB0aGUgdG91cm5hbWVudFxuICBjb25zdCBsb3NzQ291bnRzOiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+ID0ge307XG4gIGNvbnN0IHdpbnNDb3VudHM6IFJlY29yZDxzdHJpbmcsIG51bWJlcj4gPSB7fTtcbiAgdG91cm5hbWVudC5yb3VuZHMuZm9yRWFjaCgocm91bmQpID0+IHtcbiAgICByb3VuZC5tYXRjaGVzLmZvckVhY2goKG1hdGNoKSA9PiB7XG4gICAgICBpZiAobWF0Y2guaXNDb21wbGV0ZWQgJiYgbWF0Y2gubG9zZXIpIHtcbiAgICAgICAgbG9zc0NvdW50c1ttYXRjaC5sb3Nlci5pZF0gPSAobG9zc0NvdW50c1ttYXRjaC5sb3Nlci5pZF0gfHwgMCkgKyAxO1xuICAgICAgfVxuICAgICAgaWYgKG1hdGNoLmlzQ29tcGxldGVkICYmIG1hdGNoLndpbm5lcikge1xuICAgICAgICB3aW5zQ291bnRzW21hdGNoLndpbm5lci5pZF0gPSAod2luc0NvdW50c1ttYXRjaC53aW5uZXIuaWRdIHx8IDApICsgMTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG5cbiAgLy8gR2F0aGVyIGFsbCB0ZWFtcyBldmVyIGluIHRoZSB0b3VybmFtZW50LCBhdHRhY2hpbmcgd2lucyBhbmQgbG9zc2VzXG4gIGNvbnN0IGFsbFRlYW1zOiBUZWFtW10gPSBbXTtcbiAgY29uc3QgdGVhbUlkcyA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuICBmb3IgKGNvbnN0IHJvdW5kIG9mIHRvdXJuYW1lbnQucm91bmRzKSB7XG4gICAgZm9yIChjb25zdCBtYXRjaCBvZiByb3VuZC5tYXRjaGVzKSB7XG4gICAgICBpZiAobWF0Y2gudGVhbTEgJiYgIXRlYW1JZHMuaGFzKG1hdGNoLnRlYW0xLmlkKSkge1xuICAgICAgICBhbGxUZWFtcy5wdXNoKHtcbiAgICAgICAgICAuLi5tYXRjaC50ZWFtMSxcbiAgICAgICAgICB3aW5zOiB3aW5zQ291bnRzW21hdGNoLnRlYW0xLmlkXSB8fCAwLFxuICAgICAgICAgIGxvc3NlczogbG9zc0NvdW50c1ttYXRjaC50ZWFtMS5pZF0gfHwgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGVhbUlkcy5hZGQobWF0Y2gudGVhbTEuaWQpO1xuICAgICAgfVxuICAgICAgaWYgKG1hdGNoLnRlYW0yICYmICF0ZWFtSWRzLmhhcyhtYXRjaC50ZWFtMi5pZCkpIHtcbiAgICAgICAgYWxsVGVhbXMucHVzaCh7XG4gICAgICAgICAgLi4ubWF0Y2gudGVhbTIsXG4gICAgICAgICAgd2luczogd2luc0NvdW50c1ttYXRjaC50ZWFtMi5pZF0gfHwgMCxcbiAgICAgICAgICBsb3NzZXM6IGxvc3NDb3VudHNbbWF0Y2gudGVhbTIuaWRdIHx8IDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRlYW1JZHMuYWRkKG1hdGNoLnRlYW0yLmlkKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBJZGVudGlmeSBuZXdseSBlbGltaW5hdGVkIHRlYW1zICgyIGxvc3NlcylcbiAgY29uc3QgbmV3bHlFbGltaW5hdGVkOiBUZWFtW10gPSBbXTtcbiAgZm9yIChjb25zdCB0ZWFtIG9mIGFsbFRlYW1zKSB7XG4gICAgaWYgKFxuICAgICAgKGxvc3NDb3VudHNbdGVhbS5pZF0gfHwgMCkgPj0gMiAmJlxuICAgICAgIXRvdXJuYW1lbnQuZWxpbWluYXRlZFRlYW1zLnNvbWUoKHQpID0+IHQuaWQgPT09IHRlYW0uaWQpXG4gICAgKSB7XG4gICAgICBuZXdseUVsaW1pbmF0ZWQucHVzaCh0ZWFtKTtcbiAgICB9XG4gIH1cblxuICAvLyBXaW5uZXJzOiB0ZWFtcyB3aXRoIDAgbG9zc2VzIGFuZCBub3QgZWxpbWluYXRlZFxuICBjb25zdCB3aW5uZXJzQnJhY2tldFRlYW1zID0gYWxsVGVhbXNcbiAgICAuZmlsdGVyKFxuICAgICAgKHRlYW0pID0+XG4gICAgICAgIChsb3NzQ291bnRzW3RlYW0uaWRdIHx8IDApID09PSAwICYmXG4gICAgICAgICF0b3VybmFtZW50LmVsaW1pbmF0ZWRUZWFtcy5zb21lKCh0KSA9PiB0LmlkID09PSB0ZWFtLmlkKSAmJlxuICAgICAgICAhbmV3bHlFbGltaW5hdGVkLnNvbWUoKHQpID0+IHQuaWQgPT09IHRlYW0uaWQpICYmXG4gICAgICAgICF0ZWFtLmlkLnN0YXJ0c1dpdGgoXCJ0YmQtXCIpIC8vIEV4Y2x1ZGUgcGhhbnRvbSBUQkQgdGVhbXNcbiAgICApO1xuXG4gIC8vIExvc2VyczogdGVhbXMgd2l0aCAxIGxvc3MgYW5kIG5vdCBlbGltaW5hdGVkXG4gIGNvbnN0IGxvc2Vyc0JyYWNrZXRUZWFtcyA9IGFsbFRlYW1zXG4gICAgLmZpbHRlcihcbiAgICAgICh0ZWFtKSA9PlxuICAgICAgICAobG9zc0NvdW50c1t0ZWFtLmlkXSB8fCAwKSA9PT0gMSAmJlxuICAgICAgICAhdG91cm5hbWVudC5lbGltaW5hdGVkVGVhbXMuc29tZSgodCkgPT4gdC5pZCA9PT0gdGVhbS5pZCkgJiZcbiAgICAgICAgIW5ld2x5RWxpbWluYXRlZC5zb21lKCh0KSA9PiB0LmlkID09PSB0ZWFtLmlkKSAmJlxuICAgICAgICAvLyBEb24ndCBpbmNsdWRlIHRoZSB3aW5uZXJzIGJyYWNrZXQgZmluYWwgbG9zZXIgaW4gcmVndWxhciBsb3NlcnMgYnJhY2tldCB0ZWFtc1xuICAgICAgICAhKFxuICAgICAgICAgIHRvdXJuYW1lbnQud2lubmVyc0JyYWNrZXRGaW5hbExvc2VyICYmXG4gICAgICAgICAgdG91cm5hbWVudC53aW5uZXJzQnJhY2tldEZpbmFsTG9zZXIuaWQgPT09IHRlYW0uaWRcbiAgICAgICAgKVxuICAgICk7XG5cbiAgbGV0IGlzQ2hhbXBpb25zaGlwUm91bmQgPSBmYWxzZTtcbiAgbGV0IGNoYW1waW9uc2hpcE1hdGNoZXM6IE1hdGNoW10gPSBbXTtcbiAgbGV0IG5leHRSb3VuZE1hdGNoZXM6IE1hdGNoW10gPSBbXTtcblxuICAvLyBHZXQgcHJldmlvdXMgY2hhbXBpb25zaGlwIG1hdGNoZXNcbiAgY29uc3QgcHJldkNoYW1waW9uc2hpcE1hdGNoZXMgPSB0b3VybmFtZW50LnJvdW5kc1xuICAgIC5maWx0ZXIoKHIpID0+IHIuaXNDaGFtcGlvbnNoaXBSb3VuZClcbiAgICAuZmxhdE1hcCgocikgPT4gci5tYXRjaGVzKVxuICAgIC5maWx0ZXIoKG0pID0+IG0uYnJhY2tldCA9PT0gXCJjaGFtcGlvbnNoaXBcIik7XG5cbiAgLy8gLS0tIENIQU1QSU9OU0hJUCBMT0dJQyAtLS1cblxuICAvLyBDaGVjayBpZiBhIGNoYW1waW9uc2hpcCBtYXRjaCBhbHJlYWR5IGhhcHBlbmVkIGFuZCB3YXMgY29tcGxldGVkXG4gIGlmIChcbiAgICBwcmV2Q2hhbXBpb25zaGlwTWF0Y2hlcy5sZW5ndGggPj0gMSAmJlxuICAgIHByZXZDaGFtcGlvbnNoaXBNYXRjaGVzW3ByZXZDaGFtcGlvbnNoaXBNYXRjaGVzLmxlbmd0aCAtIDFdLmlzQ29tcGxldGVkXG4gICkge1xuICAgIGNvbnN0IGxhc3RDaGFtcE1hdGNoID1cbiAgICAgIHByZXZDaGFtcGlvbnNoaXBNYXRjaGVzW3ByZXZDaGFtcGlvbnNoaXBNYXRjaGVzLmxlbmd0aCAtIDFdO1xuICAgIGNvbnN0IHdpbm5lcnNCcmFja2V0VGVhbSA9IGxhc3RDaGFtcE1hdGNoLnRlYW0xO1xuICAgIGNvbnN0IGxvc2Vyc0JyYWNrZXRUZWFtID0gbGFzdENoYW1wTWF0Y2gudGVhbTI7XG5cbiAgICAvLyBJZiBsb3NlcidzIGJyYWNrZXQgdGVhbSB3b24gdGhlIGZpcnN0IGNoYW1waW9uc2hpcCBtYXRjaCwgd2lubmVyJ3MgYnJhY2tldCB0ZWFtIGdldHMgYW5vdGhlciBjaGFuY2VcbiAgICBpZiAoXG4gICAgICBsYXN0Q2hhbXBNYXRjaC53aW5uZXI/LmlkID09PSBsb3NlcnNCcmFja2V0VGVhbT8uaWQgJiZcbiAgICAgIHRvdXJuYW1lbnQuY2hhbXBpb25zaGlwTWF0Y2hlc1BsYXllZCA9PT0gMVxuICAgICkge1xuICAgICAgaXNDaGFtcGlvbnNoaXBSb3VuZCA9IHRydWU7XG4gICAgICAvLyBDcmVhdGUgdGhlIFwicmVzZXRcIiBtYXRjaFxuICAgICAgY2hhbXBpb25zaGlwTWF0Y2hlcy5wdXNoKFxuICAgICAgICBjcmVhdGVNYXRjaChcbiAgICAgICAgICBgQyR7bmV4dFJvdW5kTnVtYmVyfS0xYCxcbiAgICAgICAgICBuZXh0Um91bmROdW1iZXIsXG4gICAgICAgICAgd2lubmVyc0JyYWNrZXRUZWFtLFxuICAgICAgICAgIGxvc2Vyc0JyYWNrZXRUZWFtLFxuICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgIFwiY2hhbXBpb25zaGlwXCJcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRWl0aGVyIHdpbm5lcidzIGJyYWNrZXQgdGVhbSB3b24gZmlyc3QgbWF0Y2gsIG9yIHRoaXMgd2FzIHRoZSByZXNldCBtYXRjaFxuICAgICAgLy8gVG91cm5hbWVudCBpcyBvdmVyLCB3aW5uZXIgd2lsbCBiZSBkZXRlcm1pbmVkIGluIHdpbm5lciBkZXRlY3Rpb24gbG9naWNcbiAgICAgIGlzQ2hhbXBpb25zaGlwUm91bmQgPSB0cnVlO1xuICAgIH1cbiAgfSBcbiAgLy8gQ2hlY2sgaWYgd2UgbmVlZCB0byBjcmVhdGUgdGhlIGNoYW1waW9uc2hpcCBtYXRjaFxuICBlbHNlIGlmIChcbiAgICB3aW5uZXJzQnJhY2tldFRlYW1zLmxlbmd0aCA9PT0gMSAmJiAvLyBXZSBoYXZlIGEgd2lubmVyJ3MgYnJhY2tldCBjaGFtcGlvblxuICAgIGxvc2Vyc0JyYWNrZXRUZWFtcy5sZW5ndGggPT09IDAgJiYgLy8gTm8gdGVhbXMgaW4gcmVndWxhciBsb3NlcnMgYnJhY2tldFxuICAgIHRvdXJuYW1lbnQud2lubmVyc0JyYWNrZXRGaW5hbExvc2VyIC8vIFdlIGhhdmUgdGhlIHdpbm5lcidzIGJyYWNrZXQgZmluYWwgbG9zZXJcbiAgKSB7XG4gICAgLy8gRmluZCB0aGUgd2lubmVyIG9mIHRoZSBsb3NlcnMgYnJhY2tldCBmaW5hbCAoV0JGTCB2cyBzb21lb25lKVxuICAgIGNvbnN0IGxvc2Vyc0JyYWNrZXRGaW5hbE1hdGNoID0gY3VycmVudFJvdW5kLm1hdGNoZXMuZmluZChcbiAgICAgIChtKSA9PiBcbiAgICAgICAgbS5icmFja2V0ID09PSBcImxvc2Vyc1wiICYmIFxuICAgICAgICBtLmlzQ29tcGxldGVkICYmIFxuICAgICAgICAoKG0udGVhbTE/LmlkID09PSB0b3VybmFtZW50Lndpbm5lcnNCcmFja2V0RmluYWxMb3Nlci5pZCkgfHwgXG4gICAgICAgICAobS50ZWFtMj8uaWQgPT09IHRvdXJuYW1lbnQud2lubmVyc0JyYWNrZXRGaW5hbExvc2VyLmlkKSlcbiAgICApO1xuXG4gICAgaWYgKGxvc2Vyc0JyYWNrZXRGaW5hbE1hdGNoICYmIGxvc2Vyc0JyYWNrZXRGaW5hbE1hdGNoLndpbm5lcikge1xuICAgICAgLy8gV2UgaGF2ZSBhIHdpbm5lciBmcm9tIHRoZSBsb3NlcnMgYnJhY2tldCBmaW5hbCAtIGNyZWF0ZSBjaGFtcGlvbnNoaXAgbWF0Y2hcbiAgICAgIGlzQ2hhbXBpb25zaGlwUm91bmQgPSB0cnVlO1xuICAgICAgY2hhbXBpb25zaGlwTWF0Y2hlcy5wdXNoKFxuICAgICAgICBjcmVhdGVNYXRjaChcbiAgICAgICAgICBgQyR7bmV4dFJvdW5kTnVtYmVyfS0xYCxcbiAgICAgICAgICBuZXh0Um91bmROdW1iZXIsXG4gICAgICAgICAgd2lubmVyc0JyYWNrZXRUZWFtc1swXSwgLy8gV2lubmVyJ3MgYnJhY2tldCBjaGFtcGlvblxuICAgICAgICAgIGxvc2Vyc0JyYWNrZXRGaW5hbE1hdGNoLndpbm5lciwgLy8gTG9zZXIncyBicmFja2V0IGNoYW1waW9uXG4gICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgXCJjaGFtcGlvbnNoaXBcIlxuICAgICAgICApXG4gICAgICApO1xuICAgIH1cbiAgfVxuICAvLyBDaGVjayBpZiB3ZSBuZWVkIHRvIGNyZWF0ZSB0aGUgbG9zZXJzIGJyYWNrZXQgZmluYWwgbWF0Y2hcbiAgZWxzZSBpZiAoXG4gICAgd2lubmVyc0JyYWNrZXRUZWFtcy5sZW5ndGggPT09IDEgJiYgLy8gV2UgaGF2ZSBhIHdpbm5lcidzIGJyYWNrZXQgY2hhbXBpb25cbiAgICB0b3VybmFtZW50Lndpbm5lcnNCcmFja2V0RmluYWxMb3NlciAmJiAvLyBXZSBoYXZlIHRoZSB3aW5uZXIncyBicmFja2V0IGZpbmFsIGxvc2VyXG4gICAgbG9zZXJzQnJhY2tldFRlYW1zLmxlbmd0aCA9PT0gMSAvLyBXZSBoYXZlIG9uZSB0ZWFtIGluIGxvc2VycyBicmFja2V0XG4gICkge1xuICAgIC8vIENyZWF0ZSB0aGUgbG9zZXJzIGJyYWNrZXQgZmluYWwgbWF0Y2hcbiAgICBuZXh0Um91bmRNYXRjaGVzLnB1c2goXG4gICAgICBjcmVhdGVNYXRjaChcbiAgICAgICAgYExvc2Vyc0xhc3QtJHtuZXh0Um91bmROdW1iZXJ9YCxcbiAgICAgICAgbmV4dFJvdW5kTnVtYmVyLFxuICAgICAgICBsb3NlcnNCcmFja2V0VGVhbXNbMF0sXG4gICAgICAgIHRvdXJuYW1lbnQud2lubmVyc0JyYWNrZXRGaW5hbExvc2VyLFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgXCJsb3NlcnNcIlxuICAgICAgKVxuICAgICk7XG4gICAgXG4gICAgLy8gU2hvdyBhIHdhaXRpbmcgY2FyZCBmb3IgdGhlIHdpbm5lcnMgYnJhY2tldCBjaGFtcGlvblxuICAgIG5leHRSb3VuZE1hdGNoZXMucHVzaChcbiAgICAgIGNyZWF0ZU1hdGNoKFxuICAgICAgICBgV2lubmVyc0JyYWNrZXRDaGFtcGlvbi13YWl0aW5nLSR7bmV4dFJvdW5kTnVtYmVyfWAsXG4gICAgICAgIG5leHRSb3VuZE51bWJlcixcbiAgICAgICAgd2lubmVyc0JyYWNrZXRUZWFtc1swXSxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgdHJ1ZSxcbiAgICAgICAgXCJ3aW5uZXJzXCJcbiAgICAgIClcbiAgICApO1xuICB9XG4gIC8vIENoZWNrIGlmIHRoaXMgaXMgdGhlIHdpbm5lcidzIGJyYWNrZXQgZmluYWwgKGV4YWN0bHkgMiB0ZWFtcyBpbiB3aW5uZXIncyBicmFja2V0KVxuICBlbHNlIGlmICh3aW5uZXJzQnJhY2tldFRlYW1zLmxlbmd0aCA9PT0gMikge1xuICAgIC8vIENyZWF0ZSB0aGUgd2lubmVyJ3MgYnJhY2tldCBmaW5hbCBtYXRjaFxuICAgIG5leHRSb3VuZE1hdGNoZXMucHVzaChcbiAgICAgIGNyZWF0ZU1hdGNoKFxuICAgICAgICBgVyR7bmV4dFJvdW5kTnVtYmVyfS0xYCxcbiAgICAgICAgbmV4dFJvdW5kTnVtYmVyLFxuICAgICAgICB3aW5uZXJzQnJhY2tldFRlYW1zWzBdLFxuICAgICAgICB3aW5uZXJzQnJhY2tldFRlYW1zWzFdLFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgXCJ3aW5uZXJzXCJcbiAgICAgIClcbiAgICApO1xuXG4gICAgLy8gQ29udGludWUgd2l0aCBsb3NlcnMgYnJhY2tldCBtYXRjaGVzXG4gICAgY3JlYXRlTG9zZXJzQnJhY2tldE1hdGNoZXMoKTtcbiAgfVxuICAvLyBPdGhlcndpc2UsIGNvbnRpbnVlIHdpdGggbm9ybWFsIGJyYWNrZXQgcGxheVxuICBlbHNlIHtcbiAgICBjcmVhdGVTdGFuZGFyZEJyYWNrZXRNYXRjaGVzKCk7XG4gIH1cblxuICAvLyBIZWxwZXIgZnVuY3Rpb24gdG8gY3JlYXRlIHN0YW5kYXJkIGJyYWNrZXQgbWF0Y2hlc1xuICBmdW5jdGlvbiBjcmVhdGVTdGFuZGFyZEJyYWNrZXRNYXRjaGVzKCkge1xuICAgIC8vIC0tLSBXaW5uZXJzIEJyYWNrZXQgTWF0Y2hlcyAtLS1cbiAgICBsZXQgbWF0Y2hDb3VudGVyID0gMTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHdpbm5lcnNCcmFja2V0VGVhbXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgIGNvbnN0IHRlYW0xID0gd2lubmVyc0JyYWNrZXRUZWFtc1tpXTtcbiAgICAgIGNvbnN0IHRlYW0yID0gd2lubmVyc0JyYWNrZXRUZWFtc1tpICsgMV0gPz8gbnVsbDtcbiAgICAgIGNvbnN0IGlzQnllID0gIXRlYW0yO1xuICAgICAgbmV4dFJvdW5kTWF0Y2hlcy5wdXNoKFxuICAgICAgICBjcmVhdGVNYXRjaChcbiAgICAgICAgICBgVyR7bmV4dFJvdW5kTnVtYmVyfS0ke21hdGNoQ291bnRlcn1gLFxuICAgICAgICAgIG5leHRSb3VuZE51bWJlcixcbiAgICAgICAgICB0ZWFtMSxcbiAgICAgICAgICB0ZWFtMixcbiAgICAgICAgICBpc0J5ZSxcbiAgICAgICAgICBcIndpbm5lcnNcIlxuICAgICAgICApXG4gICAgICApO1xuICAgICAgbWF0Y2hDb3VudGVyKys7XG4gICAgfVxuXG4gICAgLy8gQ3JlYXRlIGxvc2VycyBicmFja2V0IG1hdGNoZXNcbiAgICBjcmVhdGVMb3NlcnNCcmFja2V0TWF0Y2hlcygpO1xuICB9XG5cbiAgLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGNyZWF0ZSBsb3NlcnMgYnJhY2tldCBtYXRjaGVzXG4gIGZ1bmN0aW9uIGNyZWF0ZUxvc2Vyc0JyYWNrZXRNYXRjaGVzKCkge1xuICAgIC8vIEZpbmQgdGVhbXMgcmVjZW50bHkgZHJvcHBlZCBmcm9tIHdpbm5lcnMgYnJhY2tldFxuICAgIGNvbnN0IGp1c3REcm9wcGVkRnJvbVdpbm5lcnMgPSBjdXJyZW50Um91bmQubWF0Y2hlc1xuICAgICAgLmZpbHRlcigobSkgPT4gbS5icmFja2V0ID09PSBcIndpbm5lcnNcIiAmJiBtLmxvc2VyICYmIG0uaXNDb21wbGV0ZWQpXG4gICAgICAubWFwKChtKSA9PiBtLmxvc2VyISlcbiAgICAgIC5maWx0ZXIoKGxvc2VyKSA9PiBcbiAgICAgICAgIXRvdXJuYW1lbnQuZWxpbWluYXRlZFRlYW1zLnNvbWUoKHQpID0+IHQuaWQgPT09IGxvc2VyLmlkKSAmJlxuICAgICAgICAhbmV3bHlFbGltaW5hdGVkLnNvbWUoKHQpID0+IHQuaWQgPT09IGxvc2VyLmlkKVxuICAgICAgKTtcblxuICAgIC8vIElmIHRoaXMgaXMgdGhlIHdpbm5lcidzIGJyYWNrZXQgZmluYWwsIHN0b3JlIHRoZSBsb3NlciBmb3IgbGF0ZXIgdXNlXG4gICAgaWYgKFxuICAgICAgY3VycmVudFJvdW5kLm1hdGNoZXMuc29tZShcbiAgICAgICAgKG0pID0+XG4gICAgICAgICAgbS5icmFja2V0ID09PSBcIndpbm5lcnNcIiAmJlxuICAgICAgICAgIHdpbm5lcnNCcmFja2V0VGVhbXMubGVuZ3RoID09PSAxICYmXG4gICAgICAgICAgbS5sb3NlciAmJlxuICAgICAgICAgIG0uaXNDb21wbGV0ZWRcbiAgICAgIClcbiAgICApIHtcbiAgICAgIC8vIFRoaXMgaXMgYSBzcGVjaWFsIGNhc2UgLSB3ZSBmb3VuZCB0aGUgd2lubmVyJ3MgYnJhY2tldCBmaW5hbCBsb3NlclxuICAgICAgY29uc3Qgd2lubmVyc0ZpbmFsTG9zZXIgPSBjdXJyZW50Um91bmQubWF0Y2hlc1xuICAgICAgICAuZmlsdGVyKChtKSA9PiBtLmJyYWNrZXQgPT09IFwid2lubmVyc1wiICYmIG0uaXNDb21wbGV0ZWQgJiYgbS5sb3NlcilcbiAgICAgICAgLm1hcCgobSkgPT4gbS5sb3NlciEpXG4gICAgICAgIC5wb3AoKTtcblxuICAgICAgaWYgKFxuICAgICAgICB3aW5uZXJzRmluYWxMb3NlciAmJlxuICAgICAgICAhdG91cm5hbWVudC5lbGltaW5hdGVkVGVhbXMuc29tZSgodCkgPT4gdC5pZCA9PT0gd2lubmVyc0ZpbmFsTG9zZXIuaWQpXG4gICAgICApIHtcbiAgICAgICAgdG91cm5hbWVudC53aW5uZXJzQnJhY2tldEZpbmFsTG9zZXIgPSB3aW5uZXJzRmluYWxMb3NlcjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDb21iaW5lIGFsbCBlbGlnaWJsZSBsb3NlcnMgYnJhY2tldCB0ZWFtc1xuICAgIGNvbnN0IG9yZGVyZWRMb3NlcnMgPSBbXG4gICAgICAuLi5qdXN0RHJvcHBlZEZyb21XaW5uZXJzLFxuICAgICAgLi4ubG9zZXJzQnJhY2tldFRlYW1zXG4gICAgXTtcblxuICAgIGlmIChvcmRlcmVkTG9zZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgIGlmIChvcmRlcmVkTG9zZXJzLmxlbmd0aCAlIDIgPT09IDEpIHtcbiAgICAgICAgLy8gT2RkIG51bWJlciBvZiB0ZWFtczogZ2l2ZSBieWUgdG8gbW9zdCByZWNlbnQgdGVhbSBmcm9tIHdpbm5lcnMgYnJhY2tldFxuICAgICAgICBsZXQgdGVhbVdpdGhCeWU6IFRlYW0gfCBudWxsID0gbnVsbDtcbiAgICAgICAgaWYgKGp1c3REcm9wcGVkRnJvbVdpbm5lcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHRlYW1XaXRoQnllID0ganVzdERyb3BwZWRGcm9tV2lubmVyc1tqdXN0RHJvcHBlZEZyb21XaW5uZXJzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgIC8vIFJlbW92ZSB0aGUgYnllIHRlYW0gZnJvbSBvcmRlcmVkTG9zZXJzXG4gICAgICAgICAgY29uc3QgYnllSW5kZXggPSBvcmRlcmVkTG9zZXJzLmZpbmRJbmRleChcbiAgICAgICAgICAgICh0KSA9PiB0LmlkID09PSB0ZWFtV2l0aEJ5ZSEuaWRcbiAgICAgICAgICApO1xuICAgICAgICAgIGlmIChieWVJbmRleCAhPT0gLTEpIG9yZGVyZWRMb3NlcnMuc3BsaWNlKGJ5ZUluZGV4LCAxKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBGYWxsYmFjayB0byBmaXJzdCB0ZWFtIGlmIG5vIHJlY2VudCBkcm9wXG4gICAgICAgICAgdGVhbVdpdGhCeWUgPSBvcmRlcmVkTG9zZXJzLnNoaWZ0KCkhO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBuZXh0Um91bmRNYXRjaGVzLnB1c2goXG4gICAgICAgICAgY3JlYXRlTWF0Y2goXG4gICAgICAgICAgICBgTCR7bmV4dFJvdW5kTnVtYmVyfS0xYCxcbiAgICAgICAgICAgIG5leHRSb3VuZE51bWJlcixcbiAgICAgICAgICAgIHRlYW1XaXRoQnllLFxuICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgIHRydWUsXG4gICAgICAgICAgICBcImxvc2Vyc1wiXG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgICBcbiAgICAgICAgLy8gUGFpciB0aGUgcmVzdFxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9yZGVyZWRMb3NlcnMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICBjb25zdCB0ZWFtMSA9IG9yZGVyZWRMb3NlcnNbaV07XG4gICAgICAgICAgY29uc3QgdGVhbTIgPSBvcmRlcmVkTG9zZXJzW2kgKyAxXSA/PyBudWxsO1xuICAgICAgICAgIG5leHRSb3VuZE1hdGNoZXMucHVzaChcbiAgICAgICAgICAgIGNyZWF0ZU1hdGNoKFxuICAgICAgICAgICAgICBgTCR7bmV4dFJvdW5kTnVtYmVyfS0ke01hdGguZmxvb3IoaSAvIDIpICsgMn1gLFxuICAgICAgICAgICAgICBuZXh0Um91bmROdW1iZXIsXG4gICAgICAgICAgICAgIHRlYW0xLFxuICAgICAgICAgICAgICB0ZWFtMixcbiAgICAgICAgICAgICAgIXRlYW0yLFxuICAgICAgICAgICAgICBcImxvc2Vyc1wiXG4gICAgICAgICAgICApXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRXZlbiBudW1iZXI6IHBhaXIgYWxsIHRlYW1zXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3JkZXJlZExvc2Vycy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgIGNvbnN0IHRlYW0xID0gb3JkZXJlZExvc2Vyc1tpXTtcbiAgICAgICAgICBjb25zdCB0ZWFtMiA9IG9yZGVyZWRMb3NlcnNbaSArIDFdID8/IG51bGw7XG4gICAgICAgICAgbmV4dFJvdW5kTWF0Y2hlcy5wdXNoKFxuICAgICAgICAgICAgY3JlYXRlTWF0Y2goXG4gICAgICAgICAgICAgIGBMJHtuZXh0Um91bmROdW1iZXJ9LSR7TWF0aC5mbG9vcihpIC8gMikgKyAxfWAsXG4gICAgICAgICAgICAgIG5leHRSb3VuZE51bWJlcixcbiAgICAgICAgICAgICAgdGVhbTEsXG4gICAgICAgICAgICAgIHRlYW0yLFxuICAgICAgICAgICAgICAhdGVhbTIsXG4gICAgICAgICAgICAgIFwibG9zZXJzXCJcbiAgICAgICAgICAgIClcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gLS0tIFdpbm5lciBkZXRlY3Rpb24gbG9naWMgLS0tXG4gIGxldCB3aW5uZXI6IFRlYW0gfCB1bmRlZmluZWQgPSB0b3VybmFtZW50Lndpbm5lcjtcblxuICBpZiAoaXNDaGFtcGlvbnNoaXBSb3VuZCkge1xuICAgIC8vIEZpbmQgdGhlIGxhc3QgY2hhbXBpb25zaGlwIG1hdGNoIHBsYXllZFxuICAgIGNvbnN0IGxhc3RDaGFtcE1hdGNoID1cbiAgICAgIGNoYW1waW9uc2hpcE1hdGNoZXNbMF0gfHxcbiAgICAgIHByZXZDaGFtcGlvbnNoaXBNYXRjaGVzW3ByZXZDaGFtcGlvbnNoaXBNYXRjaGVzLmxlbmd0aCAtIDFdO1xuXG4gICAgaWYgKFxuICAgICAgbGFzdENoYW1wTWF0Y2ggJiZcbiAgICAgIGxhc3RDaGFtcE1hdGNoLmlzQ29tcGxldGVkICYmXG4gICAgICBsYXN0Q2hhbXBNYXRjaC53aW5uZXJcbiAgICApIHtcbiAgICAgIGNvbnN0IHdpbm5lcnNCcmFja2V0VGVhbSA9IGxhc3RDaGFtcE1hdGNoLnRlYW0xO1xuICAgICAgY29uc3QgbG9zZXJzQnJhY2tldFRlYW0gPSBsYXN0Q2hhbXBNYXRjaC50ZWFtMjtcbiAgICAgIGNvbnN0IGxvc2Vyc0JyYWNrZXRUZWFtV29uID1cbiAgICAgICAgbG9zZXJzQnJhY2tldFRlYW0gJiYgbGFzdENoYW1wTWF0Y2gud2lubmVyLmlkID09PSBsb3NlcnNCcmFja2V0VGVhbS5pZDtcblxuICAgICAgLy8gSWYgbG9zZXIncyBicmFja2V0IHRlYW0gd29uIGZpcnN0IGNoYW1waW9uc2hpcCBtYXRjaCwgd2lubmVyJ3MgYnJhY2tldCB0ZWFtIGdldHMgYW5vdGhlciBjaGFuY2VcbiAgICAgIGlmIChsb3NlcnNCcmFja2V0VGVhbVdvbiAmJiB0b3VybmFtZW50LmNoYW1waW9uc2hpcE1hdGNoZXNQbGF5ZWQgPT09IDEpIHtcbiAgICAgICAgd2lubmVyID0gdW5kZWZpbmVkOyAvLyBObyB3aW5uZXIgeWV0LCBuZWVkIHJlc2V0IG1hdGNoXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBFaXRoZXIgd2lubmVyJ3MgYnJhY2tldCB0ZWFtIHdvbiBmaXJzdCBtYXRjaCwgb3IgdGhpcyB3YXMgdGhlIHJlc2V0IG1hdGNoXG4gICAgICAgIHdpbm5lciA9IGxhc3RDaGFtcE1hdGNoLndpbm5lcjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyAtLS0gSU5GSU5JVEUgUkVDVVJTSU9OIEdVQVJEIC0tLVxuICBjb25zdCBub01vcmVNYXRjaGVzID1cbiAgICAoaXNDaGFtcGlvbnNoaXBSb3VuZCAmJiBjaGFtcGlvbnNoaXBNYXRjaGVzLmxlbmd0aCA9PT0gMCkgfHxcbiAgICAoIWlzQ2hhbXBpb25zaGlwUm91bmQgJiYgbmV4dFJvdW5kTWF0Y2hlcy5sZW5ndGggPT09IDApO1xuXG4gIGlmIChub01vcmVNYXRjaGVzKSB7XG4gICAgLy8gVG91cm5hbWVudCBpcyBvdmVyLCBkbyBub3QgYWR2YW5jZSBmdXJ0aGVyXG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnRvdXJuYW1lbnQsXG4gICAgICB3aW5uZXIsXG4gICAgICBjdXJyZW50Um91bmQ6IHRvdXJuYW1lbnQuY3VycmVudFJvdW5kXG4gICAgfTtcbiAgfVxuXG4gIC8vIERlYnVnIGxvZyBiZWZvcmUgcmV0dXJuaW5nIHRoZSBuZXcgdG91cm5hbWVudCBvYmplY3RcbiAgbG9nVG91cm5hbWVudFN0YXRlKHtcbiAgICByb3VuZE51bWJlcjogbmV4dFJvdW5kTnVtYmVyLFxuICAgIHdpbm5lcnNCcmFja2V0VGVhbXMsXG4gICAgbG9zZXJzQnJhY2tldFRlYW1zLFxuICAgIG1hdGNoZXM6IGlzQ2hhbXBpb25zaGlwUm91bmQgPyBjaGFtcGlvbnNoaXBNYXRjaGVzIDogbmV4dFJvdW5kTWF0Y2hlcyxcbiAgICB3aW5uZXJzQnJhY2tldEZpbmFsTG9zZXI6IHRvdXJuYW1lbnQud2lubmVyc0JyYWNrZXRGaW5hbExvc2VyXG4gIH0pO1xuXG4gIC8vIFJldHVybiB0aGUgbmV3IHRvdXJuYW1lbnQgc3RhdGVcbiAgcmV0dXJuIHtcbiAgICAuLi50b3VybmFtZW50LFxuICAgIHJvdW5kczogW1xuICAgICAgLi4udG91cm5hbWVudC5yb3VuZHMsXG4gICAgICB7XG4gICAgICAgIHJvdW5kTnVtYmVyOiBuZXh0Um91bmROdW1iZXIsXG4gICAgICAgIG1hdGNoZXM6IGlzQ2hhbXBpb25zaGlwUm91bmQgPyBjaGFtcGlvbnNoaXBNYXRjaGVzIDogbmV4dFJvdW5kTWF0Y2hlcyxcbiAgICAgICAgaXNEb3VibGVFbGltaW5hdGlvbjogdHJ1ZSxcbiAgICAgICAgaXNDaGFtcGlvbnNoaXBSb3VuZFxuICAgICAgfVxuICAgIF0sXG4gICAgY3VycmVudFJvdW5kOiBuZXh0Um91bmROdW1iZXIsXG4gICAgZWxpbWluYXRlZFRlYW1zOiBbXG4gICAgICAuLi50b3VybmFtZW50LmVsaW1pbmF0ZWRUZWFtcyxcbiAgICAgIC4uLm5ld2x5RWxpbWluYXRlZC5maWx0ZXIoXG4gICAgICAgICh0KSA9PiAhdG91cm5hbWVudC5lbGltaW5hdGVkVGVhbXMuc29tZSgoZXQpID0+IGV0LmlkID09PSB0LmlkKVxuICAgICAgKVxuICAgIF0sXG4gICAgY2hhbXBpb25zaGlwTWF0Y2hlc1BsYXllZDogaXNDaGFtcGlvbnNoaXBSb3VuZFxuICAgICAgPyB0b3VybmFtZW50LmNoYW1waW9uc2hpcE1hdGNoZXNQbGF5ZWQgKyAxXG4gICAgICA6IHRvdXJuYW1lbnQuY2hhbXBpb25zaGlwTWF0Y2hlc1BsYXllZCxcbiAgICB3aW5uZXJzQnJhY2tldEZpbmFsTG9zZXI6IHRvdXJuYW1lbnQud2lubmVyc0JyYWNrZXRGaW5hbExvc2VyLFxuICAgIHdpbm5lclxuICB9O1xufTsiXSwibmFtZXMiOlsibG9nVG91cm5hbWVudFN0YXRlIiwiY3JlYXRlTWF0Y2giLCJpZCIsInJvdW5kTnVtYmVyIiwidGVhbTEiLCJ0ZWFtMiIsImlzQnllIiwiYnJhY2tldCIsIm5leHRNYXRjaElkIiwibmV4dExvc2VyTWF0Y2hJZCIsImlzQ29tcGxldGVkIiwid2lubmVyIiwidW5kZWZpbmVkIiwibG9zZXIiLCJzY29yZSIsInRlYW0xU2NvcmUiLCJ0ZWFtMlNjb3JlIiwiZWxpbWluYXRlZExhYmVsIiwiY3JlYXRlSW5pdGlhbFJvdW5kcyIsInRlYW1zIiwibnVtVGVhbXMiLCJsZW5ndGgiLCJtYXRjaGVzIiwibnVtUm91bmRzIiwiTWF0aCIsImNlaWwiLCJsb2cyIiwiZmlyc3RSb3VuZE1hdGNoZXMiLCJwb3ciLCJtYXRjaENvdW50ZXIiLCJpIiwibWF0Y2hJZCIsInB1c2giLCJyb3VuZHMiLCJpc0RvdWJsZUVsaW1pbmF0aW9uIiwiaXNDaGFtcGlvbnNoaXBSb3VuZCIsImN1cnJlbnRSb3VuZCIsImVsaW1pbmF0ZWRUZWFtcyIsImNoYW1waW9uc2hpcE1hdGNoZXNQbGF5ZWQiLCJ1cGRhdGVNYXRjaFNjb3JlIiwibWF0Y2giLCJuZXdTY29yZSIsIndpbnMiLCJsb3NzZXMiLCJkZWR1cGVUZWFtcyIsInNlZW4iLCJTZXQiLCJmaWx0ZXIiLCJ0ZWFtIiwiaGFzIiwiYWRkIiwidGVhbXNXaXRoTG9zc2VzIiwibG9zc0NvdW50cyIsIm4iLCJPYmplY3QiLCJrZXlzIiwidGVhbUlkIiwiYWR2YW5jZVRvTmV4dFJvdW5kIiwidG91cm5hbWVudCIsIm5leHRSb3VuZE51bWJlciIsIndpbnNDb3VudHMiLCJmb3JFYWNoIiwicm91bmQiLCJhbGxUZWFtcyIsInRlYW1JZHMiLCJuZXdseUVsaW1pbmF0ZWQiLCJzb21lIiwidCIsIndpbm5lcnNCcmFja2V0VGVhbXMiLCJzdGFydHNXaXRoIiwibG9zZXJzQnJhY2tldFRlYW1zIiwid2lubmVyc0JyYWNrZXRGaW5hbExvc2VyIiwiY2hhbXBpb25zaGlwTWF0Y2hlcyIsIm5leHRSb3VuZE1hdGNoZXMiLCJwcmV2Q2hhbXBpb25zaGlwTWF0Y2hlcyIsInIiLCJmbGF0TWFwIiwibSIsImxhc3RDaGFtcE1hdGNoIiwid2lubmVyc0JyYWNrZXRUZWFtIiwibG9zZXJzQnJhY2tldFRlYW0iLCJsb3NlcnNCcmFja2V0RmluYWxNYXRjaCIsImZpbmQiLCJjcmVhdGVMb3NlcnNCcmFja2V0TWF0Y2hlcyIsImNyZWF0ZVN0YW5kYXJkQnJhY2tldE1hdGNoZXMiLCJqdXN0RHJvcHBlZEZyb21XaW5uZXJzIiwibWFwIiwid2lubmVyc0ZpbmFsTG9zZXIiLCJwb3AiLCJvcmRlcmVkTG9zZXJzIiwidGVhbVdpdGhCeWUiLCJieWVJbmRleCIsImZpbmRJbmRleCIsInNwbGljZSIsInNoaWZ0IiwiZmxvb3IiLCJsb3NlcnNCcmFja2V0VGVhbVdvbiIsIm5vTW9yZU1hdGNoZXMiLCJldCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./types/tournament/matches.ts\n"));

/***/ })

});
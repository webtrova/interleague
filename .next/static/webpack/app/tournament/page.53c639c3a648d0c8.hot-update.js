"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/tournament/page",{

/***/ "(app-pages-browser)/./types/tournament/index.ts":
/*!***********************************!*\
  !*** ./types/tournament/index.ts ***!
  \***********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   League: function() { return /* binding */ League; },\n/* harmony export */   TournamentStatus: function() { return /* binding */ TournamentStatus; },\n/* harmony export */   advanceToNextRound: function() { return /* reexport safe */ _matches__WEBPACK_IMPORTED_MODULE_3__.advanceToNextRound; },\n/* harmony export */   createInitialRounds: function() { return /* reexport safe */ _matches__WEBPACK_IMPORTED_MODULE_3__.createInitialRounds; },\n/* harmony export */   createMatch: function() { return /* reexport safe */ _matches__WEBPACK_IMPORTED_MODULE_3__.createMatch; },\n/* harmony export */   getTournamentStatus: function() { return /* binding */ getTournamentStatus; },\n/* harmony export */   mlbTeams: function() { return /* reexport module object */ _mlb_teams__WEBPACK_IMPORTED_MODULE_0__; },\n/* harmony export */   nbaTeams: function() { return /* reexport module object */ _nba_teams__WEBPACK_IMPORTED_MODULE_2__; },\n/* harmony export */   nflTeams: function() { return /* reexport module object */ _nfl_teams__WEBPACK_IMPORTED_MODULE_1__; },\n/* harmony export */   updateMatchScore: function() { return /* reexport safe */ _matches__WEBPACK_IMPORTED_MODULE_3__.updateMatchScore; }\n/* harmony export */ });\n/* harmony import */ var _mlb_teams__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./mlb-teams */ \"(app-pages-browser)/./types/tournament/mlb-teams.ts\");\n/* harmony import */ var _nfl_teams__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./nfl-teams */ \"(app-pages-browser)/./types/tournament/nfl-teams.ts\");\n/* harmony import */ var _nba_teams__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./nba-teams */ \"(app-pages-browser)/./types/tournament/nba-teams.ts\");\n/* harmony import */ var _matches__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./matches */ \"(app-pages-browser)/./types/tournament/matches.ts\");\n\n\n\n\n\n\nvar League;\n(function(League) {\n    League[\"MLB\"] = \"MLB\";\n    League[\"NFL\"] = \"NFL\";\n    League[\"NBA\"] = \"NBA\";\n})(League || (League = {}));\n\nvar TournamentStatus;\n(function(TournamentStatus) {\n    TournamentStatus[\"NOT_STARTED\"] = \"NOT_STARTED\";\n    TournamentStatus[\"IN_PROGRESS\"] = \"IN_PROGRESS\";\n    TournamentStatus[\"COMPLETED\"] = \"COMPLETED\";\n})(TournamentStatus || (TournamentStatus = {}));\n// Helper function to get tournament status\nconst getTournamentStatus = (currentRound, totalTeams)=>{\n    if (currentRound === 1) return \"NOT_STARTED\";\n    if (Math.pow(2, totalTeams - currentRound) === 1) return \"COMPLETED\";\n    return \"IN_PROGRESS\";\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3R5cGVzL3RvdXJuYW1lbnQvaW5kZXgudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBd0M7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBOztVQUU1Qkc7Ozs7R0FBQUEsV0FBQUE7QUFNYzs7VUFHZEM7Ozs7R0FBQUEscUJBQUFBO0FBTVosMkNBQTJDO0FBQ3BDLE1BQU1DLHNCQUFzQixDQUNqQ0MsY0FDQUM7SUFFQSxJQUFJRCxpQkFBaUIsR0FBRztJQUN4QixJQUFJRSxLQUFLQyxHQUFHLENBQUMsR0FBR0YsYUFBYUQsa0JBQWtCLEdBQzdDO0lBQ0Y7QUFDRixFQUFFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3R5cGVzL3RvdXJuYW1lbnQvaW5kZXgudHM/ZWMwMiJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgKiBhcyBtbGJUZWFtcyBmcm9tIFwiLi9tbGItdGVhbXNcIjtcbmV4cG9ydCAqIGFzIG5mbFRlYW1zIGZyb20gXCIuL25mbC10ZWFtc1wiO1xuZXhwb3J0ICogYXMgbmJhVGVhbXMgZnJvbSBcIi4vbmJhLXRlYW1zXCI7XG5cbmV4cG9ydCBlbnVtIExlYWd1ZSB7XG4gIE1MQiA9IFwiTUxCXCIsXG4gIE5GTCA9IFwiTkZMXCIsXG4gIE5CQSA9IFwiTkJBXCJcbn1cblxuZXhwb3J0ICogZnJvbSBcIi4vbWF0Y2hlc1wiO1xuXG4vLyBUb3VybmFtZW50IFN0YXR1c1xuZXhwb3J0IGVudW0gVG91cm5hbWVudFN0YXR1cyB7XG4gIE5PVF9TVEFSVEVEID0gXCJOT1RfU1RBUlRFRFwiLFxuICBJTl9QUk9HUkVTUyA9IFwiSU5fUFJPR1JFU1NcIixcbiAgQ09NUExFVEVEID0gXCJDT01QTEVURURcIlxufVxuXG4vLyBIZWxwZXIgZnVuY3Rpb24gdG8gZ2V0IHRvdXJuYW1lbnQgc3RhdHVzXG5leHBvcnQgY29uc3QgZ2V0VG91cm5hbWVudFN0YXR1cyA9IChcbiAgY3VycmVudFJvdW5kOiBudW1iZXIsXG4gIHRvdGFsVGVhbXM6IG51bWJlclxuKTogVG91cm5hbWVudFN0YXR1cyA9PiB7XG4gIGlmIChjdXJyZW50Um91bmQgPT09IDEpIHJldHVybiBUb3VybmFtZW50U3RhdHVzLk5PVF9TVEFSVEVEO1xuICBpZiAoTWF0aC5wb3coMiwgdG90YWxUZWFtcyAtIGN1cnJlbnRSb3VuZCkgPT09IDEpXG4gICAgcmV0dXJuIFRvdXJuYW1lbnRTdGF0dXMuQ09NUExFVEVEO1xuICByZXR1cm4gVG91cm5hbWVudFN0YXR1cy5JTl9QUk9HUkVTUztcbn07XG4iXSwibmFtZXMiOlsibWxiVGVhbXMiLCJuZmxUZWFtcyIsIm5iYVRlYW1zIiwiTGVhZ3VlIiwiVG91cm5hbWVudFN0YXR1cyIsImdldFRvdXJuYW1lbnRTdGF0dXMiLCJjdXJyZW50Um91bmQiLCJ0b3RhbFRlYW1zIiwiTWF0aCIsInBvdyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./types/tournament/index.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./types/tournament/matches.ts":
/*!*************************************!*\
  !*** ./types/tournament/matches.ts ***!
  \*************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   advanceToNextRound: function() { return /* binding */ advanceToNextRound; },\n/* harmony export */   createInitialRounds: function() { return /* binding */ createInitialRounds; },\n/* harmony export */   createMatch: function() { return /* binding */ createMatch; },\n/* harmony export */   updateMatchScore: function() { return /* binding */ updateMatchScore; }\n/* harmony export */ });\nconst createMatch = function(id, roundNumber, team1, team2) {\n    let isBye = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : false, bracket = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : \"winners\", nextMatchId = arguments.length > 6 ? arguments[6] : void 0, nextLoserMatchId = arguments.length > 7 ? arguments[7] : void 0;\n    var _ref;\n    return {\n        id,\n        roundNumber,\n        team1,\n        team2,\n        isCompleted: isBye,\n        isBye,\n        bracket,\n        winner: isBye ? (_ref = team1 !== null && team1 !== void 0 ? team1 : team2) !== null && _ref !== void 0 ? _ref : undefined : undefined,\n        loser: isBye ? undefined : undefined,\n        score: {\n            team1Score: 0,\n            team2Score: 0\n        },\n        nextMatchId,\n        nextLoserMatchId,\n        eliminatedLabel: undefined\n    };\n};\nconst createInitialRounds = (teams)=>{\n    const numTeams = teams.length;\n    const matches = [];\n    const numRounds = Math.ceil(Math.log2(numTeams));\n    const firstRoundMatches = Math.pow(2, numRounds - 1);\n    let matchCounter = 1;\n    for(let i = 0; i < firstRoundMatches; i++){\n        const team1 = teams[i * 2] || null;\n        const team2 = teams[i * 2 + 1] || null;\n        const isBye = !team1 || !team2;\n        const matchId = \"W1-\".concat(matchCounter);\n        const nextMatchId = \"W2-\".concat(Math.ceil(matchCounter / 2));\n        const nextLoserMatchId = \"L1-\".concat(Math.ceil(matchCounter / 2));\n        matches.push(createMatch(matchId, 1, team1, team2, isBye, \"winners\", nextMatchId, nextLoserMatchId));\n        matchCounter++;\n    }\n    return {\n        rounds: [\n            {\n                roundNumber: 1,\n                matches,\n                isDoubleElimination: true,\n                isChampionshipRound: false\n            }\n        ],\n        currentRound: 1,\n        eliminatedTeams: [],\n        championshipMatchesPlayed: 0\n    };\n};\nconst updateMatchScore = (match, newScore)=>{\n    const isCompleted = newScore.team1Score !== newScore.team2Score;\n    let winner = undefined;\n    let loser = undefined;\n    if (isCompleted) {\n        if (newScore.team1Score > newScore.team2Score) {\n            var _match_team1_wins, _match_team1_losses;\n            winner = match.team1 ? {\n                ...match.team1,\n                wins: ((_match_team1_wins = match.team1.wins) !== null && _match_team1_wins !== void 0 ? _match_team1_wins : 0) + 1,\n                losses: (_match_team1_losses = match.team1.losses) !== null && _match_team1_losses !== void 0 ? _match_team1_losses : 0\n            } : undefined;\n            var _match_team2_wins, _match_team2_losses;\n            loser = match.team2 ? {\n                ...match.team2,\n                wins: (_match_team2_wins = match.team2.wins) !== null && _match_team2_wins !== void 0 ? _match_team2_wins : 0,\n                losses: ((_match_team2_losses = match.team2.losses) !== null && _match_team2_losses !== void 0 ? _match_team2_losses : 0) + 1\n            } : undefined;\n        } else {\n            var _match_team2_wins1, _match_team2_losses1;\n            winner = match.team2 ? {\n                ...match.team2,\n                wins: ((_match_team2_wins1 = match.team2.wins) !== null && _match_team2_wins1 !== void 0 ? _match_team2_wins1 : 0) + 1,\n                losses: (_match_team2_losses1 = match.team2.losses) !== null && _match_team2_losses1 !== void 0 ? _match_team2_losses1 : 0\n            } : undefined;\n            var _match_team1_wins1, _match_team1_losses1;\n            loser = match.team1 ? {\n                ...match.team1,\n                wins: (_match_team1_wins1 = match.team1.wins) !== null && _match_team1_wins1 !== void 0 ? _match_team1_wins1 : 0,\n                losses: ((_match_team1_losses1 = match.team1.losses) !== null && _match_team1_losses1 !== void 0 ? _match_team1_losses1 : 0) + 1\n            } : undefined;\n        }\n    }\n    return {\n        ...match,\n        score: newScore,\n        isCompleted,\n        winner,\n        loser\n    };\n};\n// Helper to deduplicate teams by ID\nfunction dedupeTeams(teams) {\n    const seen = new Set();\n    return teams.filter((team)=>{\n        if (!team) return false;\n        if (seen.has(team.id)) return false;\n        seen.add(team.id);\n        return true;\n    });\n}\n// Helper: get all teams with exactly N losses\nfunction teamsWithLosses(lossCounts, n) {\n    return Object.keys(lossCounts).filter((teamId)=>lossCounts[teamId] === n);\n}\nconst advanceToNextRound = (tournament)=>{\n    const currentRound = tournament.rounds[tournament.rounds.length - 1];\n    const nextRoundNumber = tournament.currentRound + 1;\n    // Track all losses and wins across the tournament\n    const lossCounts = {};\n    const winsCounts = {};\n    tournament.rounds.forEach((round)=>{\n        round.matches.forEach((match)=>{\n            if (match.isCompleted && match.loser) {\n                lossCounts[match.loser.id] = (lossCounts[match.loser.id] || 0) + 1;\n            }\n            if (match.isCompleted && match.winner) {\n                winsCounts[match.winner.id] = (winsCounts[match.winner.id] || 0) + 1;\n            }\n        });\n    });\n    // Gather all teams ever in the tournament, attaching wins\n    const allTeams = [];\n    const teamIds = new Set();\n    for (const round of tournament.rounds){\n        for (const match of round.matches){\n            if (match.team1 && !teamIds.has(match.team1.id)) {\n                allTeams.push({\n                    ...match.team1,\n                    wins: winsCounts[match.team1.id] || 0,\n                    losses: lossCounts[match.team1.id] || 0\n                });\n                teamIds.add(match.team1.id);\n            }\n            if (match.team2 && !teamIds.has(match.team2.id)) {\n                allTeams.push({\n                    ...match.team2,\n                    wins: winsCounts[match.team2.id] || 0,\n                    losses: lossCounts[match.team2.id] || 0\n                });\n                teamIds.add(match.team2.id);\n            }\n        }\n    }\n    // Identify newly eliminated teams (2 losses)\n    const newlyEliminated = [];\n    for (const team of allTeams){\n        if ((lossCounts[team.id] || 0) >= 2 && !tournament.eliminatedTeams.some((t)=>t.id === team.id)) {\n            newlyEliminated.push(team);\n        }\n    }\n    // Winners: teams with 0 losses and not eliminated\n    const winnersBracketTeams = allTeams.filter((team)=>(lossCounts[team.id] || 0) === 0 && !tournament.eliminatedTeams.some((t)=>t.id === team.id) && !newlyEliminated.some((t)=>t.id === team.id)).map((team)=>({\n            ...team,\n            losses: lossCounts[team.id] || 0,\n            wins: winsCounts[team.id] || 0\n        }));\n    // Losers: teams with 1 loss and not eliminated\n    const losersBracketTeams = allTeams.filter((team)=>(lossCounts[team.id] || 0) === 1 && !tournament.eliminatedTeams.some((t)=>t.id === team.id) && !newlyEliminated.some((t)=>t.id === team.id)).map((team)=>({\n            ...team,\n            losses: lossCounts[team.id] || 0,\n            wins: winsCounts[team.id] || 0\n        }));\n    let isChampionshipRound = false;\n    let championshipMatches = [];\n    let nextRoundMatches = [];\n    // Flag to track if we've already added a WWB card\n    let wwbCardAdded = false;\n    // Flag to track if we've already added a LWB card\n    let lwbCardAdded = false;\n    const prevChampionshipMatches = tournament.rounds.filter((r)=>r.isChampionshipRound).flatMap((r)=>r.matches).filter((m)=>m.bracket === \"championship\");\n    // --- CHAMPIONSHIP LOGIC ---\n    // Check if a championship match already happened and was completed\n    if (prevChampionshipMatches.length >= 1 && prevChampionshipMatches[prevChampionshipMatches.length - 1].isCompleted) {\n        var _lastChampMatch_winner;\n        const lastChampMatch = prevChampionshipMatches[prevChampionshipMatches.length - 1];\n        const winnersBracketTeam = lastChampMatch.team1;\n        const losersBracketTeam = lastChampMatch.team2;\n        // If loser's bracket team won the first championship match, winner's bracket team gets another chance\n        if (((_lastChampMatch_winner = lastChampMatch.winner) === null || _lastChampMatch_winner === void 0 ? void 0 : _lastChampMatch_winner.id) === (losersBracketTeam === null || losersBracketTeam === void 0 ? void 0 : losersBracketTeam.id) && tournament.championshipMatchesPlayed === 1) {\n            isChampionshipRound = true;\n            // Create the \"reset\" match\n            championshipMatches.push(createMatch(\"C\".concat(nextRoundNumber, \"-1\"), nextRoundNumber, winnersBracketTeam, losersBracketTeam, false, \"championship\"));\n            // Add a placeholder match for the winner's bracket champion in round 8\n            if (!wwbCardAdded) {\n                nextRoundMatches.push(createMatch(\"W\".concat(nextRoundNumber, \"-1\"), nextRoundNumber, winnersBracketTeam, null, true, \"winners\"));\n                wwbCardAdded = true;\n            }\n        } else {\n            // Either winner's bracket team won first match, or this was the reset match\n            isChampionshipRound = true;\n        // No new matches, winner will be determined in winner detection logic\n        }\n    } else if (winnersBracketTeams.length === 1 && losersBracketTeams.length === 1 && currentRound.matches.some((m)=>(m.bracket === \"losers\" || m.id.includes(\"LosersLast\")) && m.isCompleted && m.winner && losersBracketTeams.some((t)=>t.id === m.winner.id))) {\n        // Championship match: Winner's bracket champion vs Loser's bracket champion\n        isChampionshipRound = true;\n        championshipMatches.push(createMatch(\"C\".concat(nextRoundNumber, \"-1\"), nextRoundNumber, winnersBracketTeams[0], losersBracketTeams[0], false, \"championship\"));\n        // Also add a placeholder match for the winner's bracket champion\n        // This ensures the WWB card is still shown\n        if (!wwbCardAdded) {\n            nextRoundMatches.push(createMatch(\"W\".concat(nextRoundNumber, \"-1\"), nextRoundNumber, winnersBracketTeams[0], null, true, \"winners\"));\n            wwbCardAdded = true;\n        }\n    } else if (winnersBracketTeams.length === 1 && // We have a winner's bracket champion\n    losersBracketTeams.length >= 1 && // We have at least one team in loser's bracket\n    tournament.winnersBracketFinalLoser // We have stored the winner's bracket final loser\n    ) {\n        // Find the winner of the loser's bracket\n        const losersBracketWinner = currentRound.matches.filter((m)=>m.bracket === \"losers\" && m.isCompleted && m.winner).map((m)=>m.winner).find((winner)=>losersBracketTeams.some((t)=>t.id === winner.id));\n        if (losersBracketWinner && losersBracketWinner.id !== tournament.winnersBracketFinalLoser.id) {\n            // Only schedule if they're not the same team!\n            nextRoundMatches.push(createMatch(\"LosersLast-\".concat(nextRoundNumber), nextRoundNumber, tournament.winnersBracketFinalLoser, losersBracketWinner, false, \"losers\"));\n            lwbCardAdded = true;\n            // Add a placeholder match for the winner's bracket champion\n            if (!wwbCardAdded) {\n                nextRoundMatches.push(createMatch(\"W\".concat(nextRoundNumber, \"-1\"), nextRoundNumber, winnersBracketTeams[0], null, true, \"winners\"));\n                wwbCardAdded = true;\n            }\n        } else {\n            // Wait for the losers bracket to resolve properly\n            createStandardBracketMatches();\n            // Even when waiting, we should still show the WWB and LWB cards\n            if (winnersBracketTeams.length === 1 && tournament.winnersBracketFinalLoser) {\n                // Add a placeholder match for the winner's bracket champion\n                if (!wwbCardAdded) {\n                    nextRoundMatches.push(createMatch(\"W\".concat(nextRoundNumber, \"-1\"), nextRoundNumber, winnersBracketTeams[0], null, true, \"winners\"));\n                    wwbCardAdded = true;\n                }\n                // Add a placeholder for the loser of winner's bracket final\n                // This ensures the LWB card is shown while waiting\n                if (!lwbCardAdded) {\n                    nextRoundMatches.push(createMatch(\"LWB\".concat(nextRoundNumber, \"-1\"), nextRoundNumber, tournament.winnersBracketFinalLoser, null, true, \"losers\"));\n                    lwbCardAdded = true;\n                }\n            }\n        }\n    } else if (winnersBracketTeams.length === 2 && losersBracketTeams.length >= 1) {\n        // Create the winner's bracket final match\n        nextRoundMatches.push(createMatch(\"W\".concat(nextRoundNumber, \"-1\"), nextRoundNumber, winnersBracketTeams[0], winnersBracketTeams[1], false, \"winners\"));\n        wwbCardAdded = true;\n        // Continue with losers bracket matches separately\n        createLosersBracketMatches();\n    } else {\n        createStandardBracketMatches();\n    }\n    // Helper function to create standard bracket matches\n    function createStandardBracketMatches() {\n        // --- Winners Bracket Matches ---\n        let matchCounter = 1;\n        for(let i = 0; i < winnersBracketTeams.length; i += 2){\n            const team1 = winnersBracketTeams[i];\n            var _winnersBracketTeams_;\n            const team2 = (_winnersBracketTeams_ = winnersBracketTeams[i + 1]) !== null && _winnersBracketTeams_ !== void 0 ? _winnersBracketTeams_ : null;\n            const isBye = !team2;\n            nextRoundMatches.push(createMatch(\"W\".concat(nextRoundNumber, \"-\").concat(matchCounter), nextRoundNumber, team1, team2, isBye, \"winners\"));\n            wwbCardAdded = true;\n            matchCounter++;\n        }\n        // Create losers bracket matches separately\n        createLosersBracketMatches();\n    }\n    // Helper function to create losers bracket matches\n    function createLosersBracketMatches() {\n        // --- Losers Bracket Matches ---\n        const eligibleLosers = allTeams.filter((team)=>(lossCounts[team.id] || 0) === 1 && !tournament.eliminatedTeams.some((t)=>t.id === team.id) && !newlyEliminated.some((t)=>t.id === team.id) && // Exclude winner's bracket final loser if it exists but hasn't played yet in losers\n            !(tournament.winnersBracketFinalLoser && tournament.winnersBracketFinalLoser.id === team.id));\n        // Find teams recently dropped from winners bracket\n        const justDroppedFromWinners = currentRound.matches.filter((m)=>m.bracket === \"winners\" && m.loser && m.isCompleted).map((m)=>m.loser).filter((loser)=>eligibleLosers.some((t)=>t.id === loser.id));\n        // If this is the winner's bracket final, store the loser for later use\n        if (currentRound.matches.some((m)=>m.bracket === \"winners\" && winnersBracketTeams.length === 1 && m.loser && m.isCompleted)) {\n            // This is a special case - we found the winner's bracket final loser\n            const winnersFinalLoser = currentRound.matches.filter((m)=>m.bracket === \"winners\" && m.isCompleted && m.loser).map((m)=>m.loser).pop();\n            if (winnersFinalLoser) {\n                tournament.winnersBracketFinalLoser = winnersFinalLoser;\n                // Always add a placeholder for the loser of winner's bracket final in round 7\n                // This ensures the LWB card is shown\n                if (nextRoundNumber === 7 && !lwbCardAdded) {\n                    nextRoundMatches.push(createMatch(\"LWB\".concat(nextRoundNumber, \"-1\"), nextRoundNumber, winnersFinalLoser, null, true, \"losers\"));\n                    lwbCardAdded = true;\n                }\n            }\n        }\n        // Existing losers bracket teams\n        const existingLosers = eligibleLosers.filter((t)=>!justDroppedFromWinners.some((jd)=>jd.id === t.id));\n        // Order: most recent drop(s) first\n        const orderedLosers = [\n            ...justDroppedFromWinners,\n            ...existingLosers\n        ];\n        if (orderedLosers.length > 0) {\n            if (orderedLosers.length % 2 === 1) {\n                // Odd: bye goes to the most recent team dropped from winners bracket\n                let teamWithBye = null;\n                if (justDroppedFromWinners.length > 0) {\n                    teamWithBye = justDroppedFromWinners[justDroppedFromWinners.length - 1];\n                    // Remove the bye team from orderedLosers\n                    const byeIndex = orderedLosers.findIndex((t)=>t.id === teamWithBye.id);\n                    if (byeIndex !== -1) orderedLosers.splice(byeIndex, 1);\n                } else {\n                    // Defensive: fallback to first team if no recent drop\n                    teamWithBye = orderedLosers.shift();\n                }\n                nextRoundMatches.push(createMatch(\"L\".concat(nextRoundNumber, \"-1\"), nextRoundNumber, teamWithBye, null, true, \"losers\"));\n                // Pair the rest\n                for(let i = 0; i < orderedLosers.length; i += 2){\n                    const team1 = orderedLosers[i];\n                    var _orderedLosers_;\n                    const team2 = (_orderedLosers_ = orderedLosers[i + 1]) !== null && _orderedLosers_ !== void 0 ? _orderedLosers_ : null;\n                    nextRoundMatches.push(createMatch(\"L\".concat(nextRoundNumber, \"-\").concat(Math.floor(i / 2) + 2), nextRoundNumber, team1, team2, !team2, \"losers\"));\n                }\n            } else {\n                // Even number: pair all\n                for(let i = 0; i < orderedLosers.length; i += 2){\n                    const team1 = orderedLosers[i];\n                    var _orderedLosers_1;\n                    const team2 = (_orderedLosers_1 = orderedLosers[i + 1]) !== null && _orderedLosers_1 !== void 0 ? _orderedLosers_1 : null;\n                    nextRoundMatches.push(createMatch(\"L\".concat(nextRoundNumber, \"-\").concat(Math.floor(i / 2) + 1), nextRoundNumber, team1, team2, !team2, \"losers\"));\n                }\n            }\n        }\n        // If we're in round 7 and there's a winner's bracket final loser but no LWB card yet\n        if (nextRoundNumber === 7 && tournament.winnersBracketFinalLoser && !lwbCardAdded) {\n            nextRoundMatches.push(createMatch(\"LWB\".concat(nextRoundNumber, \"-1\"), nextRoundNumber, tournament.winnersBracketFinalLoser, null, true, \"losers\"));\n            lwbCardAdded = true;\n        }\n    }\n    // --- Winner detection logic ---\n    let winner = tournament.winner;\n    if (isChampionshipRound) {\n        // Find the last championship match played\n        const lastChampMatch = championshipMatches[0] || prevChampionshipMatches[prevChampionshipMatches.length - 1];\n        if (lastChampMatch && lastChampMatch.isCompleted && lastChampMatch.winner && lastChampMatch.loser) {\n            const winnersBracketTeam = lastChampMatch.team1;\n            const losersBracketTeam = lastChampMatch.team2;\n            const losersBracketTeamWon = losersBracketTeam && lastChampMatch.winner.id === losersBracketTeam.id;\n            // If loser's bracket team won first championship match, winner's bracket team gets another chance\n            if (losersBracketTeamWon && tournament.championshipMatchesPlayed === 1) {\n                winner = undefined; // No winner yet, need reset match\n            } else {\n                // Either winner's bracket team won first match, or this was the reset match\n                winner = lastChampMatch.winner;\n            }\n        }\n    }\n    // --- INFINITE RECURSION GUARD ---\n    const noMoreMatches = isChampionshipRound && championshipMatches.length === 0 || !isChampionshipRound && nextRoundMatches.length === 0;\n    if (noMoreMatches) {\n        // Tournament is over, do not advance further\n        return {\n            ...tournament,\n            winner,\n            currentRound: tournament.currentRound\n        };\n    }\n    // Ensure LWB card is added for round 7 if it hasn't been added yet\n    if (nextRoundNumber === 7 && tournament.winnersBracketFinalLoser && !lwbCardAdded) {\n        nextRoundMatches.push(createMatch(\"LWB\".concat(nextRoundNumber, \"-1\"), nextRoundNumber, tournament.winnersBracketFinalLoser, null, true, \"losers\"));\n    }\n    // Compose the new tournament object\n    return {\n        ...tournament,\n        rounds: [\n            ...tournament.rounds,\n            {\n                roundNumber: nextRoundNumber,\n                matches: isChampionshipRound ? championshipMatches : nextRoundMatches,\n                isDoubleElimination: true,\n                isChampionshipRound\n            }\n        ],\n        currentRound: nextRoundNumber,\n        eliminatedTeams: [\n            ...tournament.eliminatedTeams,\n            ...newlyEliminated.filter((t)=>!tournament.eliminatedTeams.some((et)=>et.id === t.id))\n        ],\n        championshipMatchesPlayed: isChampionshipRound ? tournament.championshipMatchesPlayed + 1 : tournament.championshipMatchesPlayed,\n        winnersBracketFinalLoser: tournament.winnersBracketFinalLoser,\n        winner\n    };\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3R5cGVzL3RvdXJuYW1lbnQvbWF0Y2hlcy50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBbUNPLE1BQU1BLGNBQWMsU0FDekJDLElBQ0FDLGFBQ0FDLE9BQ0FDO1FBQ0FDLHlFQUFpQixPQUNqQkMsMkVBQWlELFdBQ2pEQyw0REFDQUM7UUFTZ0JMO1dBUkw7UUFDWEY7UUFDQUM7UUFDQUM7UUFDQUM7UUFDQUssYUFBYUo7UUFDYkE7UUFDQUM7UUFDQUksUUFBUUwsUUFBUUYsQ0FBQUEsT0FBQUEsa0JBQUFBLG1CQUFBQSxRQUFTQyxtQkFBVEQsa0JBQUFBLE9BQWtCUSxZQUFZQTtRQUM5Q0MsT0FBT1AsUUFBUU0sWUFBWUE7UUFDM0JFLE9BQU87WUFBRUMsWUFBWTtZQUFHQyxZQUFZO1FBQUU7UUFDdENSO1FBQ0FDO1FBQ0FRLGlCQUFpQkw7SUFDbkI7QUFBQSxFQUFHO0FBRUksTUFBTU0sc0JBQXNCLENBQUNDO0lBQ2xDLE1BQU1DLFdBQVdELE1BQU1FLE1BQU07SUFDN0IsTUFBTUMsVUFBbUIsRUFBRTtJQUMzQixNQUFNQyxZQUFZQyxLQUFLQyxJQUFJLENBQUNELEtBQUtFLElBQUksQ0FBQ047SUFFdEMsTUFBTU8sb0JBQW9CSCxLQUFLSSxHQUFHLENBQUMsR0FBR0wsWUFBWTtJQUNsRCxJQUFJTSxlQUFlO0lBRW5CLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJSCxtQkFBbUJHLElBQUs7UUFDMUMsTUFBTTFCLFFBQVFlLEtBQUssQ0FBQ1csSUFBSSxFQUFFLElBQUk7UUFDOUIsTUFBTXpCLFFBQVFjLEtBQUssQ0FBQ1csSUFBSSxJQUFJLEVBQUUsSUFBSTtRQUNsQyxNQUFNeEIsUUFBUSxDQUFDRixTQUFTLENBQUNDO1FBRXpCLE1BQU0wQixVQUFVLE1BQW1CLE9BQWJGO1FBQ3RCLE1BQU1yQixjQUFjLE1BQWtDLE9BQTVCZ0IsS0FBS0MsSUFBSSxDQUFDSSxlQUFlO1FBQ25ELE1BQU1wQixtQkFBbUIsTUFBa0MsT0FB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QUFNLENBQ3ZCLENBQUNvQixJQUFNLENBQUNULFdBQVdyQixlQUFlLENBQUM2QixJQUFJLENBQUMsQ0FBQ3FDLEtBQU9BLEdBQUdyRyxFQUFFLEtBQUtpRSxFQUFFakUsRUFBRTtTQUVqRTtRQUNEb0MsMkJBQTJCSCxzQkFDdkJ1QixXQUFXcEIseUJBQXlCLEdBQUcsSUFDdkNvQixXQUFXcEIseUJBQXlCO1FBQ3hDNkMsMEJBQTBCekIsV0FBV3lCLHdCQUF3QjtRQUM3RHhFO0lBQ0Y7QUFDRixFQUFFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3R5cGVzL3RvdXJuYW1lbnQvbWF0Y2hlcy50cz9kYTIyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0eXBlIHsgVGVhbSB9IGZyb20gXCIuL21sYi10ZWFtc1wiO1xuXG5leHBvcnQgaW50ZXJmYWNlIE1hdGNoIHtcbiAgaWQ6IHN0cmluZztcbiAgcm91bmROdW1iZXI6IG51bWJlcjtcbiAgdGVhbTE6IFRlYW0gfCBudWxsO1xuICB0ZWFtMjogVGVhbSB8IG51bGw7XG4gIGlzQ29tcGxldGVkOiBib29sZWFuO1xuICBpc0J5ZT86IGJvb2xlYW47XG4gIHdpbm5lcj86IFRlYW07XG4gIGxvc2VyPzogVGVhbTtcbiAgYnJhY2tldDogXCJ3aW5uZXJzXCIgfCBcImxvc2Vyc1wiIHwgXCJjaGFtcGlvbnNoaXBcIjtcbiAgc2NvcmU6IHsgdGVhbTFTY29yZTogbnVtYmVyOyB0ZWFtMlNjb3JlOiBudW1iZXIgfTtcbiAgbmV4dE1hdGNoSWQ/OiBzdHJpbmc7XG4gIG5leHRMb3Nlck1hdGNoSWQ/OiBzdHJpbmc7XG4gIGVsaW1pbmF0ZWRMYWJlbD86IHN0cmluZzsgLy8gbGFiZWwgZm9yIGVsaW1pbmF0ZWQgdGVhbXMgaW4gbG9zZXJzIGJyYWNrZXRcbiAgcmVxdWlyZXNSZW1hdGNoPzogYm9vbGVhbjsgLy8gaW5kaWNhdGVzIGlmIGEgY2hhbXBpb25zaGlwIHJlbWF0Y2ggaXMgcmVxdWlyZWRcbn1cblxuZXhwb3J0IGludGVyZmFjZSBSb3VuZCB7XG4gIHJvdW5kTnVtYmVyOiBudW1iZXI7XG4gIG1hdGNoZXM6IE1hdGNoW107XG4gIGlzRG91YmxlRWxpbWluYXRpb246IGJvb2xlYW47XG4gIGlzQ2hhbXBpb25zaGlwUm91bmQ6IGJvb2xlYW47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVG91cm5hbWVudCB7XG4gIHJvdW5kczogUm91bmRbXTtcbiAgY3VycmVudFJvdW5kOiBudW1iZXI7XG4gIGVsaW1pbmF0ZWRUZWFtczogVGVhbVtdO1xuICBjaGFtcGlvbnNoaXBNYXRjaGVzUGxheWVkOiBudW1iZXI7XG4gIHdpbm5lcj86IFRlYW07XG4gIHdpbm5lcnNCcmFja2V0RmluYWxMb3Nlcj86IFRlYW07IC8vIHRyYWNrcyB0aGUgd2lubmVyJ3MgYnJhY2tldCBmaW5hbCBsb3NlciBmb3IgY2hhbXBpb25zaGlwIHJlbWF0Y2ggbG9naWNcbn1cblxuZXhwb3J0IGNvbnN0IGNyZWF0ZU1hdGNoID0gKFxuICBpZDogc3RyaW5nLFxuICByb3VuZE51bWJlcjogbnVtYmVyLFxuICB0ZWFtMTogVGVhbSB8IG51bGwsXG4gIHRlYW0yOiBUZWFtIHwgbnVsbCxcbiAgaXNCeWU6IGJvb2xlYW4gPSBmYWxzZSxcbiAgYnJhY2tldDogXCJ3aW5uZXJzXCIgfCBcImxvc2Vyc1wiIHwgXCJjaGFtcGlvbnNoaXBcIiA9IFwid2lubmVyc1wiLFxuICBuZXh0TWF0Y2hJZD86IHN0cmluZyxcbiAgbmV4dExvc2VyTWF0Y2hJZD86IHN0cmluZ1xuKTogTWF0Y2ggPT4gKHtcbiAgaWQsXG4gIHJvdW5kTnVtYmVyLFxuICB0ZWFtMSxcbiAgdGVhbTIsXG4gIGlzQ29tcGxldGVkOiBpc0J5ZSxcbiAgaXNCeWUsXG4gIGJyYWNrZXQsXG4gIHdpbm5lcjogaXNCeWUgPyB0ZWFtMSA/PyB0ZWFtMiA/PyB1bmRlZmluZWQgOiB1bmRlZmluZWQsXG4gIGxvc2VyOiBpc0J5ZSA/IHVuZGVmaW5lZCA6IHVuZGVmaW5lZCxcbiAgc2NvcmU6IHsgdGVhbTFTY29yZTogMCwgdGVhbTJTY29yZTogMCB9LFxuICBuZXh0TWF0Y2hJZCxcbiAgbmV4dExvc2VyTWF0Y2hJZCxcbiAgZWxpbWluYXRlZExhYmVsOiB1bmRlZmluZWRcbn0pO1xuXG5leHBvcnQgY29uc3QgY3JlYXRlSW5pdGlhbFJvdW5kcyA9ICh0ZWFtczogVGVhbVtdKTogVG91cm5hbWVudCA9PiB7XG4gIGNvbnN0IG51bVRlYW1zID0gdGVhbXMubGVuZ3RoO1xuICBjb25zdCBtYXRjaGVzOiBNYXRjaFtdID0gW107XG4gIGNvbnN0IG51bVJvdW5kcyA9IE1hdGguY2VpbChNYXRoLmxvZzIobnVtVGVhbXMpKTtcblxuICBjb25zdCBmaXJzdFJvdW5kTWF0Y2hlcyA9IE1hdGgucG93KDIsIG51bVJvdW5kcyAtIDEpO1xuICBsZXQgbWF0Y2hDb3VudGVyID0gMTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGZpcnN0Um91bmRNYXRjaGVzOyBpKyspIHtcbiAgICBjb25zdCB0ZWFtMSA9IHRlYW1zW2kgKiAyXSB8fCBudWxsO1xuICAgIGNvbnN0IHRlYW0yID0gdGVhbXNbaSAqIDIgKyAxXSB8fCBudWxsO1xuICAgIGNvbnN0IGlzQnllID0gIXRlYW0xIHx8ICF0ZWFtMjtcblxuICAgIGNvbnN0IG1hdGNoSWQgPSBgVzEtJHttYXRjaENvdW50ZXJ9YDtcbiAgICBjb25zdCBuZXh0TWF0Y2hJZCA9IGBXMi0ke01hdGguY2VpbChtYXRjaENvdW50ZXIgLyAyKX1gO1xuICAgIGNvbnN0IG5leHRMb3Nlck1hdGNoSWQgPSBgTDEtJHtNYXRoLmNlaWwobWF0Y2hDb3VudGVyIC8gMil9YDtcblxuICAgIG1hdGNoZXMucHVzaChcbiAgICAgIGNyZWF0ZU1hdGNoKFxuICAgICAgICBtYXRjaElkLFxuICAgICAgICAxLFxuICAgICAgICB0ZWFtMSxcbiAgICAgICAgdGVhbTIsXG4gICAgICAgIGlzQnllLFxuICAgICAgICBcIndpbm5lcnNcIixcbiAgICAgICAgbmV4dE1hdGNoSWQsXG4gICAgICAgIG5leHRMb3Nlck1hdGNoSWRcbiAgICAgIClcbiAgICApO1xuICAgIG1hdGNoQ291bnRlcisrO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICByb3VuZHM6IFtcbiAgICAgIHtcbiAgICAgICAgcm91bmROdW1iZXI6IDEsXG4gICAgICAgIG1hdGNoZXMsXG4gICAgICAgIGlzRG91YmxlRWxpbWluYXRpb246IHRydWUsXG4gICAgICAgIGlzQ2hhbXBpb25zaGlwUm91bmQ6IGZhbHNlXG4gICAgICB9XG4gICAgXSxcbiAgICBjdXJyZW50Um91bmQ6IDEsXG4gICAgZWxpbWluYXRlZFRlYW1zOiBbXSxcbiAgICBjaGFtcGlvbnNoaXBNYXRjaGVzUGxheWVkOiAwXG4gIH07XG59O1xuXG5leHBvcnQgY29uc3QgdXBkYXRlTWF0Y2hTY29yZSA9IChcbiAgbWF0Y2g6IE1hdGNoLFxuICBuZXdTY29yZTogeyB0ZWFtMVNjb3JlOiBudW1iZXI7IHRlYW0yU2NvcmU6IG51bWJlciB9XG4pOiBNYXRjaCA9PiB7XG4gIGNvbnN0IGlzQ29tcGxldGVkID0gbmV3U2NvcmUudGVhbTFTY29yZSAhPT0gbmV3U2NvcmUudGVhbTJTY29yZTtcbiAgbGV0IHdpbm5lcjogVGVhbSB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcbiAgbGV0IGxvc2VyOiBUZWFtIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuICBpZiAoaXNDb21wbGV0ZWQpIHtcbiAgICBpZiAobmV3U2NvcmUudGVhbTFTY29yZSA+IG5ld1Njb3JlLnRlYW0yU2NvcmUpIHtcbiAgICAgIHdpbm5lciA9IG1hdGNoLnRlYW0xXG4gICAgICAgID8ge1xuICAgICAgICAgICAgLi4ubWF0Y2gudGVhbTEsXG4gICAgICAgICAgICB3aW5zOiAobWF0Y2gudGVhbTEud2lucyA/PyAwKSArIDEsXG4gICAgICAgICAgICBsb3NzZXM6IG1hdGNoLnRlYW0xLmxvc3NlcyA/PyAwXG4gICAgICAgICAgfVxuICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgIGxvc2VyID0gbWF0Y2gudGVhbTJcbiAgICAgICAgPyB7XG4gICAgICAgICAgICAuLi5tYXRjaC50ZWFtMixcbiAgICAgICAgICAgIHdpbnM6IG1hdGNoLnRlYW0yLndpbnMgPz8gMCxcbiAgICAgICAgICAgIGxvc3NlczogKG1hdGNoLnRlYW0yLmxvc3NlcyA/PyAwKSArIDFcbiAgICAgICAgICB9XG4gICAgICAgIDogdW5kZWZpbmVkO1xuICAgIH0gZWxzZSB7XG4gICAgICB3aW5uZXIgPSBtYXRjaC50ZWFtMlxuICAgICAgICA/IHtcbiAgICAgICAgICAgIC4uLm1hdGNoLnRlYW0yLFxuICAgICAgICAgICAgd2luczogKG1hdGNoLnRlYW0yLndpbnMgPz8gMCkgKyAxLFxuICAgICAgICAgICAgbG9zc2VzOiBtYXRjaC50ZWFtMi5sb3NzZXMgPz8gMFxuICAgICAgICAgIH1cbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICBsb3NlciA9IG1hdGNoLnRlYW0xXG4gICAgICAgID8ge1xuICAgICAgICAgICAgLi4ubWF0Y2gudGVhbTEsXG4gICAgICAgICAgICB3aW5zOiBtYXRjaC50ZWFtMS53aW5zID8/IDAsXG4gICAgICAgICAgICBsb3NzZXM6IChtYXRjaC50ZWFtMS5sb3NzZXMgPz8gMCkgKyAxXG4gICAgICAgICAgfVxuICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICAuLi5tYXRjaCxcbiAgICBzY29yZTogbmV3U2NvcmUsXG4gICAgaXNDb21wbGV0ZWQsXG4gICAgd2lubmVyLFxuICAgIGxvc2VyXG4gIH07XG59O1xuXG4vLyBIZWxwZXIgdG8gZGVkdXBsaWNhdGUgdGVhbXMgYnkgSURcbmZ1bmN0aW9uIGRlZHVwZVRlYW1zKHRlYW1zOiBUZWFtW10pOiBUZWFtW10ge1xuICBjb25zdCBzZWVuID0gbmV3IFNldDxzdHJpbmc+KCk7XG4gIHJldHVybiB0ZWFtcy5maWx0ZXIoKHRlYW0pID0+IHtcbiAgICBpZiAoIXRlYW0pIHJldHVybiBmYWxzZTtcbiAgICBpZiAoc2Vlbi5oYXModGVhbS5pZCkpIHJldHVybiBmYWxzZTtcbiAgICBzZWVuLmFkZCh0ZWFtLmlkKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSk7XG59XG5cbi8vIEhlbHBlcjogZ2V0IGFsbCB0ZWFtcyB3aXRoIGV4YWN0bHkgTiBsb3NzZXNcbmZ1bmN0aW9uIHRlYW1zV2l0aExvc3NlcyhcbiAgbG9zc0NvdW50czogUmVjb3JkPHN0cmluZywgbnVtYmVyPixcbiAgbjogbnVtYmVyXG4pOiBzdHJpbmdbXSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyhsb3NzQ291bnRzKS5maWx0ZXIoKHRlYW1JZCkgPT4gbG9zc0NvdW50c1t0ZWFtSWRdID09PSBuKTtcbn1cbmV4cG9ydCBjb25zdCBhZHZhbmNlVG9OZXh0Um91bmQgPSAodG91cm5hbWVudDogVG91cm5hbWVudCk6IFRvdXJuYW1lbnQgPT4ge1xuICBjb25zdCBjdXJyZW50Um91bmQgPSB0b3VybmFtZW50LnJvdW5kc1t0b3VybmFtZW50LnJvdW5kcy5sZW5ndGggLSAxXTtcbiAgY29uc3QgbmV4dFJvdW5kTnVtYmVyID0gdG91cm5hbWVudC5jdXJyZW50Um91bmQgKyAxO1xuXG4gIC8vIFRyYWNrIGFsbCBsb3NzZXMgYW5kIHdpbnMgYWNyb3NzIHRoZSB0b3VybmFtZW50XG4gIGNvbnN0IGxvc3NDb3VudHM6IFJlY29yZDxzdHJpbmcsIG51bWJlcj4gPSB7fTtcbiAgY29uc3Qgd2luc0NvdW50czogUmVjb3JkPHN0cmluZywgbnVtYmVyPiA9IHt9O1xuICB0b3VybmFtZW50LnJvdW5kcy5mb3JFYWNoKChyb3VuZCkgPT4ge1xuICAgIHJvdW5kLm1hdGNoZXMuZm9yRWFjaCgobWF0Y2gpID0+IHtcbiAgICAgIGlmIChtYXRjaC5pc0NvbXBsZXRlZCAmJiBtYXRjaC5sb3Nlcikge1xuICAgICAgICBsb3NzQ291bnRzW21hdGNoLmxvc2VyLmlkXSA9IChsb3NzQ291bnRzW21hdGNoLmxvc2VyLmlkXSB8fCAwKSArIDE7XG4gICAgICB9XG4gICAgICBpZiAobWF0Y2guaXNDb21wbGV0ZWQgJiYgbWF0Y2gud2lubmVyKSB7XG4gICAgICAgIHdpbnNDb3VudHNbbWF0Y2gud2lubmVyLmlkXSA9ICh3aW5zQ291bnRzW21hdGNoLndpbm5lci5pZF0gfHwgMCkgKyAxO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcblxuICAvLyBHYXRoZXIgYWxsIHRlYW1zIGV2ZXIgaW4gdGhlIHRvdXJuYW1lbnQsIGF0dGFjaGluZyB3aW5zXG4gIGNvbnN0IGFsbFRlYW1zOiBUZWFtW10gPSBbXTtcbiAgY29uc3QgdGVhbUlkcyA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuICBmb3IgKGNvbnN0IHJvdW5kIG9mIHRvdXJuYW1lbnQucm91bmRzKSB7XG4gICAgZm9yIChjb25zdCBtYXRjaCBvZiByb3VuZC5tYXRjaGVzKSB7XG4gICAgICBpZiAobWF0Y2gudGVhbTEgJiYgIXRlYW1JZHMuaGFzKG1hdGNoLnRlYW0xLmlkKSkge1xuICAgICAgICBhbGxUZWFtcy5wdXNoKHtcbiAgICAgICAgICAuLi5tYXRjaC50ZWFtMSxcbiAgICAgICAgICB3aW5zOiB3aW5zQ291bnRzW21hdGNoLnRlYW0xLmlkXSB8fCAwLFxuICAgICAgICAgIGxvc3NlczogbG9zc0NvdW50c1ttYXRjaC50ZWFtMS5pZF0gfHwgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGVhbUlkcy5hZGQobWF0Y2gudGVhbTEuaWQpO1xuICAgICAgfVxuICAgICAgaWYgKG1hdGNoLnRlYW0yICYmICF0ZWFtSWRzLmhhcyhtYXRjaC50ZWFtMi5pZCkpIHtcbiAgICAgICAgYWxsVGVhbXMucHVzaCh7XG4gICAgICAgICAgLi4ubWF0Y2gudGVhbTIsXG4gICAgICAgICAgd2luczogd2luc0NvdW50c1ttYXRjaC50ZWFtMi5pZF0gfHwgMCxcbiAgICAgICAgICBsb3NzZXM6IGxvc3NDb3VudHNbbWF0Y2gudGVhbTIuaWRdIHx8IDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRlYW1JZHMuYWRkKG1hdGNoLnRlYW0yLmlkKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBJZGVudGlmeSBuZXdseSBlbGltaW5hdGVkIHRlYW1zICgyIGxvc3NlcylcbiAgY29uc3QgbmV3bHlFbGltaW5hdGVkOiBUZWFtW10gPSBbXTtcbiAgZm9yIChjb25zdCB0ZWFtIG9mIGFsbFRlYW1zKSB7XG4gICAgaWYgKFxuICAgICAgKGxvc3NDb3VudHNbdGVhbS5pZF0gfHwgMCkgPj0gMiAmJlxuICAgICAgIXRvdXJuYW1lbnQuZWxpbWluYXRlZFRlYW1zLnNvbWUoKHQpID0+IHQuaWQgPT09IHRlYW0uaWQpXG4gICAgKSB7XG4gICAgICBuZXdseUVsaW1pbmF0ZWQucHVzaCh0ZWFtKTtcbiAgICB9XG4gIH1cblxuICAvLyBXaW5uZXJzOiB0ZWFtcyB3aXRoIDAgbG9zc2VzIGFuZCBub3QgZWxpbWluYXRlZFxuICBjb25zdCB3aW5uZXJzQnJhY2tldFRlYW1zID0gYWxsVGVhbXNcbiAgICAuZmlsdGVyKFxuICAgICAgKHRlYW0pID0+XG4gICAgICAgIChsb3NzQ291bnRzW3RlYW0uaWRdIHx8IDApID09PSAwICYmXG4gICAgICAgICF0b3VybmFtZW50LmVsaW1pbmF0ZWRUZWFtcy5zb21lKCh0KSA9PiB0LmlkID09PSB0ZWFtLmlkKSAmJlxuICAgICAgICAhbmV3bHlFbGltaW5hdGVkLnNvbWUoKHQpID0+IHQuaWQgPT09IHRlYW0uaWQpXG4gICAgKVxuICAgIC5tYXAoKHRlYW0pID0+ICh7XG4gICAgICAuLi50ZWFtLFxuICAgICAgbG9zc2VzOiBsb3NzQ291bnRzW3RlYW0uaWRdIHx8IDAsXG4gICAgICB3aW5zOiB3aW5zQ291bnRzW3RlYW0uaWRdIHx8IDBcbiAgICB9KSk7XG5cbiAgLy8gTG9zZXJzOiB0ZWFtcyB3aXRoIDEgbG9zcyBhbmQgbm90IGVsaW1pbmF0ZWRcbiAgY29uc3QgbG9zZXJzQnJhY2tldFRlYW1zID0gYWxsVGVhbXNcbiAgICAuZmlsdGVyKFxuICAgICAgKHRlYW0pID0+XG4gICAgICAgIChsb3NzQ291bnRzW3RlYW0uaWRdIHx8IDApID09PSAxICYmXG4gICAgICAgICF0b3VybmFtZW50LmVsaW1pbmF0ZWRUZWFtcy5zb21lKCh0KSA9PiB0LmlkID09PSB0ZWFtLmlkKSAmJlxuICAgICAgICAhbmV3bHlFbGltaW5hdGVkLnNvbWUoKHQpID0+IHQuaWQgPT09IHRlYW0uaWQpXG4gICAgKVxuICAgIC5tYXAoKHRlYW0pID0+ICh7XG4gICAgICAuLi50ZWFtLFxuICAgICAgbG9zc2VzOiBsb3NzQ291bnRzW3RlYW0uaWRdIHx8IDAsXG4gICAgICB3aW5zOiB3aW5zQ291bnRzW3RlYW0uaWRdIHx8IDBcbiAgICB9KSk7XG5cbiAgbGV0IGlzQ2hhbXBpb25zaGlwUm91bmQgPSBmYWxzZTtcbiAgbGV0IGNoYW1waW9uc2hpcE1hdGNoZXM6IE1hdGNoW10gPSBbXTtcbiAgbGV0IG5leHRSb3VuZE1hdGNoZXM6IE1hdGNoW10gPSBbXTtcbiAgLy8gRmxhZyB0byB0cmFjayBpZiB3ZSd2ZSBhbHJlYWR5IGFkZGVkIGEgV1dCIGNhcmRcbiAgbGV0IHd3YkNhcmRBZGRlZCA9IGZhbHNlO1xuICAvLyBGbGFnIHRvIHRyYWNrIGlmIHdlJ3ZlIGFscmVhZHkgYWRkZWQgYSBMV0IgY2FyZFxuICBsZXQgbHdiQ2FyZEFkZGVkID0gZmFsc2U7XG5cbiAgY29uc3QgcHJldkNoYW1waW9uc2hpcE1hdGNoZXMgPSB0b3VybmFtZW50LnJvdW5kc1xuICAgIC5maWx0ZXIoKHIpID0+IHIuaXNDaGFtcGlvbnNoaXBSb3VuZClcbiAgICAuZmxhdE1hcCgocikgPT4gci5tYXRjaGVzKVxuICAgIC5maWx0ZXIoKG0pID0+IG0uYnJhY2tldCA9PT0gXCJjaGFtcGlvbnNoaXBcIik7XG5cbiAgLy8gLS0tIENIQU1QSU9OU0hJUCBMT0dJQyAtLS1cblxuICAvLyBDaGVjayBpZiBhIGNoYW1waW9uc2hpcCBtYXRjaCBhbHJlYWR5IGhhcHBlbmVkIGFuZCB3YXMgY29tcGxldGVkXG4gIGlmIChcbiAgICBwcmV2Q2hhbXBpb25zaGlwTWF0Y2hlcy5sZW5ndGggPj0gMSAmJlxuICAgIHByZXZDaGFtcGlvbnNoaXBNYXRjaGVzW3ByZXZDaGFtcGlvbnNoaXBNYXRjaGVzLmxlbmd0aCAtIDFdLmlzQ29tcGxldGVkXG4gICkge1xuICAgIGNvbnN0IGxhc3RDaGFtcE1hdGNoID1cbiAgICAgIHByZXZDaGFtcGlvbnNoaXBNYXRjaGVzW3ByZXZDaGFtcGlvbnNoaXBNYXRjaGVzLmxlbmd0aCAtIDFdO1xuICAgIGNvbnN0IHdpbm5lcnNCcmFja2V0VGVhbSA9IGxhc3RDaGFtcE1hdGNoLnRlYW0xO1xuICAgIGNvbnN0IGxvc2Vyc0JyYWNrZXRUZWFtID0gbGFzdENoYW1wTWF0Y2gudGVhbTI7XG5cbiAgICAvLyBJZiBsb3NlcidzIGJyYWNrZXQgdGVhbSB3b24gdGhlIGZpcnN0IGNoYW1waW9uc2hpcCBtYXRjaCwgd2lubmVyJ3MgYnJhY2tldCB0ZWFtIGdldHMgYW5vdGhlciBjaGFuY2VcbiAgICBpZiAoXG4gICAgICBsYXN0Q2hhbXBNYXRjaC53aW5uZXI/LmlkID09PSBsb3NlcnNCcmFja2V0VGVhbT8uaWQgJiZcbiAgICAgIHRvdXJuYW1lbnQuY2hhbXBpb25zaGlwTWF0Y2hlc1BsYXllZCA9PT0gMVxuICAgICkge1xuICAgICAgaXNDaGFtcGlvbnNoaXBSb3VuZCA9IHRydWU7XG4gICAgICAvLyBDcmVhdGUgdGhlIFwicmVzZXRcIiBtYXRjaFxuICAgICAgY2hhbXBpb25zaGlwTWF0Y2hlcy5wdXNoKFxuICAgICAgICBjcmVhdGVNYXRjaChcbiAgICAgICAgICBgQyR7bmV4dFJvdW5kTnVtYmVyfS0xYCxcbiAgICAgICAgICBuZXh0Um91bmROdW1iZXIsXG4gICAgICAgICAgd2lubmVyc0JyYWNrZXRUZWFtLFxuICAgICAgICAgIGxvc2Vyc0JyYWNrZXRUZWFtLFxuICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgIFwiY2hhbXBpb25zaGlwXCJcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICAgIFxuICAgICAgLy8gQWRkIGEgcGxhY2Vob2xkZXIgbWF0Y2ggZm9yIHRoZSB3aW5uZXIncyBicmFja2V0IGNoYW1waW9uIGluIHJvdW5kIDhcbiAgICAgIGlmICghd3diQ2FyZEFkZGVkKSB7XG4gICAgICAgIG5leHRSb3VuZE1hdGNoZXMucHVzaChcbiAgICAgICAgICBjcmVhdGVNYXRjaChcbiAgICAgICAgICAgIGBXJHtuZXh0Um91bmROdW1iZXJ9LTFgLFxuICAgICAgICAgICAgbmV4dFJvdW5kTnVtYmVyLFxuICAgICAgICAgICAgd2lubmVyc0JyYWNrZXRUZWFtLFxuICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgIHRydWUsXG4gICAgICAgICAgICBcIndpbm5lcnNcIlxuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgICAgd3diQ2FyZEFkZGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRWl0aGVyIHdpbm5lcidzIGJyYWNrZXQgdGVhbSB3b24gZmlyc3QgbWF0Y2gsIG9yIHRoaXMgd2FzIHRoZSByZXNldCBtYXRjaFxuICAgICAgaXNDaGFtcGlvbnNoaXBSb3VuZCA9IHRydWU7XG4gICAgICAvLyBObyBuZXcgbWF0Y2hlcywgd2lubmVyIHdpbGwgYmUgZGV0ZXJtaW5lZCBpbiB3aW5uZXIgZGV0ZWN0aW9uIGxvZ2ljXG4gICAgfVxuICB9XG4gIC8vIENoZWNrIGlmIHdlJ3JlIHJlYWR5IGZvciB0aGUgY2hhbXBpb25zaGlwIG1hdGNoIC0gb25lIHRlYW0gaW4gZWFjaCBicmFja2V0IGFuZCBsb3NlcidzIGZpbmFsIGlzIGNvbXBsZXRlXG4gIGVsc2UgaWYgKFxuICAgIHdpbm5lcnNCcmFja2V0VGVhbXMubGVuZ3RoID09PSAxICYmXG4gICAgbG9zZXJzQnJhY2tldFRlYW1zLmxlbmd0aCA9PT0gMSAmJlxuICAgIGN1cnJlbnRSb3VuZC5tYXRjaGVzLnNvbWUoXG4gICAgICAobSkgPT5cbiAgICAgICAgKG0uYnJhY2tldCA9PT0gXCJsb3NlcnNcIiB8fCBtLmlkLmluY2x1ZGVzKFwiTG9zZXJzTGFzdFwiKSkgJiZcbiAgICAgICAgbS5pc0NvbXBsZXRlZCAmJlxuICAgICAgICBtLndpbm5lciAmJlxuICAgICAgICBsb3NlcnNCcmFja2V0VGVhbXMuc29tZSgodCkgPT4gdC5pZCA9PT0gbS53aW5uZXIhLmlkKVxuICAgIClcbiAgKSB7XG4gICAgLy8gQ2hhbXBpb25zaGlwIG1hdGNoOiBXaW5uZXIncyBicmFja2V0IGNoYW1waW9uIHZzIExvc2VyJ3MgYnJhY2tldCBjaGFtcGlvblxuICAgIGlzQ2hhbXBpb25zaGlwUm91bmQgPSB0cnVlO1xuICAgIGNoYW1waW9uc2hpcE1hdGNoZXMucHVzaChcbiAgICAgIGNyZWF0ZU1hdGNoKFxuICAgICAgICBgQyR7bmV4dFJvdW5kTnVtYmVyfS0xYCxcbiAgICAgICAgbmV4dFJvdW5kTnVtYmVyLFxuICAgICAgICB3aW5uZXJzQnJhY2tldFRlYW1zWzBdLCAvLyBXaW5uZXIncyBicmFja2V0IGNoYW1waW9uXG4gICAgICAgIGxvc2Vyc0JyYWNrZXRUZWFtc1swXSwgLy8gTG9zZXIncyBicmFja2V0IGNoYW1waW9uXG4gICAgICAgIGZhbHNlLFxuICAgICAgICBcImNoYW1waW9uc2hpcFwiXG4gICAgICApXG4gICAgKTtcbiAgICBcbiAgICAvLyBBbHNvIGFkZCBhIHBsYWNlaG9sZGVyIG1hdGNoIGZvciB0aGUgd2lubmVyJ3MgYnJhY2tldCBjaGFtcGlvblxuICAgIC8vIFRoaXMgZW5zdXJlcyB0aGUgV1dCIGNhcmQgaXMgc3RpbGwgc2hvd25cbiAgICBpZiAoIXd3YkNhcmRBZGRlZCkge1xuICAgICAgbmV4dFJvdW5kTWF0Y2hlcy5wdXNoKFxuICAgICAgICBjcmVhdGVNYXRjaChcbiAgICAgICAgICBgVyR7bmV4dFJvdW5kTnVtYmVyfS0xYCxcbiAgICAgICAgICBuZXh0Um91bmROdW1iZXIsXG4gICAgICAgICAgd2lubmVyc0JyYWNrZXRUZWFtc1swXSxcbiAgICAgICAgICBudWxsLFxuICAgICAgICAgIHRydWUsXG4gICAgICAgICAgXCJ3aW5uZXJzXCJcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICAgIHd3YkNhcmRBZGRlZCA9IHRydWU7XG4gICAgfVxuICB9XG4gIC8vIENoZWNrIGlmIHdlIGhhdmUgYSBsb3NlciBmcm9tIHdpbm5lcidzIGJyYWNrZXQgZmluYWwgd2FpdGluZyB0byBwbGF5IGFnYWluc3QgbG9zZXIncyBicmFja2V0IHdpbm5lclxuICBlbHNlIGlmIChcbiAgICB3aW5uZXJzQnJhY2tldFRlYW1zLmxlbmd0aCA9PT0gMSAmJiAvLyBXZSBoYXZlIGEgd2lubmVyJ3MgYnJhY2tldCBjaGFtcGlvblxuICAgIGxvc2Vyc0JyYWNrZXRUZWFtcy5sZW5ndGggPj0gMSAmJiAvLyBXZSBoYXZlIGF0IGxlYXN0IG9uZSB0ZWFtIGluIGxvc2VyJ3MgYnJhY2tldFxuICAgIHRvdXJuYW1lbnQud2lubmVyc0JyYWNrZXRGaW5hbExvc2VyIC8vIFdlIGhhdmUgc3RvcmVkIHRoZSB3aW5uZXIncyBicmFja2V0IGZpbmFsIGxvc2VyXG4gICkge1xuICAgIC8vIEZpbmQgdGhlIHdpbm5lciBvZiB0aGUgbG9zZXIncyBicmFja2V0XG4gICAgY29uc3QgbG9zZXJzQnJhY2tldFdpbm5lciA9IGN1cnJlbnRSb3VuZC5tYXRjaGVzXG4gICAgICAuZmlsdGVyKChtKSA9PiBtLmJyYWNrZXQgPT09IFwibG9zZXJzXCIgJiYgbS5pc0NvbXBsZXRlZCAmJiBtLndpbm5lcilcbiAgICAgIC5tYXAoKG0pID0+IG0ud2lubmVyISlcbiAgICAgIC5maW5kKCh3aW5uZXIpID0+IGxvc2Vyc0JyYWNrZXRUZWFtcy5zb21lKCh0KSA9PiB0LmlkID09PSB3aW5uZXIuaWQpKTtcblxuICAgIGlmIChcbiAgICAgIGxvc2Vyc0JyYWNrZXRXaW5uZXIgJiZcbiAgICAgIGxvc2Vyc0JyYWNrZXRXaW5uZXIuaWQgIT09IHRvdXJuYW1lbnQud2lubmVyc0JyYWNrZXRGaW5hbExvc2VyLmlkXG4gICAgKSB7XG4gICAgICAvLyBPbmx5IHNjaGVkdWxlIGlmIHRoZXkncmUgbm90IHRoZSBzYW1lIHRlYW0hXG4gICAgICBuZXh0Um91bmRNYXRjaGVzLnB1c2goXG4gICAgICAgIGNyZWF0ZU1hdGNoKFxuICAgICAgICAgIGBMb3NlcnNMYXN0LSR7bmV4dFJvdW5kTnVtYmVyfWAsXG4gICAgICAgICAgbmV4dFJvdW5kTnVtYmVyLFxuICAgICAgICAgIHRvdXJuYW1lbnQud2lubmVyc0JyYWNrZXRGaW5hbExvc2VyLFxuICAgICAgICAgIGxvc2Vyc0JyYWNrZXRXaW5uZXIsXG4gICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgXCJsb3NlcnNcIlxuICAgICAgICApXG4gICAgICApO1xuICAgICAgbHdiQ2FyZEFkZGVkID0gdHJ1ZTtcbiAgICAgIFxuICAgICAgLy8gQWRkIGEgcGxhY2Vob2xkZXIgbWF0Y2ggZm9yIHRoZSB3aW5uZXIncyBicmFja2V0IGNoYW1waW9uXG4gICAgICBpZiAoIXd3YkNhcmRBZGRlZCkge1xuICAgICAgICBuZXh0Um91bmRNYXRjaGVzLnB1c2goXG4gICAgICAgICAgY3JlYXRlTWF0Y2goXG4gICAgICAgICAgICBgVyR7bmV4dFJvdW5kTnVtYmVyfS0xYCxcbiAgICAgICAgICAgIG5leHRSb3VuZE51bWJlcixcbiAgICAgICAgICAgIHdpbm5lcnNCcmFja2V0VGVhbXNbMF0sXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgdHJ1ZSwgLy8gVGhpcyBpcyBhIGJ5ZSBtYXRjaFxuICAgICAgICAgICAgXCJ3aW5uZXJzXCJcbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICAgIHd3YkNhcmRBZGRlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFdhaXQgZm9yIHRoZSBsb3NlcnMgYnJhY2tldCB0byByZXNvbHZlIHByb3Blcmx5XG4gICAgICBjcmVhdGVTdGFuZGFyZEJyYWNrZXRNYXRjaGVzKCk7XG4gICAgICBcbiAgICAgIC8vIEV2ZW4gd2hlbiB3YWl0aW5nLCB3ZSBzaG91bGQgc3RpbGwgc2hvdyB0aGUgV1dCIGFuZCBMV0IgY2FyZHNcbiAgICAgIGlmICh3aW5uZXJzQnJhY2tldFRlYW1zLmxlbmd0aCA9PT0gMSAmJiB0b3VybmFtZW50Lndpbm5lcnNCcmFja2V0RmluYWxMb3Nlcikge1xuICAgICAgICAvLyBBZGQgYSBwbGFjZWhvbGRlciBtYXRjaCBmb3IgdGhlIHdpbm5lcidzIGJyYWNrZXQgY2hhbXBpb25cbiAgICAgICAgaWYgKCF3d2JDYXJkQWRkZWQpIHtcbiAgICAgICAgICBuZXh0Um91bmRNYXRjaGVzLnB1c2goXG4gICAgICAgICAgICBjcmVhdGVNYXRjaChcbiAgICAgICAgICAgICAgYFcke25leHRSb3VuZE51bWJlcn0tMWAsXG4gICAgICAgICAgICAgIG5leHRSb3VuZE51bWJlcixcbiAgICAgICAgICAgICAgd2lubmVyc0JyYWNrZXRUZWFtc1swXSxcbiAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAgICAgXCJ3aW5uZXJzXCJcbiAgICAgICAgICAgIClcbiAgICAgICAgICApO1xuICAgICAgICAgIHd3YkNhcmRBZGRlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIEFkZCBhIHBsYWNlaG9sZGVyIGZvciB0aGUgbG9zZXIgb2Ygd2lubmVyJ3MgYnJhY2tldCBmaW5hbFxuICAgICAgICAvLyBUaGlzIGVuc3VyZXMgdGhlIExXQiBjYXJkIGlzIHNob3duIHdoaWxlIHdhaXRpbmdcbiAgICAgICAgaWYgKCFsd2JDYXJkQWRkZWQpIHtcbiAgICAgICAgICBuZXh0Um91bmRNYXRjaGVzLnB1c2goXG4gICAgICAgICAgICBjcmVhdGVNYXRjaChcbiAgICAgICAgICAgICAgYExXQiR7bmV4dFJvdW5kTnVtYmVyfS0xYCxcbiAgICAgICAgICAgICAgbmV4dFJvdW5kTnVtYmVyLFxuICAgICAgICAgICAgICB0b3VybmFtZW50Lndpbm5lcnNCcmFja2V0RmluYWxMb3NlcixcbiAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAgICAgXCJsb3NlcnNcIlxuICAgICAgICAgICAgKVxuICAgICAgICAgICk7XG4gICAgICAgICAgbHdiQ2FyZEFkZGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICAvLyBDaGVjayBpZiB0aGlzIGlzIHRoZSB3aW5uZXIncyBicmFja2V0IGZpbmFsIChleGFjdGx5IDIgdGVhbXMgaW4gd2lubmVyJ3MgYnJhY2tldClcbiAgZWxzZSBpZiAod2lubmVyc0JyYWNrZXRUZWFtcy5sZW5ndGggPT09IDIgJiYgbG9zZXJzQnJhY2tldFRlYW1zLmxlbmd0aCA+PSAxKSB7XG4gICAgLy8gQ3JlYXRlIHRoZSB3aW5uZXIncyBicmFja2V0IGZpbmFsIG1hdGNoXG4gICAgbmV4dFJvdW5kTWF0Y2hlcy5wdXNoKFxuICAgICAgY3JlYXRlTWF0Y2goXG4gICAgICAgIGBXJHtuZXh0Um91bmROdW1iZXJ9LTFgLFxuICAgICAgICBuZXh0Um91bmROdW1iZXIsXG4gICAgICAgIHdpbm5lcnNCcmFja2V0VGVhbXNbMF0sXG4gICAgICAgIHdpbm5lcnNCcmFja2V0VGVhbXNbMV0sXG4gICAgICAgIGZhbHNlLFxuICAgICAgICBcIndpbm5lcnNcIlxuICAgICAgKVxuICAgICk7XG4gICAgd3diQ2FyZEFkZGVkID0gdHJ1ZTtcblxuICAgIC8vIENvbnRpbnVlIHdpdGggbG9zZXJzIGJyYWNrZXQgbWF0Y2hlcyBzZXBhcmF0ZWx5XG4gICAgY3JlYXRlTG9zZXJzQnJhY2tldE1hdGNoZXMoKTtcbiAgfVxuICAvLyBPdGhlcndpc2UsIGNvbnRpbnVlIHdpdGggbm9ybWFsIGJyYWNrZXQgcGxheVxuICBlbHNlIHtcbiAgICBjcmVhdGVTdGFuZGFyZEJyYWNrZXRNYXRjaGVzKCk7XG4gIH1cblxuICAvLyBIZWxwZXIgZnVuY3Rpb24gdG8gY3JlYXRlIHN0YW5kYXJkIGJyYWNrZXQgbWF0Y2hlc1xuICBmdW5jdGlvbiBjcmVhdGVTdGFuZGFyZEJyYWNrZXRNYXRjaGVzKCkge1xuICAgIC8vIC0tLSBXaW5uZXJzIEJyYWNrZXQgTWF0Y2hlcyAtLS1cbiAgICBsZXQgbWF0Y2hDb3VudGVyID0gMTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHdpbm5lcnNCcmFja2V0VGVhbXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgIGNvbnN0IHRlYW0xID0gd2lubmVyc0JyYWNrZXRUZWFtc1tpXTtcbiAgICAgIGNvbnN0IHRlYW0yID0gd2lubmVyc0JyYWNrZXRUZWFtc1tpICsgMV0gPz8gbnVsbDtcbiAgICAgIGNvbnN0IGlzQnllID0gIXRlYW0yO1xuICAgICAgbmV4dFJvdW5kTWF0Y2hlcy5wdXNoKFxuICAgICAgICBjcmVhdGVNYXRjaChcbiAgICAgICAgICBgVyR7bmV4dFJvdW5kTnVtYmVyfS0ke21hdGNoQ291bnRlcn1gLFxuICAgICAgICAgIG5leHRSb3VuZE51bWJlcixcbiAgICAgICAgICB0ZWFtMSxcbiAgICAgICAgICB0ZWFtMixcbiAgICAgICAgICBpc0J5ZSxcbiAgICAgICAgICBcIndpbm5lcnNcIlxuICAgICAgICApXG4gICAgICApO1xuICAgICAgd3diQ2FyZEFkZGVkID0gdHJ1ZTtcbiAgICAgIG1hdGNoQ291bnRlcisrO1xuICAgIH1cblxuICAgIC8vIENyZWF0ZSBsb3NlcnMgYnJhY2tldCBtYXRjaGVzIHNlcGFyYXRlbHlcbiAgICBjcmVhdGVMb3NlcnNCcmFja2V0TWF0Y2hlcygpO1xuICB9XG5cbiAgLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGNyZWF0ZSBsb3NlcnMgYnJhY2tldCBtYXRjaGVzXG4gIGZ1bmN0aW9uIGNyZWF0ZUxvc2Vyc0JyYWNrZXRNYXRjaGVzKCkge1xuICAgIC8vIC0tLSBMb3NlcnMgQnJhY2tldCBNYXRjaGVzIC0tLVxuICAgIGNvbnN0IGVsaWdpYmxlTG9zZXJzID0gYWxsVGVhbXMuZmlsdGVyKFxuICAgICAgKHRlYW0pID0+XG4gICAgICAgIChsb3NzQ291bnRzW3RlYW0uaWRdIHx8IDApID09PSAxICYmXG4gICAgICAgICF0b3VybmFtZW50LmVsaW1pbmF0ZWRUZWFtcy5zb21lKCh0KSA9PiB0LmlkID09PSB0ZWFtLmlkKSAmJlxuICAgICAgICAhbmV3bHlFbGltaW5hdGVkLnNvbWUoKHQpID0+IHQuaWQgPT09IHRlYW0uaWQpICYmXG4gICAgICAgIC8vIEV4Y2x1ZGUgd2lubmVyJ3MgYnJhY2tldCBmaW5hbCBsb3NlciBpZiBpdCBleGlzdHMgYnV0IGhhc24ndCBwbGF5ZWQgeWV0IGluIGxvc2Vyc1xuICAgICAgICAhKFxuICAgICAgICAgIHRvdXJuYW1lbnQud2lubmVyc0JyYWNrZXRGaW5hbExvc2VyICYmXG4gICAgICAgICAgdG91cm5hbWVudC53aW5uZXJzQnJhY2tldEZpbmFsTG9zZXIuaWQgPT09IHRlYW0uaWRcbiAgICAgICAgKVxuICAgICk7XG5cbiAgICAvLyBGaW5kIHRlYW1zIHJlY2VudGx5IGRyb3BwZWQgZnJvbSB3aW5uZXJzIGJyYWNrZXRcbiAgICBjb25zdCBqdXN0RHJvcHBlZEZyb21XaW5uZXJzID0gY3VycmVudFJvdW5kLm1hdGNoZXNcbiAgICAgIC5maWx0ZXIoKG0pID0+IG0uYnJhY2tldCA9PT0gXCJ3aW5uZXJzXCIgJiYgbS5sb3NlciAmJiBtLmlzQ29tcGxldGVkKVxuICAgICAgLm1hcCgobSkgPT4gbS5sb3NlciEpXG4gICAgICAuZmlsdGVyKChsb3NlcikgPT4gZWxpZ2libGVMb3NlcnMuc29tZSgodCkgPT4gdC5pZCA9PT0gbG9zZXIuaWQpKTtcblxuICAgIC8vIElmIHRoaXMgaXMgdGhlIHdpbm5lcidzIGJyYWNrZXQgZmluYWwsIHN0b3JlIHRoZSBsb3NlciBmb3IgbGF0ZXIgdXNlXG4gICAgaWYgKFxuICAgICAgY3VycmVudFJvdW5kLm1hdGNoZXMuc29tZShcbiAgICAgICAgKG0pID0+XG4gICAgICAgICAgbS5icmFja2V0ID09PSBcIndpbm5lcnNcIiAmJlxuICAgICAgICAgIHdpbm5lcnNCcmFja2V0VGVhbXMubGVuZ3RoID09PSAxICYmXG4gICAgICAgICAgbS5sb3NlciAmJlxuICAgICAgICAgIG0uaXNDb21wbGV0ZWRcbiAgICAgIClcbiAgICApIHtcbiAgICAgIC8vIFRoaXMgaXMgYSBzcGVjaWFsIGNhc2UgLSB3ZSBmb3VuZCB0aGUgd2lubmVyJ3MgYnJhY2tldCBmaW5hbCBsb3NlclxuICAgICAgY29uc3Qgd2lubmVyc0ZpbmFsTG9zZXIgPSBjdXJyZW50Um91bmQubWF0Y2hlc1xuICAgICAgICAuZmlsdGVyKChtKSA9PiBtLmJyYWNrZXQgPT09IFwid2lubmVyc1wiICYmIG0uaXNDb21wbGV0ZWQgJiYgbS5sb3NlcilcbiAgICAgICAgLm1hcCgobSkgPT4gbS5sb3NlciEpXG4gICAgICAgIC5wb3AoKTtcblxuICAgICAgaWYgKHdpbm5lcnNGaW5hbExvc2VyKSB7XG4gICAgICAgIHRvdXJuYW1lbnQud2lubmVyc0JyYWNrZXRGaW5hbExvc2VyID0gd2lubmVyc0ZpbmFsTG9zZXI7XG4gICAgICAgIFxuICAgICAgICAvLyBBbHdheXMgYWRkIGEgcGxhY2Vob2xkZXIgZm9yIHRoZSBsb3NlciBvZiB3aW5uZXIncyBicmFja2V0IGZpbmFsIGluIHJvdW5kIDdcbiAgICAgICAgLy8gVGhpcyBlbnN1cmVzIHRoZSBMV0IgY2FyZCBpcyBzaG93blxuICAgICAgICBpZiAobmV4dFJvdW5kTnVtYmVyID09PSA3ICYmICFsd2JDYXJkQWRkZWQpIHtcbiAgICAgICAgICBuZXh0Um91bmRNYXRjaGVzLnB1c2goXG4gICAgICAgICAgICBjcmVhdGVNYXRjaChcbiAgICAgICAgICAgICAgYExXQiR7bmV4dFJvdW5kTnVtYmVyfS0xYCxcbiAgICAgICAgICAgICAgbmV4dFJvdW5kTnVtYmVyLFxuICAgICAgICAgICAgICB3aW5uZXJzRmluYWxMb3NlcixcbiAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAgICAgXCJsb3NlcnNcIlxuICAgICAgICAgICAgKVxuICAgICAgICAgICk7XG4gICAgICAgICAgbHdiQ2FyZEFkZGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEV4aXN0aW5nIGxvc2VycyBicmFja2V0IHRlYW1zXG4gICAgY29uc3QgZXhpc3RpbmdMb3NlcnMgPSBlbGlnaWJsZUxvc2Vycy5maWx0ZXIoXG4gICAgICAodCkgPT4gIWp1c3REcm9wcGVkRnJvbVdpbm5lcnMuc29tZSgoamQpID0+IGpkLmlkID09PSB0LmlkKVxuICAgICk7XG5cbiAgICAvLyBPcmRlcjogbW9zdCByZWNlbnQgZHJvcChzKSBmaXJzdFxuICAgIGNvbnN0IG9yZGVyZWRMb3NlcnMgPSBbLi4uanVzdERyb3BwZWRGcm9tV2lubmVycywgLi4uZXhpc3RpbmdMb3NlcnNdO1xuXG4gICAgaWYgKG9yZGVyZWRMb3NlcnMubGVuZ3RoID4gMCkge1xuICAgICAgaWYgKG9yZGVyZWRMb3NlcnMubGVuZ3RoICUgMiA9PT0gMSkge1xuICAgICAgICAvLyBPZGQ6IGJ5ZSBnb2VzIHRvIHRoZSBtb3N0IHJlY2VudCB0ZWFtIGRyb3BwZWQgZnJvbSB3aW5uZXJzIGJyYWNrZXRcbiAgICAgICAgbGV0IHRlYW1XaXRoQnllOiBUZWFtIHwgbnVsbCA9IG51bGw7XG4gICAgICAgIGlmIChqdXN0RHJvcHBlZEZyb21XaW5uZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICB0ZWFtV2l0aEJ5ZSA9XG4gICAgICAgICAgICBqdXN0RHJvcHBlZEZyb21XaW5uZXJzW2p1c3REcm9wcGVkRnJvbVdpbm5lcnMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgLy8gUmVtb3ZlIHRoZSBieWUgdGVhbSBmcm9tIG9yZGVyZWRMb3NlcnNcbiAgICAgICAgICBjb25zdCBieWVJbmRleCA9IG9yZGVyZWRMb3NlcnMuZmluZEluZGV4KFxuICAgICAgICAgICAgKHQpID0+IHQuaWQgPT09IHRlYW1XaXRoQnllIS5pZFxuICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKGJ5ZUluZGV4ICE9PSAtMSkgb3JkZXJlZExvc2Vycy5zcGxpY2UoYnllSW5kZXgsIDEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIERlZmVuc2l2ZTogZmFsbGJhY2sgdG8gZmlyc3QgdGVhbSBpZiBubyByZWNlbnQgZHJvcFxuICAgICAgICAgIHRlYW1XaXRoQnllID0gb3JkZXJlZExvc2Vycy5zaGlmdCgpITtcbiAgICAgICAgfVxuICAgICAgICBuZXh0Um91bmRNYXRjaGVzLnB1c2goXG4gICAgICAgICAgY3JlYXRlTWF0Y2goXG4gICAgICAgICAgICBgTCR7bmV4dFJvdW5kTnVtYmVyfS0xYCxcbiAgICAgICAgICAgIG5leHRSb3VuZE51bWJlcixcbiAgICAgICAgICAgIHRlYW1XaXRoQnllLFxuICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgIHRydWUsXG4gICAgICAgICAgICBcImxvc2Vyc1wiXG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgICAvLyBQYWlyIHRoZSByZXN0XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3JkZXJlZExvc2Vycy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgIGNvbnN0IHRlYW0xID0gb3JkZXJlZExvc2Vyc1tpXTtcbiAgICAgICAgICBjb25zdCB0ZWFtMiA9IG9yZGVyZWRMb3NlcnNbaSArIDFdID8/IG51bGw7XG4gICAgICAgICAgbmV4dFJvdW5kTWF0Y2hlcy5wdXNoKFxuICAgICAgICAgICAgY3JlYXRlTWF0Y2goXG4gICAgICAgICAgICAgIGBMJHtuZXh0Um91bmROdW1iZXJ9LSR7TWF0aC5mbG9vcihpIC8gMikgKyAyfWAsXG4gICAgICAgICAgICAgIG5leHRSb3VuZE51bWJlcixcbiAgICAgICAgICAgICAgdGVhbTEsXG4gICAgICAgICAgICAgIHRlYW0yLFxuICAgICAgICAgICAgICAhdGVhbTIsXG4gICAgICAgICAgICAgIFwibG9zZXJzXCJcbiAgICAgICAgICAgIClcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBFdmVuIG51bWJlcjogcGFpciBhbGxcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvcmRlcmVkTG9zZXJzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgY29uc3QgdGVhbTEgPSBvcmRlcmVkTG9zZXJzW2ldO1xuICAgICAgICAgIGNvbnN0IHRlYW0yID0gb3JkZXJlZExvc2Vyc1tpICsgMV0gPz8gbnVsbDtcbiAgICAgICAgICBuZXh0Um91bmRNYXRjaGVzLnB1c2goXG4gICAgICAgICAgICBjcmVhdGVNYXRjaChcbiAgICAgICAgICAgICAgYEwke25leHRSb3VuZE51bWJlcn0tJHtNYXRoLmZsb29yKGkgLyAyKSArIDF9YCxcbiAgICAgICAgICAgICAgbmV4dFJvdW5kTnVtYmVyLFxuICAgICAgICAgICAgICB0ZWFtMSxcbiAgICAgICAgICAgICAgdGVhbTIsXG4gICAgICAgICAgICAgICF0ZWFtMixcbiAgICAgICAgICAgICAgXCJsb3NlcnNcIlxuICAgICAgICAgICAgKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLy8gSWYgd2UncmUgaW4gcm91bmQgNyBhbmQgdGhlcmUncyBhIHdpbm5lcidzIGJyYWNrZXQgZmluYWwgbG9zZXIgYnV0IG5vIExXQiBjYXJkIHlldFxuICAgIGlmIChuZXh0Um91bmROdW1iZXIgPT09IDcgJiYgdG91cm5hbWVudC53aW5uZXJzQnJhY2tldEZpbmFsTG9zZXIgJiYgIWx3YkNhcmRBZGRlZCkge1xuICAgICAgbmV4dFJvdW5kTWF0Y2hlcy5wdXNoKFxuICAgICAgICBjcmVhdGVNYXRjaChcbiAgICAgICAgICBgTFdCJHtuZXh0Um91bmROdW1iZXJ9LTFgLFxuICAgICAgICAgIG5leHRSb3VuZE51bWJlcixcbiAgICAgICAgICB0b3VybmFtZW50Lndpbm5lcnNCcmFja2V0RmluYWxMb3NlcixcbiAgICAgICAgICBudWxsLFxuICAgICAgICAgIHRydWUsXG4gICAgICAgICAgXCJsb3NlcnNcIlxuICAgICAgICApXG4gICAgICApO1xuICAgICAgbHdiQ2FyZEFkZGVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICAvLyAtLS0gV2lubmVyIGRldGVjdGlvbiBsb2dpYyAtLS1cbiAgbGV0IHdpbm5lcjogVGVhbSB8IHVuZGVmaW5lZCA9IHRvdXJuYW1lbnQud2lubmVyO1xuXG4gIGlmIChpc0NoYW1waW9uc2hpcFJvdW5kKSB7XG4gICAgLy8gRmluZCB0aGUgbGFzdCBjaGFtcGlvbnNoaXAgbWF0Y2ggcGxheWVkXG4gICAgY29uc3QgbGFzdENoYW1wTWF0Y2ggPVxuICAgICAgY2hhbXBpb25zaGlwTWF0Y2hlc1swXSB8fFxuICAgICAgcHJldkNoYW1waW9uc2hpcE1hdGNoZXNbcHJldkNoYW1waW9uc2hpcE1hdGNoZXMubGVuZ3RoIC0gMV07XG5cbiAgICBpZiAoXG4gICAgICBsYXN0Q2hhbXBNYXRjaCAmJlxuICAgICAgbGFzdENoYW1wTWF0Y2guaXNDb21wbGV0ZWQgJiZcbiAgICAgIGxhc3RDaGFtcE1hdGNoLndpbm5lciAmJlxuICAgICAgbGFzdENoYW1wTWF0Y2gubG9zZXJcbiAgICApIHtcbiAgICAgIGNvbnN0IHdpbm5lcnNCcmFja2V0VGVhbSA9IGxhc3RDaGFtcE1hdGNoLnRlYW0xO1xuICAgICAgY29uc3QgbG9zZXJzQnJhY2tldFRlYW0gPSBsYXN0Q2hhbXBNYXRjaC50ZWFtMjtcbiAgICAgIGNvbnN0IGxvc2Vyc0JyYWNrZXRUZWFtV29uID1cbiAgICAgICAgbG9zZXJzQnJhY2tldFRlYW0gJiYgbGFzdENoYW1wTWF0Y2gud2lubmVyLmlkID09PSBsb3NlcnNCcmFja2V0VGVhbS5pZDtcblxuICAgICAgLy8gSWYgbG9zZXIncyBicmFja2V0IHRlYW0gd29uIGZpcnN0IGNoYW1waW9uc2hpcCBtYXRjaCwgd2lubmVyJ3MgYnJhY2tldCB0ZWFtIGdldHMgYW5vdGhlciBjaGFuY2VcbiAgICAgIGlmIChsb3NlcnNCcmFja2V0VGVhbVdvbiAmJiB0b3VybmFtZW50LmNoYW1waW9uc2hpcE1hdGNoZXNQbGF5ZWQgPT09IDEpIHtcbiAgICAgICAgd2lubmVyID0gdW5kZWZpbmVkOyAvLyBObyB3aW5uZXIgeWV0LCBuZWVkIHJlc2V0IG1hdGNoXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBFaXRoZXIgd2lubmVyJ3MgYnJhY2tldCB0ZWFtIHdvbiBmaXJzdCBtYXRjaCwgb3IgdGhpcyB3YXMgdGhlIHJlc2V0IG1hdGNoXG4gICAgICAgIHdpbm5lciA9IGxhc3RDaGFtcE1hdGNoLndpbm5lcjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyAtLS0gSU5GSU5JVEUgUkVDVVJTSU9OIEdVQVJEIC0tLVxuICBjb25zdCBub01vcmVNYXRjaGVzID1cbiAgICAoaXNDaGFtcGlvbnNoaXBSb3VuZCAmJiBjaGFtcGlvbnNoaXBNYXRjaGVzLmxlbmd0aCA9PT0gMCkgfHxcbiAgICAoIWlzQ2hhbXBpb25zaGlwUm91bmQgJiYgbmV4dFJvdW5kTWF0Y2hlcy5sZW5ndGggPT09IDApO1xuXG4gIGlmIChub01vcmVNYXRjaGVzKSB7XG4gICAgLy8gVG91cm5hbWVudCBpcyBvdmVyLCBkbyBub3QgYWR2YW5jZSBmdXJ0aGVyXG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnRvdXJuYW1lbnQsXG4gICAgICB3aW5uZXIsXG4gICAgICBjdXJyZW50Um91bmQ6IHRvdXJuYW1lbnQuY3VycmVudFJvdW5kXG4gICAgfTtcbiAgfVxuXG4gIC8vIEVuc3VyZSBMV0IgY2FyZCBpcyBhZGRlZCBmb3Igcm91bmQgNyBpZiBpdCBoYXNuJ3QgYmVlbiBhZGRlZCB5ZXRcbiAgaWYgKG5leHRSb3VuZE51bWJlciA9PT0gNyAmJiB0b3VybmFtZW50Lndpbm5lcnNCcmFja2V0RmluYWxMb3NlciAmJiAhbHdiQ2FyZEFkZGVkKSB7XG4gICAgbmV4dFJvdW5kTWF0Y2hlcy5wdXNoKFxuICAgICAgY3JlYXRlTWF0Y2goXG4gICAgICAgIGBMV0Ike25leHRSb3VuZE51bWJlcn0tMWAsXG4gICAgICAgIG5leHRSb3VuZE51bWJlcixcbiAgICAgICAgdG91cm5hbWVudC53aW5uZXJzQnJhY2tldEZpbmFsTG9zZXIsXG4gICAgICAgIG51bGwsXG4gICAgICAgIHRydWUsXG4gICAgICAgIFwibG9zZXJzXCJcbiAgICAgIClcbiAgICApO1xuICB9XG5cbiAgLy8gQ29tcG9zZSB0aGUgbmV3IHRvdXJuYW1lbnQgb2JqZWN0XG4gIHJldHVybiB7XG4gICAgLi4udG91cm5hbWVudCxcbiAgICByb3VuZHM6IFtcbiAgICAgIC4uLnRvdXJuYW1lbnQucm91bmRzLFxuICAgICAge1xuICAgICAgICByb3VuZE51bWJlcjogbmV4dFJvdW5kTnVtYmVyLFxuICAgICAgICBtYXRjaGVzOiBpc0NoYW1waW9uc2hpcFJvdW5kID8gY2hhbXBpb25zaGlwTWF0Y2hlcyA6IG5leHRSb3VuZE1hdGNoZXMsXG4gICAgICAgIGlzRG91YmxlRWxpbWluYXRpb246IHRydWUsXG4gICAgICAgIGlzQ2hhbXBpb25zaGlwUm91bmRcbiAgICAgIH1cbiAgICBdLFxuICAgIGN1cnJlbnRSb3VuZDogbmV4dFJvdW5kTnVtYmVyLFxuICAgIGVsaW1pbmF0ZWRUZWFtczogW1xuICAgICAgLi4udG91cm5hbWVudC5lbGltaW5hdGVkVGVhbXMsXG4gICAgICAuLi5uZXdseUVsaW1pbmF0ZWQuZmlsdGVyKFxuICAgICAgICAodCkgPT4gIXRvdXJuYW1lbnQuZWxpbWluYXRlZFRlYW1zLnNvbWUoKGV0KSA9PiBldC5pZCA9PT0gdC5pZClcbiAgICAgIClcbiAgICBdLFxuICAgIGNoYW1waW9uc2hpcE1hdGNoZXNQbGF5ZWQ6IGlzQ2hhbXBpb25zaGlwUm91bmRcbiAgICAgID8gdG91cm5hbWVudC5jaGFtcGlvbnNoaXBNYXRjaGVzUGxheWVkICsgMVxuICAgICAgOiB0b3VybmFtZW50LmNoYW1waW9uc2hpcE1hdGNoZXNQbGF5ZWQsXG4gICAgd2lubmVyc0JyYWNrZXRGaW5hbExvc2VyOiB0b3VybmFtZW50Lndpbm5lcnNCcmFja2V0RmluYWxMb3NlcixcbiAgICB3aW5uZXJcbiAgfTtcbn07Il0sIm5hbWVzIjpbImNyZWF0ZU1hdGNoIiwiaWQiLCJyb3VuZE51bWJlciIsInRlYW0xIiwidGVhbTIiLCJpc0J5ZSIsImJyYWNrZXQiLCJuZXh0TWF0Y2hJZCIsIm5leHRMb3Nlck1hdGNoSWQiLCJpc0NvbXBsZXRlZCIsIndpbm5lciIsInVuZGVmaW5lZCIsImxvc2VyIiwic2NvcmUiLCJ0ZWFtMVNjb3JlIiwidGVhbTJTY29yZSIsImVsaW1pbmF0ZWRMYWJlbCIsImNyZWF0ZUluaXRpYWxSb3VuZHMiLCJ0ZWFtcyIsIm51bVRlYW1zIiwibGVuZ3RoIiwibWF0Y2hlcyIsIm51bVJvdW5kcyIsIk1hdGgiLCJjZWlsIiwibG9nMiIsImZpcnN0Um91bmRNYXRjaGVzIiwicG93IiwibWF0Y2hDb3VudGVyIiwiaSIsIm1hdGNoSWQiLCJwdXNoIiwicm91bmRzIiwiaXNEb3VibGVFbGltaW5hdGlvbiIsImlzQ2hhbXBpb25zaGlwUm91bmQiLCJjdXJyZW50Um91bmQiLCJlbGltaW5hdGVkVGVhbXMiLCJjaGFtcGlvbnNoaXBNYXRjaGVzUGxheWVkIiwidXBkYXRlTWF0Y2hTY29yZSIsIm1hdGNoIiwibmV3U2NvcmUiLCJ3aW5zIiwibG9zc2VzIiwiZGVkdXBlVGVhbXMiLCJzZWVuIiwiU2V0IiwiZmlsdGVyIiwidGVhbSIsImhhcyIsImFkZCIsInRlYW1zV2l0aExvc3NlcyIsImxvc3NDb3VudHMiLCJuIiwiT2JqZWN0Iiwia2V5cyIsInRlYW1JZCIsImFkdmFuY2VUb05leHRSb3VuZCIsInRvdXJuYW1lbnQiLCJuZXh0Um91bmROdW1iZXIiLCJ3aW5zQ291bnRzIiwiZm9yRWFjaCIsInJvdW5kIiwiYWxsVGVhbXMiLCJ0ZWFtSWRzIiwibmV3bHlFbGltaW5hdGVkIiwic29tZSIsInQiLCJ3aW5uZXJzQnJhY2tldFRlYW1zIiwibWFwIiwibG9zZXJzQnJhY2tldFRlYW1zIiwiY2hhbXBpb25zaGlwTWF0Y2hlcyIsIm5leHRSb3VuZE1hdGNoZXMiLCJ3d2JDYXJkQWRkZWQiLCJsd2JDYXJkQWRkZWQiLCJwcmV2Q2hhbXBpb25zaGlwTWF0Y2hlcyIsInIiLCJmbGF0TWFwIiwibSIsImxhc3RDaGFtcE1hdGNoIiwid2lubmVyc0JyYWNrZXRUZWFtIiwibG9zZXJzQnJhY2tldFRlYW0iLCJpbmNsdWRlcyIsIndpbm5lcnNCcmFja2V0RmluYWxMb3NlciIsImxvc2Vyc0JyYWNrZXRXaW5uZXIiLCJmaW5kIiwiY3JlYXRlU3RhbmRhcmRCcmFja2V0TWF0Y2hlcyIsImNyZWF0ZUxvc2Vyc0JyYWNrZXRNYXRjaGVzIiwiZWxpZ2libGVMb3NlcnMiLCJqdXN0RHJvcHBlZEZyb21XaW5uZXJzIiwid2lubmVyc0ZpbmFsTG9zZXIiLCJwb3AiLCJleGlzdGluZ0xvc2VycyIsImpkIiwib3JkZXJlZExvc2VycyIsInRlYW1XaXRoQnllIiwiYnllSW5kZXgiLCJmaW5kSW5kZXgiLCJzcGxpY2UiLCJzaGlmdCIsImZsb29yIiwibG9zZXJzQnJhY2tldFRlYW1Xb24iLCJub01vcmVNYXRjaGVzIiwiZXQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./types/tournament/matches.ts\n"));

/***/ })

});
"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/tournament/page",{

/***/ "(app-pages-browser)/./types/tournament/matches.ts":
/*!*************************************!*\
  !*** ./types/tournament/matches.ts ***!
  \*************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   advanceToNextRound: function() { return /* binding */ advanceToNextRound; },\n/* harmony export */   createInitialRounds: function() { return /* binding */ createInitialRounds; },\n/* harmony export */   createMatch: function() { return /* binding */ createMatch; },\n/* harmony export */   updateMatchScore: function() { return /* binding */ updateMatchScore; }\n/* harmony export */ });\nconst createMatch = function(id, roundNumber, team1, team2) {\n    let isBye = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : false, bracket = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : \"winners\", nextMatchId = arguments.length > 6 ? arguments[6] : void 0, nextLoserMatchId = arguments.length > 7 ? arguments[7] : void 0;\n    var _ref;\n    return {\n        id,\n        roundNumber,\n        team1,\n        team2,\n        isCompleted: isBye,\n        isBye,\n        bracket,\n        winner: isBye ? (_ref = team1 !== null && team1 !== void 0 ? team1 : team2) !== null && _ref !== void 0 ? _ref : undefined : undefined,\n        loser: isBye ? undefined : undefined,\n        score: {\n            team1Score: 0,\n            team2Score: 0\n        },\n        nextMatchId,\n        nextLoserMatchId,\n        eliminatedLabel: undefined\n    };\n};\nconst createInitialRounds = (teams)=>{\n    const numTeams = teams.length;\n    const matches = [];\n    const numRounds = Math.ceil(Math.log2(numTeams));\n    const firstRoundMatches = Math.pow(2, numRounds - 1);\n    let matchCounter = 1;\n    for(let i = 0; i < firstRoundMatches; i++){\n        const team1 = teams[i * 2] || null;\n        const team2 = teams[i * 2 + 1] || null;\n        const isBye = !team1 || !team2;\n        const matchId = \"W1-\".concat(matchCounter);\n        const nextMatchId = \"W2-\".concat(Math.ceil(matchCounter / 2));\n        const nextLoserMatchId = \"L1-\".concat(Math.ceil(matchCounter / 2));\n        matches.push(createMatch(matchId, 1, team1, team2, isBye, \"winners\", nextMatchId, nextLoserMatchId));\n        matchCounter++;\n    }\n    return {\n        rounds: [\n            {\n                roundNumber: 1,\n                matches,\n                isDoubleElimination: true,\n                isChampionshipRound: false\n            }\n        ],\n        currentRound: 1,\n        eliminatedTeams: [],\n        championshipMatchesPlayed: 0\n    };\n};\nconst updateMatchScore = (match, newScore)=>{\n    const isCompleted = newScore.team1Score !== newScore.team2Score;\n    let winner = undefined;\n    let loser = undefined;\n    if (isCompleted) {\n        if (newScore.team1Score > newScore.team2Score) {\n            var _match_team1_wins, _match_team1_losses;\n            winner = match.team1 ? {\n                ...match.team1,\n                wins: ((_match_team1_wins = match.team1.wins) !== null && _match_team1_wins !== void 0 ? _match_team1_wins : 0) + 1,\n                losses: (_match_team1_losses = match.team1.losses) !== null && _match_team1_losses !== void 0 ? _match_team1_losses : 0\n            } : undefined;\n            var _match_team2_wins, _match_team2_losses;\n            loser = match.team2 ? {\n                ...match.team2,\n                wins: (_match_team2_wins = match.team2.wins) !== null && _match_team2_wins !== void 0 ? _match_team2_wins : 0,\n                losses: ((_match_team2_losses = match.team2.losses) !== null && _match_team2_losses !== void 0 ? _match_team2_losses : 0) + 1\n            } : undefined;\n        } else {\n            var _match_team2_wins1, _match_team2_losses1;\n            winner = match.team2 ? {\n                ...match.team2,\n                wins: ((_match_team2_wins1 = match.team2.wins) !== null && _match_team2_wins1 !== void 0 ? _match_team2_wins1 : 0) + 1,\n                losses: (_match_team2_losses1 = match.team2.losses) !== null && _match_team2_losses1 !== void 0 ? _match_team2_losses1 : 0\n            } : undefined;\n            var _match_team1_wins1, _match_team1_losses1;\n            loser = match.team1 ? {\n                ...match.team1,\n                wins: (_match_team1_wins1 = match.team1.wins) !== null && _match_team1_wins1 !== void 0 ? _match_team1_wins1 : 0,\n                losses: ((_match_team1_losses1 = match.team1.losses) !== null && _match_team1_losses1 !== void 0 ? _match_team1_losses1 : 0) + 1\n            } : undefined;\n        }\n    }\n    return {\n        ...match,\n        score: newScore,\n        isCompleted,\n        winner,\n        loser\n    };\n};\n// Helper to deduplicate teams by ID\nfunction dedupeTeams(teams) {\n    const seen = new Set();\n    return teams.filter((team)=>{\n        if (!team) return false;\n        if (seen.has(team.id)) return false;\n        seen.add(team.id);\n        return true;\n    });\n}\n// Helper: get all teams with exactly N losses\nfunction teamsWithLosses(lossCounts, n) {\n    return Object.keys(lossCounts).filter((teamId)=>lossCounts[teamId] === n);\n}\nconst advanceToNextRound = (tournament)=>{\n    const currentRound = tournament.rounds[tournament.rounds.length - 1];\n    const nextRoundNumber = tournament.currentRound + 1;\n    // Track all losses and wins across the tournament\n    const lossCounts = {};\n    const winsCounts = {};\n    tournament.rounds.forEach((round)=>{\n        round.matches.forEach((match)=>{\n            if (match.isCompleted && match.loser) {\n                lossCounts[match.loser.id] = (lossCounts[match.loser.id] || 0) + 1;\n            }\n            if (match.isCompleted && match.winner) {\n                winsCounts[match.winner.id] = (winsCounts[match.winner.id] || 0) + 1;\n            }\n        });\n    });\n    // Gather all teams ever in the tournament, attaching wins\n    const allTeams = [];\n    const teamIds = new Set();\n    for (const round of tournament.rounds){\n        for (const match of round.matches){\n            if (match.team1 && !teamIds.has(match.team1.id)) {\n                allTeams.push({\n                    ...match.team1,\n                    wins: winsCounts[match.team1.id] || 0,\n                    losses: lossCounts[match.team1.id] || 0\n                });\n                teamIds.add(match.team1.id);\n            }\n            if (match.team2 && !teamIds.has(match.team2.id)) {\n                allTeams.push({\n                    ...match.team2,\n                    wins: winsCounts[match.team2.id] || 0,\n                    losses: lossCounts[match.team2.id] || 0\n                });\n                teamIds.add(match.team2.id);\n            }\n        }\n    }\n    // Identify newly eliminated teams (2 losses)\n    const newlyEliminated = [];\n    for (const team of allTeams){\n        if ((lossCounts[team.id] || 0) >= 2 && !tournament.eliminatedTeams.some((t)=>t.id === team.id)) {\n            newlyEliminated.push(team);\n        }\n    }\n    // Winners: teams with 0 losses and not eliminated\n    const winnersBracketTeams = allTeams.filter((team)=>(lossCounts[team.id] || 0) === 0 && !tournament.eliminatedTeams.some((t)=>t.id === team.id) && !newlyEliminated.some((t)=>t.id === team.id)).map((team)=>({\n            ...team,\n            losses: lossCounts[team.id] || 0,\n            wins: winsCounts[team.id] || 0\n        }));\n    // Losers: teams with 1 loss and not eliminated\n    const losersBracketTeams = allTeams.filter((team)=>(lossCounts[team.id] || 0) === 1 && !tournament.eliminatedTeams.some((t)=>t.id === team.id) && !newlyEliminated.some((t)=>t.id === team.id)).map((team)=>({\n            ...team,\n            losses: lossCounts[team.id] || 0,\n            wins: winsCounts[team.id] || 0\n        }));\n    let isChampionshipRound = false;\n    let championshipMatches = [];\n    let nextRoundMatches = [];\n    const prevChampionshipMatches = tournament.rounds.filter((r)=>r.isChampionshipRound).flatMap((r)=>r.matches).filter((m)=>m.bracket === \"championship\");\n    // --- CHAMPIONSHIP LOGIC ---\n    // Check if a championship match already happened and was completed\n    if (prevChampionshipMatches.length >= 1 && prevChampionshipMatches[prevChampionshipMatches.length - 1].isCompleted) {\n        var _lastChampMatch_winner;\n        const lastChampMatch = prevChampionshipMatches[prevChampionshipMatches.length - 1];\n        const winnersBracketTeam = lastChampMatch.team1;\n        const losersBracketTeam = lastChampMatch.team2;\n        // If loser's bracket team won the first championship match, winner's bracket team gets another chance\n        if (((_lastChampMatch_winner = lastChampMatch.winner) === null || _lastChampMatch_winner === void 0 ? void 0 : _lastChampMatch_winner.id) === (losersBracketTeam === null || losersBracketTeam === void 0 ? void 0 : losersBracketTeam.id) && tournament.championshipMatchesPlayed === 1) {\n            isChampionshipRound = true;\n            // Create the \"reset\" match\n            championshipMatches.push(createMatch(\"C\".concat(nextRoundNumber, \"-1\"), nextRoundNumber, winnersBracketTeam, losersBracketTeam, false, \"championship\"));\n        } else {\n            // Either winner's bracket team won first match, or this was the reset match\n            isChampionshipRound = true;\n        // No new matches, winner will be determined in winner detection logic\n        }\n    } else if (winnersBracketTeams.length === 1 && losersBracketTeams.length === 1 && currentRound.matches.some((m)=>(m.bracket === \"losers\" || m.id.includes(\"LosersLast\")) && m.isCompleted && m.winner && losersBracketTeams.some((t)=>t.id === m.winner.id))) {\n        // Championship match: Winner's bracket champion vs Loser's bracket champion\n        isChampionshipRound = true;\n        championshipMatches.push(createMatch(\"C\".concat(nextRoundNumber, \"-1\"), nextRoundNumber, winnersBracketTeams[0], losersBracketTeams[0], false, \"championship\"));\n    } else if (winnersBracketTeams.length === 1 && // We have a winner's bracket champion\n    losersBracketTeams.length >= 1 && // We have at least one team in loser's bracket\n    tournament.winnersBracketFinalLoser // We have stored the winner's bracket final loser\n    ) {\n        // Find the winner of the loser's bracket\n        const losersBracketWinner = currentRound.matches.filter((m)=>m.bracket === \"losers\" && m.isCompleted && m.winner).map((m)=>m.winner).find((winner)=>losersBracketTeams.some((t)=>t.id === winner.id));\n        if (losersBracketWinner && losersBracketWinner.id !== tournament.winnersBracketFinalLoser.id) {\n            // Only schedule if they're not the same team!\n            nextRoundMatches.push(createMatch(\"LosersLast-\".concat(nextRoundNumber), nextRoundNumber, tournament.winnersBracketFinalLoser, losersBracketWinner, false, \"losers\"));\n        } else {\n            // Wait for the losers bracket to resolve properly\n            createStandardBracketMatches();\n        }\n    } else if (winnersBracketTeams.length === 2 && losersBracketTeams.length >= 1) {\n        // Create the winner's bracket final match\n        nextRoundMatches.push(createMatch(\"W\".concat(nextRoundNumber, \"-1\"), nextRoundNumber, winnersBracketTeams[0], winnersBracketTeams[1], false, \"winners\"));\n        // Continue with losers bracket matches separately\n        createLosersBracketMatches();\n    } else {\n        createStandardBracketMatches();\n    }\n    // Helper function to create standard bracket matches\n    function createStandardBracketMatches() {\n        // --- Winners Bracket Matches ---\n        let matchCounter = 1;\n        for(let i = 0; i < winnersBracketTeams.length; i += 2){\n            const team1 = winnersBracketTeams[i];\n            var _winnersBracketTeams_;\n            const team2 = (_winnersBracketTeams_ = winnersBracketTeams[i + 1]) !== null && _winnersBracketTeams_ !== void 0 ? _winnersBracketTeams_ : null;\n            const isBye = !team2;\n            nextRoundMatches.push(createMatch(\"W\".concat(nextRoundNumber, \"-\").concat(matchCounter), nextRoundNumber, team1, team2, isBye, \"winners\"));\n            matchCounter++;\n        }\n        // Create losers bracket matches separately\n        createLosersBracketMatches();\n    }\n    // Helper function to create losers bracket matches\n    function createLosersBracketMatches() {\n        // --- Losers Bracket Matches ---\n        const eligibleLosers = allTeams.filter((team)=>(lossCounts[team.id] || 0) === 1 && !tournament.eliminatedTeams.some((t)=>t.id === team.id) && !newlyEliminated.some((t)=>t.id === team.id) && // Exclude winner's bracket final loser if it exists but hasn't played yet in losers\n            !(tournament.winnersBracketFinalLoser && tournament.winnersBracketFinalLoser.id === team.id));\n        // Find teams recently dropped from winners bracket\n        const justDroppedFromWinners = currentRound.matches.filter((m)=>m.bracket === \"winners\" && m.loser && m.isCompleted).map((m)=>m.loser).filter((loser)=>eligibleLosers.some((t)=>t.id === loser.id));\n        // If this is the winner's bracket final, store the loser for later use\n        if (currentRound.matches.some((m)=>m.bracket === \"winners\" && winnersBracketTeams.length === 1 && m.loser && m.isCompleted)) {\n            // This is a special case - we found the winner's bracket final loser\n            const winnersFinalLoser = currentRound.matches.filter((m)=>m.bracket === \"winners\" && m.isCompleted && m.loser).map((m)=>m.loser).pop();\n            if (winnersFinalLoser) {\n                tournament.winnersBracketFinalLoser = winnersFinalLoser;\n            }\n        }\n        // Existing losers bracket teams\n        const existingLosers = eligibleLosers.filter((t)=>!justDroppedFromWinners.some((jd)=>jd.id === t.id));\n        // Order: most recent drop(s) first\n        const orderedLosers = [\n            ...justDroppedFromWinners,\n            ...existingLosers\n        ];\n        if (orderedLosers.length > 0) {\n            if (orderedLosers.length % 2 === 1) {\n                // Odd: bye goes to the most recent team dropped from winners bracket\n                let teamWithBye = null;\n                if (justDroppedFromWinners.length > 0) {\n                    teamWithBye = justDroppedFromWinners[justDroppedFromWinners.length - 1];\n                    // Remove the bye team from orderedLosers\n                    const byeIndex = orderedLosers.findIndex((t)=>t.id === teamWithBye.id);\n                    if (byeIndex !== -1) orderedLosers.splice(byeIndex, 1);\n                } else {\n                    // Defensive: fallback to first team if no recent drop\n                    teamWithBye = orderedLosers.shift();\n                }\n                nextRoundMatches.push(createMatch(\"L\".concat(nextRoundNumber, \"-1\"), nextRoundNumber, teamWithBye, null, true, \"losers\"));\n                // Pair the rest\n                for(let i = 0; i < orderedLosers.length; i += 2){\n                    const team1 = orderedLosers[i];\n                    var _orderedLosers_;\n                    const team2 = (_orderedLosers_ = orderedLosers[i + 1]) !== null && _orderedLosers_ !== void 0 ? _orderedLosers_ : null;\n                    nextRoundMatches.push(createMatch(\"L\".concat(nextRoundNumber, \"-\").concat(Math.floor(i / 2) + 2), nextRoundNumber, team1, team2, !team2, \"losers\"));\n                }\n            } else {\n                // Even number: pair all\n                for(let i = 0; i < orderedLosers.length; i += 2){\n                    const team1 = orderedLosers[i];\n                    var _orderedLosers_1;\n                    const team2 = (_orderedLosers_1 = orderedLosers[i + 1]) !== null && _orderedLosers_1 !== void 0 ? _orderedLosers_1 : null;\n                    nextRoundMatches.push(createMatch(\"L\".concat(nextRoundNumber, \"-\").concat(Math.floor(i / 2) + 1), nextRoundNumber, team1, team2, !team2, \"losers\"));\n                }\n            }\n        }\n    }\n    // --- Winner detection logic ---\n    let winner = tournament.winner;\n    if (isChampionshipRound) {\n        // Find the last championship match played\n        const lastChampMatch = championshipMatches[0] || prevChampionshipMatches[prevChampionshipMatches.length - 1];\n        if (lastChampMatch && lastChampMatch.isCompleted && lastChampMatch.winner && lastChampMatch.loser) {\n            const winnersBracketTeam = lastChampMatch.team1;\n            const losersBracketTeam = lastChampMatch.team2;\n            const losersBracketTeamWon = losersBracketTeam && lastChampMatch.winner.id === losersBracketTeam.id;\n            // If loser's bracket team won first championship match, winner's bracket team gets another chance\n            if (losersBracketTeamWon && tournament.championshipMatchesPlayed === 1) {\n                winner = undefined; // No winner yet, need reset match\n            } else {\n                // Either winner's bracket team won first match, or this was the reset match\n                winner = lastChampMatch.winner;\n            }\n        }\n    }\n    // --- INFINITE RECURSION GUARD ---\n    const noMoreMatches = isChampionshipRound && championshipMatches.length === 0 || !isChampionshipRound && nextRoundMatches.length === 0;\n    if (noMoreMatches) {\n        // Tournament is over, do not advance further\n        return {\n            ...tournament,\n            winner,\n            currentRound: tournament.currentRound\n        };\n    }\n    // Compose the new tournament object\n    return {\n        ...tournament,\n        rounds: [\n            ...tournament.rounds,\n            {\n                roundNumber: nextRoundNumber,\n                matches: isChampionshipRound ? championshipMatches : nextRoundMatches,\n                isDoubleElimination: true,\n                isChampionshipRound\n            }\n        ],\n        currentRound: nextRoundNumber,\n        eliminatedTeams: [\n            ...tournament.eliminatedTeams,\n            ...newlyEliminated.filter((t)=>!tournament.eliminatedTeams.some((et)=>et.id === t.id))\n        ],\n        championshipMatchesPlayed: isChampionshipRound ? tournament.championshipMatchesPlayed + 1 : tournament.championshipMatchesPlayed,\n        winnersBracketFinalLoser: tournament.winnersBracketFinalLoser,\n        winner\n    };\n}; // export const advanceToNextRound = (tournament: Tournament): Tournament => {\n //   const currentRound = tournament.rounds[tournament.rounds.length - 1];\n //   const nextRoundNumber = tournament.currentRound + 1;\n //   // Track all losses across the tournament\n //   const lossCounts: Record<string, number> = {};\n //   tournament.rounds.forEach((round) => {\n //     round.matches.forEach((match) => {\n //       if (match.isCompleted && match.loser) {\n //         lossCounts[match.loser.id] = (lossCounts[match.loser.id] || 0) + 1;\n //       }\n //     });\n //   });\n //   // Gather all teams ever in the tournament\n //   const allTeams: Team[] = [];\n //   const teamIds = new Set<string>();\n //   for (const round of tournament.rounds) {\n //     for (const match of round.matches) {\n //       if (match.team1 && !teamIds.has(match.team1.id)) {\n //         allTeams.push(match.team1);\n //         teamIds.add(match.team1.id);\n //       }\n //       if (match.team2 && !teamIds.has(match.team2.id)) {\n //         allTeams.push(match.team2);\n //         teamIds.add(match.team2.id);\n //       }\n //     }\n //   }\n //   // Identify newly eliminated teams (2 losses)\n //   const newlyEliminated: Team[] = [];\n //   for (const team of allTeams) {\n //     if (\n //       (lossCounts[team.id] || 0) >= 2 &&\n //       !tournament.eliminatedTeams.some((t) => t.id === team.id)\n //     ) {\n //       newlyEliminated.push(team);\n //     }\n //   }\n //   // Winners: teams with 0 losses and not eliminated\n //   const winnersBracketTeams = allTeams.filter(\n //     (team) =>\n //       (lossCounts[team.id] || 0) === 0 &&\n //       !tournament.eliminatedTeams.some((t) => t.id === team.id) &&\n //       !newlyEliminated.some((t) => t.id === team.id)\n //   );\n //   // Losers: teams with 1 loss and not eliminated\n //   const losersBracketTeams = allTeams.filter(\n //     (team) =>\n //       (lossCounts[team.id] || 0) === 1 &&\n //       !tournament.eliminatedTeams.some((t) => t.id === team.id) &&\n //       !newlyEliminated.some((t) => t.id === team.id)\n //   );\n //   let isChampionshipRound = false;\n //   let championshipMatches: Match[] = [];\n //   let nextRoundMatches: Match[] = [];\n //   const prevChampionshipMatches = tournament.rounds\n //     .filter((r) => r.isChampionshipRound)\n //     .flatMap((r) => r.matches)\n //     .filter((m) => m.bracket === \"championship\");\n //   // --- CHAMPIONSHIP LOGIC ---\n //   // Check if a championship match already happened and was completed\n //   if (\n //     prevChampionshipMatches.length >= 1 &&\n //     prevChampionshipMatches[prevChampionshipMatches.length - 1].isCompleted\n //   ) {\n //     const lastChampMatch =\n //       prevChampionshipMatches[prevChampionshipMatches.length - 1];\n //     const winnersBracketTeam = lastChampMatch.team1;\n //     const losersBracketTeam = lastChampMatch.team2;\n //     // If loser's bracket team won the first championship match, winner's bracket team gets another chance\n //     if (\n //       lastChampMatch.winner?.id === losersBracketTeam?.id &&\n //       tournament.championshipMatchesPlayed === 1\n //     ) {\n //       isChampionshipRound = true;\n //       // Create the \"reset\" match\n //       championshipMatches.push(\n //         createMatch(\n //           `C${nextRoundNumber}-1`,\n //           nextRoundNumber,\n //           winnersBracketTeam,\n //           losersBracketTeam,\n //           false,\n //           \"championship\"\n //         )\n //       );\n //     } else {\n //       // Either winner's bracket team won first match, or this was the reset match\n //       isChampionshipRound = true;\n //       // No new matches, winner will be determined in winner detection logic\n //     }\n //   }\n //   // Check if we're ready for the championship match - one team in each bracket and loser's final is complete\n //   else if (\n //     winnersBracketTeams.length === 1 &&\n //     losersBracketTeams.length === 1 &&\n //     currentRound.matches.some(\n //       (m) =>\n //         (m.bracket === \"losers\" || m.id.includes(\"LosersLast\")) &&\n //         m.isCompleted &&\n //         m.winner &&\n //         losersBracketTeams.some((t) => t.id === m.winner!.id)\n //     )\n //   ) {\n //     // Championship match: Winner's bracket champion vs Loser's bracket champion\n //     isChampionshipRound = true;\n //     championshipMatches.push(\n //       createMatch(\n //         `C${nextRoundNumber}-1`,\n //         nextRoundNumber,\n //         winnersBracketTeams[0], // Winner's bracket champion\n //         losersBracketTeams[0], // Loser's bracket champion\n //         false,\n //         \"championship\"\n //       )\n //     );\n //   }\n //   // Check if we have a loser from winner's bracket final waiting to play against loser's bracket winner\n //   else if (\n //     winnersBracketTeams.length === 1 && // We have a winner's bracket champion\n //     losersBracketTeams.length >= 1 && // We have at least one team in loser's bracket\n //     tournament.winnersBracketFinalLoser // We have stored the winner's bracket final loser\n //   ) {\n //     // Find the winner of the loser's bracket\n //     const losersBracketWinner = currentRound.matches\n //       .filter((m) => m.bracket === \"losers\" && m.isCompleted && m.winner)\n //       .map((m) => m.winner!)\n //       .find((winner) => losersBracketTeams.some((t) => t.id === winner.id));\n //     if (\n //       losersBracketWinner &&\n //       losersBracketWinner.id !== tournament.winnersBracketFinalLoser.id\n //     ) {\n //       // Only schedule if they're not the same team!\n //       nextRoundMatches.push(\n //         createMatch(\n //           `LosersLast-${nextRoundNumber}`,\n //           nextRoundNumber,\n //           tournament.winnersBracketFinalLoser,\n //           losersBracketWinner,\n //           false,\n //           \"losers\"\n //         )\n //       );\n //     } else {\n //       // Wait for the losers bracket to resolve properly\n //       createStandardBracketMatches();\n //     }\n //   }\n //   // Check if this is the winner's bracket final (exactly 2 teams in winner's bracket)\n //   else if (winnersBracketTeams.length === 2 && losersBracketTeams.length >= 1) {\n //     // Create the winner's bracket final match\n //     nextRoundMatches.push(\n //       createMatch(\n //         `W${nextRoundNumber}-1`,\n //         nextRoundNumber,\n //         winnersBracketTeams[0],\n //         winnersBracketTeams[1],\n //         false,\n //         \"winners\"\n //       )\n //     );\n //     // Continue with losers bracket matches separately\n //     createLosersBracketMatches();\n //   }\n //   // Otherwise, continue with normal bracket play\n //   else {\n //     createStandardBracketMatches();\n //   }\n //   // Helper function to create standard bracket matches\n //   function createStandardBracketMatches() {\n //     // --- Winners Bracket Matches ---\n //     let matchCounter = 1;\n //     for (let i = 0; i < winnersBracketTeams.length; i += 2) {\n //       const team1 = winnersBracketTeams[i];\n //       const team2 = winnersBracketTeams[i + 1] ?? null;\n //       const isBye = !team2;\n //       nextRoundMatches.push(\n //         createMatch(\n //           `W${nextRoundNumber}-${matchCounter}`,\n //           nextRoundNumber,\n //           team1,\n //           team2,\n //           isBye,\n //           \"winners\"\n //         )\n //       );\n //       matchCounter++;\n //     }\n //     // Create losers bracket matches separately\n //     createLosersBracketMatches();\n //   }\n //   // Helper function to create losers bracket matches\n //   function createLosersBracketMatches() {\n //     // --- Losers Bracket Matches ---\n //     const eligibleLosers = allTeams.filter(\n //       (team) =>\n //         (lossCounts[team.id] || 0) === 1 &&\n //         !tournament.eliminatedTeams.some((t) => t.id === team.id) &&\n //         !newlyEliminated.some((t) => t.id === team.id) &&\n //         // Exclude winner's bracket final loser if it exists but hasn't played yet in losers\n //         !(\n //           tournament.winnersBracketFinalLoser &&\n //           tournament.winnersBracketFinalLoser.id === team.id\n //         )\n //     );\n //     // Find teams recently dropped from winners bracket\n //     const justDroppedFromWinners = currentRound.matches\n //       .filter((m) => m.bracket === \"winners\" && m.loser && m.isCompleted)\n //       .map((m) => m.loser!)\n //       .filter((loser) => eligibleLosers.some((t) => t.id === loser.id));\n //     // If this is the winner's bracket final, store the loser for later use\n //     if (\n //       currentRound.matches.some(\n //         (m) =>\n //           m.bracket === \"winners\" &&\n //           winnersBracketTeams.length === 1 &&\n //           m.loser &&\n //           m.isCompleted\n //       )\n //     ) {\n //       // This is a special case - we found the winner's bracket final loser\n //       const winnersFinalLoser = currentRound.matches\n //         .filter((m) => m.bracket === \"winners\" && m.isCompleted && m.loser)\n //         .map((m) => m.loser!)\n //         .pop();\n //       if (winnersFinalLoser) {\n //         tournament.winnersBracketFinalLoser = winnersFinalLoser;\n //       }\n //     }\n //     // Existing losers bracket teams\n //     const existingLosers = eligibleLosers.filter(\n //       (t) => !justDroppedFromWinners.some((jd) => jd.id === t.id)\n //     );\n //     // Order: most recent drop(s) first\n //     const orderedLosers = [...justDroppedFromWinners, ...existingLosers];\n //     if (orderedLosers.length > 0) {\n //       if (orderedLosers.length % 2 === 1) {\n //         // Odd: bye goes to the most recent team dropped from winners bracket\n //         let teamWithBye: Team | null = null;\n //         if (justDroppedFromWinners.length > 0) {\n //           teamWithBye =\n //             justDroppedFromWinners[justDroppedFromWinners.length - 1];\n //           // Remove the bye team from orderedLosers\n //           const byeIndex = orderedLosers.findIndex(\n //             (t) => t.id === teamWithBye!.id\n //           );\n //           if (byeIndex !== -1) orderedLosers.splice(byeIndex, 1);\n //         } else {\n //           // Defensive: fallback to first team if no recent drop\n //           teamWithBye = orderedLosers.shift()!;\n //         }\n //         nextRoundMatches.push(\n //           createMatch(\n //             `L${nextRoundNumber}-1`,\n //             nextRoundNumber,\n //             teamWithBye,\n //             null,\n //             true,\n //             \"losers\"\n //           )\n //         );\n //         // Pair the rest\n //         for (let i = 0; i < orderedLosers.length; i += 2) {\n //           const team1 = orderedLosers[i];\n //           const team2 = orderedLosers[i + 1] ?? null;\n //           nextRoundMatches.push(\n //             createMatch(\n //               `L${nextRoundNumber}-${Math.floor(i / 2) + 2}`,\n //               nextRoundNumber,\n //               team1,\n //               team2,\n //               !team2,\n //               \"losers\"\n //             )\n //           );\n //         }\n //       } else {\n //         // Even number: pair all\n //         for (let i = 0; i < orderedLosers.length; i += 2) {\n //           const team1 = orderedLosers[i];\n //           const team2 = orderedLosers[i + 1] ?? null;\n //           nextRoundMatches.push(\n //             createMatch(\n //               `L${nextRoundNumber}-${Math.floor(i / 2) + 1}`,\n //               nextRoundNumber,\n //               team1,\n //               team2,\n //               !team2,\n //               \"losers\"\n //             )\n //           );\n //         }\n //       }\n //     }\n //   }\n //   // --- Winner detection logic ---\n //   let winner: Team | undefined = tournament.winner;\n //   if (isChampionshipRound) {\n //     // Find the last championship match played\n //     const lastChampMatch =\n //       championshipMatches[0] ||\n //       prevChampionshipMatches[prevChampionshipMatches.length - 1];\n //     if (\n //       lastChampMatch &&\n //       lastChampMatch.isCompleted &&\n //       lastChampMatch.winner &&\n //       lastChampMatch.loser\n //     ) {\n //       const winnersBracketTeam = lastChampMatch.team1;\n //       const losersBracketTeam = lastChampMatch.team2;\n //       const losersBracketTeamWon =\n //         lastChampMatch.winner.id === losersBracketTeam.id;\n //       // If loser's bracket team won first championship match, winner's bracket team gets another chance\n //       if (losersBracketTeamWon && tournament.championshipMatchesPlayed === 1) {\n //         winner = undefined; // No winner yet, need reset match\n //       } else {\n //         // Either winner's bracket team won first match, or this was the reset match\n //         winner = lastChampMatch.winner;\n //       }\n //     }\n //   }\n //   // --- INFINITE RECURSION GUARD ---\n //   const noMoreMatches =\n //     (isChampionshipRound && championshipMatches.length === 0) ||\n //     (!isChampionshipRound && nextRoundMatches.length === 0);\n //   if (noMoreMatches) {\n //     // Tournament is over, do not advance further\n //     return {\n //       ...tournament,\n //       winner,\n //       currentRound: tournament.currentRound\n //     };\n //   }\n //   // Compose the new tournament object\n //   return {\n //     ...tournament,\n //     rounds: [\n //       ...tournament.rounds,\n //       {\n //         roundNumber: nextRoundNumber,\n //         matches: isChampionshipRound ? championshipMatches : nextRoundMatches,\n //         isDoubleElimination: true,\n //         isChampionshipRound\n //       }\n //     ],\n //     currentRound: nextRoundNumber,\n //     eliminatedTeams: [\n //       ...tournament.eliminatedTeams,\n //       ...newlyEliminated.filter(\n //         (t) => !tournament.eliminatedTeams.some((et) => et.id === t.id)\n //       )\n //     ],\n //     championshipMatchesPlayed: isChampionshipRound\n //       ? tournament.championshipMatchesPlayed + 1\n //       : tournament.championshipMatchesPlayed,\n //     winnersBracketFinalLoser: tournament.winnersBracketFinalLoser,\n //     winner\n //   };\n // };\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3R5cGVzL3RvdXJuYW1lbnQvbWF0Y2hlcy50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBbUNPLE1BQU1BLGNBQWMsU0FDekJDLElBQ0FDLGFBQ0FDLE9BQ0FDO1FBQ0FDLHlFQUFpQixPQUNqQkMsMkVBQWlELFdBQ2pEQyw0REFDQUM7UUFTZ0JMO1dBUkw7UUFDWEY7UUFDQUM7UUFDQUM7UUFDQUM7UUFDQUssYUFBYUo7UUFDYkE7UUFDQUM7UUFDQUksUUFBUUwsUUFBUUYsQ0FBQUEsT0FBQUEsa0JBQUFBLG1CQUFBQSxRQUFTQyxtQkFBVEQsa0JBQUFBLE9BQWtCUSxZQUFZQTtRQUM5Q0MsT0FBT1AsUUFBUU0sWUFBWUE7UUFDM0JFLE9BQU87WUFBRUMsWUFBWTtZQUFHQyxZQUFZO1FBQUU7UUFDdENSO1FBQ0FDO1FBQ0FRLGlCQUFpQkw7SUFDbkI7QUFBQSxFQUFHO0FBRUksTUFBTU0sc0JBQXNCLENBQUNDO0lBQ2xDLE1BQU1DLFdBQVdELE1BQU1FLE1BQU07SUFDN0IsTUFBTUMsVUFBbUIsRUFBRTtJQUMzQixNQUFNQyxZQUFZQyxLQUFLQyxJQUFJLENBQUNELEtBQUtFLElBQUksQ0FBQ047SUFFdEMsTUFBTU8sb0JBQW9CSCxLQUFLSSxHQUFHLENBQUMsR0FBR0wsWUFBWTtJQUNsRCxJQUFJTSxlQUFlO0lBRW5CLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJSCxtQkFBbUJHLElBQUs7UUFDMUMsTUFBTTFCLFFBQVFlLEtBQUssQ0FBQ1csSUFBSSxFQUFFLElBQUk7UUFDOUIsTUFBTXpCLFFBQVFjLEtBQUssQ0FBQ1csSUFBSSxJQUFJLEVBQUUsSUFBSTtRQUNsQyxNQUFNeEIsUUFBUSxDQUFDRixTQUFTLENBQUNDO1FBRXpCLE1BQU0wQixVQUFVLE1BQW1CLE9BQWJGO1FBQ3RCLE1BQU1yQixjQUFjLE1BQWtDLE9BQTVCZ0IsS0FBS0MsSUFBSSxDQUFDSSxlQUFlO1FBQ25ELE1BQU1wQixtQkFBbUIsTUFBa0MsT0FB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eEMsMEJBQTBCO0NBQzFCLG1FQUFtRTtDQUNuRSwrREFBK0Q7Q0FFL0QseUJBQXlCO0NBQ3pCLG9EQUFvRDtDQUNwRCxlQUFlO0NBQ2YsdUJBQXVCO0NBQ3ZCLGdCQUFnQjtDQUNoQiw4Q0FBOEM7Q0FDOUMsU0FBUztDQUNULE1BQU07Q0FFTix5Q0FBeUM7Q0FFekMsYUFBYTtDQUNiLHFCQUFxQjtDQUNyQixnQkFBZ0I7Q0FDaEIsOEJBQThCO0NBQzlCLFVBQVU7Q0FDVix3Q0FBd0M7Q0FDeEMsaUZBQWlGO0NBQ2pGLHFDQUFxQztDQUNyQyw4QkFBOEI7Q0FDOUIsVUFBVTtDQUNWLFNBQVM7Q0FDVCxxQ0FBcUM7Q0FDckMseUJBQXlCO0NBQ3pCLHVDQUF1QztDQUN2QyxtQ0FBbUM7Q0FDbkMsMEVBQTBFO0NBQzFFLFVBQVU7Q0FDVixTQUFTO0NBQ1QscURBQXFEO0NBQ3JELG1EQUFtRDtDQUNuRCxnREFBZ0Q7Q0FDaEQscUVBQXFFO0NBQ3JFLGFBQWE7Q0FDYixPQUFPO0NBQ1AsS0FBSyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi90eXBlcy90b3VybmFtZW50L21hdGNoZXMudHM/ZGEyMiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7IFRlYW0gfSBmcm9tIFwiLi9tbGItdGVhbXNcIjtcblxuZXhwb3J0IGludGVyZmFjZSBNYXRjaCB7XG4gIGlkOiBzdHJpbmc7XG4gIHJvdW5kTnVtYmVyOiBudW1iZXI7XG4gIHRlYW0xOiBUZWFtIHwgbnVsbDtcbiAgdGVhbTI6IFRlYW0gfCBudWxsO1xuICBpc0NvbXBsZXRlZDogYm9vbGVhbjtcbiAgaXNCeWU/OiBib29sZWFuO1xuICB3aW5uZXI/OiBUZWFtO1xuICBsb3Nlcj86IFRlYW07XG4gIGJyYWNrZXQ6IFwid2lubmVyc1wiIHwgXCJsb3NlcnNcIiB8IFwiY2hhbXBpb25zaGlwXCI7XG4gIHNjb3JlOiB7IHRlYW0xU2NvcmU6IG51bWJlcjsgdGVhbTJTY29yZTogbnVtYmVyIH07XG4gIG5leHRNYXRjaElkPzogc3RyaW5nO1xuICBuZXh0TG9zZXJNYXRjaElkPzogc3RyaW5nO1xuICBlbGltaW5hdGVkTGFiZWw/OiBzdHJpbmc7IC8vIGxhYmVsIGZvciBlbGltaW5hdGVkIHRlYW1zIGluIGxvc2VycyBicmFja2V0XG4gIHJlcXVpcmVzUmVtYXRjaD86IGJvb2xlYW47IC8vIGluZGljYXRlcyBpZiBhIGNoYW1waW9uc2hpcCByZW1hdGNoIGlzIHJlcXVpcmVkXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUm91bmQge1xuICByb3VuZE51bWJlcjogbnVtYmVyO1xuICBtYXRjaGVzOiBNYXRjaFtdO1xuICBpc0RvdWJsZUVsaW1pbmF0aW9uOiBib29sZWFuO1xuICBpc0NoYW1waW9uc2hpcFJvdW5kOiBib29sZWFuO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFRvdXJuYW1lbnQge1xuICByb3VuZHM6IFJvdW5kW107XG4gIGN1cnJlbnRSb3VuZDogbnVtYmVyO1xuICBlbGltaW5hdGVkVGVhbXM6IFRlYW1bXTtcbiAgY2hhbXBpb25zaGlwTWF0Y2hlc1BsYXllZDogbnVtYmVyO1xuICB3aW5uZXI/OiBUZWFtO1xuICB3aW5uZXJzQnJhY2tldEZpbmFsTG9zZXI/OiBUZWFtOyAvLyB0cmFja3MgdGhlIHdpbm5lcidzIGJyYWNrZXQgZmluYWwgbG9zZXIgZm9yIGNoYW1waW9uc2hpcCByZW1hdGNoIGxvZ2ljXG59XG5cbmV4cG9ydCBjb25zdCBjcmVhdGVNYXRjaCA9IChcbiAgaWQ6IHN0cmluZyxcbiAgcm91bmROdW1iZXI6IG51bWJlcixcbiAgdGVhbTE6IFRlYW0gfCBudWxsLFxuICB0ZWFtMjogVGVhbSB8IG51bGwsXG4gIGlzQnllOiBib29sZWFuID0gZmFsc2UsXG4gIGJyYWNrZXQ6IFwid2lubmVyc1wiIHwgXCJsb3NlcnNcIiB8IFwiY2hhbXBpb25zaGlwXCIgPSBcIndpbm5lcnNcIixcbiAgbmV4dE1hdGNoSWQ/OiBzdHJpbmcsXG4gIG5leHRMb3Nlck1hdGNoSWQ/OiBzdHJpbmdcbik6IE1hdGNoID0+ICh7XG4gIGlkLFxuICByb3VuZE51bWJlcixcbiAgdGVhbTEsXG4gIHRlYW0yLFxuICBpc0NvbXBsZXRlZDogaXNCeWUsXG4gIGlzQnllLFxuICBicmFja2V0LFxuICB3aW5uZXI6IGlzQnllID8gdGVhbTEgPz8gdGVhbTIgPz8gdW5kZWZpbmVkIDogdW5kZWZpbmVkLFxuICBsb3NlcjogaXNCeWUgPyB1bmRlZmluZWQgOiB1bmRlZmluZWQsXG4gIHNjb3JlOiB7IHRlYW0xU2NvcmU6IDAsIHRlYW0yU2NvcmU6IDAgfSxcbiAgbmV4dE1hdGNoSWQsXG4gIG5leHRMb3Nlck1hdGNoSWQsXG4gIGVsaW1pbmF0ZWRMYWJlbDogdW5kZWZpbmVkXG59KTtcblxuZXhwb3J0IGNvbnN0IGNyZWF0ZUluaXRpYWxSb3VuZHMgPSAodGVhbXM6IFRlYW1bXSk6IFRvdXJuYW1lbnQgPT4ge1xuICBjb25zdCBudW1UZWFtcyA9IHRlYW1zLmxlbmd0aDtcbiAgY29uc3QgbWF0Y2hlczogTWF0Y2hbXSA9IFtdO1xuICBjb25zdCBudW1Sb3VuZHMgPSBNYXRoLmNlaWwoTWF0aC5sb2cyKG51bVRlYW1zKSk7XG5cbiAgY29uc3QgZmlyc3RSb3VuZE1hdGNoZXMgPSBNYXRoLnBvdygyLCBudW1Sb3VuZHMgLSAxKTtcbiAgbGV0IG1hdGNoQ291bnRlciA9IDE7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBmaXJzdFJvdW5kTWF0Y2hlczsgaSsrKSB7XG4gICAgY29uc3QgdGVhbTEgPSB0ZWFtc1tpICogMl0gfHwgbnVsbDtcbiAgICBjb25zdCB0ZWFtMiA9IHRlYW1zW2kgKiAyICsgMV0gfHwgbnVsbDtcbiAgICBjb25zdCBpc0J5ZSA9ICF0ZWFtMSB8fCAhdGVhbTI7XG5cbiAgICBjb25zdCBtYXRjaElkID0gYFcxLSR7bWF0Y2hDb3VudGVyfWA7XG4gICAgY29uc3QgbmV4dE1hdGNoSWQgPSBgVzItJHtNYXRoLmNlaWwobWF0Y2hDb3VudGVyIC8gMil9YDtcbiAgICBjb25zdCBuZXh0TG9zZXJNYXRjaElkID0gYEwxLSR7TWF0aC5jZWlsKG1hdGNoQ291bnRlciAvIDIpfWA7XG5cbiAgICBtYXRjaGVzLnB1c2goXG4gICAgICBjcmVhdGVNYXRjaChcbiAgICAgICAgbWF0Y2hJZCxcbiAgICAgICAgMSxcbiAgICAgICAgdGVhbTEsXG4gICAgICAgIHRlYW0yLFxuICAgICAgICBpc0J5ZSxcbiAgICAgICAgXCJ3aW5uZXJzXCIsXG4gICAgICAgIG5leHRNYXRjaElkLFxuICAgICAgICBuZXh0TG9zZXJNYXRjaElkXG4gICAgICApXG4gICAgKTtcbiAgICBtYXRjaENvdW50ZXIrKztcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgcm91bmRzOiBbXG4gICAgICB7XG4gICAgICAgIHJvdW5kTnVtYmVyOiAxLFxuICAgICAgICBtYXRjaGVzLFxuICAgICAgICBpc0RvdWJsZUVsaW1pbmF0aW9uOiB0cnVlLFxuICAgICAgICBpc0NoYW1waW9uc2hpcFJvdW5kOiBmYWxzZVxuICAgICAgfVxuICAgIF0sXG4gICAgY3VycmVudFJvdW5kOiAxLFxuICAgIGVsaW1pbmF0ZWRUZWFtczogW10sXG4gICAgY2hhbXBpb25zaGlwTWF0Y2hlc1BsYXllZDogMFxuICB9O1xufTtcblxuZXhwb3J0IGNvbnN0IHVwZGF0ZU1hdGNoU2NvcmUgPSAoXG4gIG1hdGNoOiBNYXRjaCxcbiAgbmV3U2NvcmU6IHsgdGVhbTFTY29yZTogbnVtYmVyOyB0ZWFtMlNjb3JlOiBudW1iZXIgfVxuKTogTWF0Y2ggPT4ge1xuICBjb25zdCBpc0NvbXBsZXRlZCA9IG5ld1Njb3JlLnRlYW0xU2NvcmUgIT09IG5ld1Njb3JlLnRlYW0yU2NvcmU7XG4gIGxldCB3aW5uZXI6IFRlYW0gfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG4gIGxldCBsb3NlcjogVGVhbSB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcbiAgaWYgKGlzQ29tcGxldGVkKSB7XG4gICAgaWYgKG5ld1Njb3JlLnRlYW0xU2NvcmUgPiBuZXdTY29yZS50ZWFtMlNjb3JlKSB7XG4gICAgICB3aW5uZXIgPSBtYXRjaC50ZWFtMVxuICAgICAgICA/IHtcbiAgICAgICAgICAgIC4uLm1hdGNoLnRlYW0xLFxuICAgICAgICAgICAgd2luczogKG1hdGNoLnRlYW0xLndpbnMgPz8gMCkgKyAxLFxuICAgICAgICAgICAgbG9zc2VzOiBtYXRjaC50ZWFtMS5sb3NzZXMgPz8gMFxuICAgICAgICAgIH1cbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICBsb3NlciA9IG1hdGNoLnRlYW0yXG4gICAgICAgID8ge1xuICAgICAgICAgICAgLi4ubWF0Y2gudGVhbTIsXG4gICAgICAgICAgICB3aW5zOiBtYXRjaC50ZWFtMi53aW5zID8/IDAsXG4gICAgICAgICAgICBsb3NzZXM6IChtYXRjaC50ZWFtMi5sb3NzZXMgPz8gMCkgKyAxXG4gICAgICAgICAgfVxuICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICB9IGVsc2Uge1xuICAgICAgd2lubmVyID0gbWF0Y2gudGVhbTJcbiAgICAgICAgPyB7XG4gICAgICAgICAgICAuLi5tYXRjaC50ZWFtMixcbiAgICAgICAgICAgIHdpbnM6IChtYXRjaC50ZWFtMi53aW5zID8/IDApICsgMSxcbiAgICAgICAgICAgIGxvc3NlczogbWF0Y2gudGVhbTIubG9zc2VzID8/IDBcbiAgICAgICAgICB9XG4gICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgbG9zZXIgPSBtYXRjaC50ZWFtMVxuICAgICAgICA/IHtcbiAgICAgICAgICAgIC4uLm1hdGNoLnRlYW0xLFxuICAgICAgICAgICAgd2luczogbWF0Y2gudGVhbTEud2lucyA/PyAwLFxuICAgICAgICAgICAgbG9zc2VzOiAobWF0Y2gudGVhbTEubG9zc2VzID8/IDApICsgMVxuICAgICAgICAgIH1cbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgLi4ubWF0Y2gsXG4gICAgc2NvcmU6IG5ld1Njb3JlLFxuICAgIGlzQ29tcGxldGVkLFxuICAgIHdpbm5lcixcbiAgICBsb3NlclxuICB9O1xufTtcblxuLy8gSGVscGVyIHRvIGRlZHVwbGljYXRlIHRlYW1zIGJ5IElEXG5mdW5jdGlvbiBkZWR1cGVUZWFtcyh0ZWFtczogVGVhbVtdKTogVGVhbVtdIHtcbiAgY29uc3Qgc2VlbiA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuICByZXR1cm4gdGVhbXMuZmlsdGVyKCh0ZWFtKSA9PiB7XG4gICAgaWYgKCF0ZWFtKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKHNlZW4uaGFzKHRlYW0uaWQpKSByZXR1cm4gZmFsc2U7XG4gICAgc2Vlbi5hZGQodGVhbS5pZCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0pO1xufVxuXG4vLyBIZWxwZXI6IGdldCBhbGwgdGVhbXMgd2l0aCBleGFjdGx5IE4gbG9zc2VzXG5mdW5jdGlvbiB0ZWFtc1dpdGhMb3NzZXMoXG4gIGxvc3NDb3VudHM6IFJlY29yZDxzdHJpbmcsIG51bWJlcj4sXG4gIG46IG51bWJlclxuKTogc3RyaW5nW10ge1xuICByZXR1cm4gT2JqZWN0LmtleXMobG9zc0NvdW50cykuZmlsdGVyKCh0ZWFtSWQpID0+IGxvc3NDb3VudHNbdGVhbUlkXSA9PT0gbik7XG59XG5cbmV4cG9ydCBjb25zdCBhZHZhbmNlVG9OZXh0Um91bmQgPSAodG91cm5hbWVudDogVG91cm5hbWVudCk6IFRvdXJuYW1lbnQgPT4ge1xuICBjb25zdCBjdXJyZW50Um91bmQgPSB0b3VybmFtZW50LnJvdW5kc1t0b3VybmFtZW50LnJvdW5kcy5sZW5ndGggLSAxXTtcbiAgY29uc3QgbmV4dFJvdW5kTnVtYmVyID0gdG91cm5hbWVudC5jdXJyZW50Um91bmQgKyAxO1xuXG4gIC8vIFRyYWNrIGFsbCBsb3NzZXMgYW5kIHdpbnMgYWNyb3NzIHRoZSB0b3VybmFtZW50XG4gIGNvbnN0IGxvc3NDb3VudHM6IFJlY29yZDxzdHJpbmcsIG51bWJlcj4gPSB7fTtcbiAgY29uc3Qgd2luc0NvdW50czogUmVjb3JkPHN0cmluZywgbnVtYmVyPiA9IHt9O1xuICB0b3VybmFtZW50LnJvdW5kcy5mb3JFYWNoKChyb3VuZCkgPT4ge1xuICAgIHJvdW5kLm1hdGNoZXMuZm9yRWFjaCgobWF0Y2gpID0+IHtcbiAgICAgIGlmIChtYXRjaC5pc0NvbXBsZXRlZCAmJiBtYXRjaC5sb3Nlcikge1xuICAgICAgICBsb3NzQ291bnRzW21hdGNoLmxvc2VyLmlkXSA9IChsb3NzQ291bnRzW21hdGNoLmxvc2VyLmlkXSB8fCAwKSArIDE7XG4gICAgICB9XG4gICAgICBpZiAobWF0Y2guaXNDb21wbGV0ZWQgJiYgbWF0Y2gud2lubmVyKSB7XG4gICAgICAgIHdpbnNDb3VudHNbbWF0Y2gud2lubmVyLmlkXSA9ICh3aW5zQ291bnRzW21hdGNoLndpbm5lci5pZF0gfHwgMCkgKyAxO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcblxuICAvLyBHYXRoZXIgYWxsIHRlYW1zIGV2ZXIgaW4gdGhlIHRvdXJuYW1lbnQsIGF0dGFjaGluZyB3aW5zXG4gIGNvbnN0IGFsbFRlYW1zOiBUZWFtW10gPSBbXTtcbiAgY29uc3QgdGVhbUlkcyA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuICBmb3IgKGNvbnN0IHJvdW5kIG9mIHRvdXJuYW1lbnQucm91bmRzKSB7XG4gICAgZm9yIChjb25zdCBtYXRjaCBvZiByb3VuZC5tYXRjaGVzKSB7XG4gICAgICBpZiAobWF0Y2gudGVhbTEgJiYgIXRlYW1JZHMuaGFzKG1hdGNoLnRlYW0xLmlkKSkge1xuICAgICAgICBhbGxUZWFtcy5wdXNoKHtcbiAgICAgICAgICAuLi5tYXRjaC50ZWFtMSxcbiAgICAgICAgICB3aW5zOiB3aW5zQ291bnRzW21hdGNoLnRlYW0xLmlkXSB8fCAwLFxuICAgICAgICAgIGxvc3NlczogbG9zc0NvdW50c1ttYXRjaC50ZWFtMS5pZF0gfHwgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGVhbUlkcy5hZGQobWF0Y2gudGVhbTEuaWQpO1xuICAgICAgfVxuICAgICAgaWYgKG1hdGNoLnRlYW0yICYmICF0ZWFtSWRzLmhhcyhtYXRjaC50ZWFtMi5pZCkpIHtcbiAgICAgICAgYWxsVGVhbXMucHVzaCh7XG4gICAgICAgICAgLi4ubWF0Y2gudGVhbTIsXG4gICAgICAgICAgd2luczogd2luc0NvdW50c1ttYXRjaC50ZWFtMi5pZF0gfHwgMCxcbiAgICAgICAgICBsb3NzZXM6IGxvc3NDb3VudHNbbWF0Y2gudGVhbTIuaWRdIHx8IDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRlYW1JZHMuYWRkKG1hdGNoLnRlYW0yLmlkKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBJZGVudGlmeSBuZXdseSBlbGltaW5hdGVkIHRlYW1zICgyIGxvc3NlcylcbiAgY29uc3QgbmV3bHlFbGltaW5hdGVkOiBUZWFtW10gPSBbXTtcbiAgZm9yIChjb25zdCB0ZWFtIG9mIGFsbFRlYW1zKSB7XG4gICAgaWYgKFxuICAgICAgKGxvc3NDb3VudHNbdGVhbS5pZF0gfHwgMCkgPj0gMiAmJlxuICAgICAgIXRvdXJuYW1lbnQuZWxpbWluYXRlZFRlYW1zLnNvbWUoKHQpID0+IHQuaWQgPT09IHRlYW0uaWQpXG4gICAgKSB7XG4gICAgICBuZXdseUVsaW1pbmF0ZWQucHVzaCh0ZWFtKTtcbiAgICB9XG4gIH1cblxuICAvLyBXaW5uZXJzOiB0ZWFtcyB3aXRoIDAgbG9zc2VzIGFuZCBub3QgZWxpbWluYXRlZFxuICBjb25zdCB3aW5uZXJzQnJhY2tldFRlYW1zID0gYWxsVGVhbXNcbiAgICAuZmlsdGVyKFxuICAgICAgKHRlYW0pID0+XG4gICAgICAgIChsb3NzQ291bnRzW3RlYW0uaWRdIHx8IDApID09PSAwICYmXG4gICAgICAgICF0b3VybmFtZW50LmVsaW1pbmF0ZWRUZWFtcy5zb21lKCh0KSA9PiB0LmlkID09PSB0ZWFtLmlkKSAmJlxuICAgICAgICAhbmV3bHlFbGltaW5hdGVkLnNvbWUoKHQpID0+IHQuaWQgPT09IHRlYW0uaWQpXG4gICAgKVxuICAgIC5tYXAoKHRlYW0pID0+ICh7XG4gICAgICAuLi50ZWFtLFxuICAgICAgbG9zc2VzOiBsb3NzQ291bnRzW3RlYW0uaWRdIHx8IDAsXG4gICAgICB3aW5zOiB3aW5zQ291bnRzW3RlYW0uaWRdIHx8IDBcbiAgICB9KSk7XG5cbiAgLy8gTG9zZXJzOiB0ZWFtcyB3aXRoIDEgbG9zcyBhbmQgbm90IGVsaW1pbmF0ZWRcbiAgY29uc3QgbG9zZXJzQnJhY2tldFRlYW1zID0gYWxsVGVhbXNcbiAgICAuZmlsdGVyKFxuICAgICAgKHRlYW0pID0+XG4gICAgICAgIChsb3NzQ291bnRzW3RlYW0uaWRdIHx8IDApID09PSAxICYmXG4gICAgICAgICF0b3VybmFtZW50LmVsaW1pbmF0ZWRUZWFtcy5zb21lKCh0KSA9PiB0LmlkID09PSB0ZWFtLmlkKSAmJlxuICAgICAgICAhbmV3bHlFbGltaW5hdGVkLnNvbWUoKHQpID0+IHQuaWQgPT09IHRlYW0uaWQpXG4gICAgKVxuICAgIC5tYXAoKHRlYW0pID0+ICh7XG4gICAgICAuLi50ZWFtLFxuICAgICAgbG9zc2VzOiBsb3NzQ291bnRzW3RlYW0uaWRdIHx8IDAsXG4gICAgICB3aW5zOiB3aW5zQ291bnRzW3RlYW0uaWRdIHx8IDBcbiAgICB9KSk7XG5cbiAgbGV0IGlzQ2hhbXBpb25zaGlwUm91bmQgPSBmYWxzZTtcbiAgbGV0IGNoYW1waW9uc2hpcE1hdGNoZXM6IE1hdGNoW10gPSBbXTtcbiAgbGV0IG5leHRSb3VuZE1hdGNoZXM6IE1hdGNoW10gPSBbXTtcblxuICBjb25zdCBwcmV2Q2hhbXBpb25zaGlwTWF0Y2hlcyA9IHRvdXJuYW1lbnQucm91bmRzXG4gICAgLmZpbHRlcigocikgPT4gci5pc0NoYW1waW9uc2hpcFJvdW5kKVxuICAgIC5mbGF0TWFwKChyKSA9PiByLm1hdGNoZXMpXG4gICAgLmZpbHRlcigobSkgPT4gbS5icmFja2V0ID09PSBcImNoYW1waW9uc2hpcFwiKTtcblxuICAvLyAtLS0gQ0hBTVBJT05TSElQIExPR0lDIC0tLVxuXG4gIC8vIENoZWNrIGlmIGEgY2hhbXBpb25zaGlwIG1hdGNoIGFscmVhZHkgaGFwcGVuZWQgYW5kIHdhcyBjb21wbGV0ZWRcbiAgaWYgKFxuICAgIHByZXZDaGFtcGlvbnNoaXBNYXRjaGVzLmxlbmd0aCA+PSAxICYmXG4gICAgcHJldkNoYW1waW9uc2hpcE1hdGNoZXNbcHJldkNoYW1waW9uc2hpcE1hdGNoZXMubGVuZ3RoIC0gMV0uaXNDb21wbGV0ZWRcbiAgKSB7XG4gICAgY29uc3QgbGFzdENoYW1wTWF0Y2ggPVxuICAgICAgcHJldkNoYW1waW9uc2hpcE1hdGNoZXNbcHJldkNoYW1waW9uc2hpcE1hdGNoZXMubGVuZ3RoIC0gMV07XG4gICAgY29uc3Qgd2lubmVyc0JyYWNrZXRUZWFtID0gbGFzdENoYW1wTWF0Y2gudGVhbTE7XG4gICAgY29uc3QgbG9zZXJzQnJhY2tldFRlYW0gPSBsYXN0Q2hhbXBNYXRjaC50ZWFtMjtcblxuICAgIC8vIElmIGxvc2VyJ3MgYnJhY2tldCB0ZWFtIHdvbiB0aGUgZmlyc3QgY2hhbXBpb25zaGlwIG1hdGNoLCB3aW5uZXIncyBicmFja2V0IHRlYW0gZ2V0cyBhbm90aGVyIGNoYW5jZVxuICAgIGlmIChcbiAgICAgIGxhc3RDaGFtcE1hdGNoLndpbm5lcj8uaWQgPT09IGxvc2Vyc0JyYWNrZXRUZWFtPy5pZCAmJlxuICAgICAgdG91cm5hbWVudC5jaGFtcGlvbnNoaXBNYXRjaGVzUGxheWVkID09PSAxXG4gICAgKSB7XG4gICAgICBpc0NoYW1waW9uc2hpcFJvdW5kID0gdHJ1ZTtcbiAgICAgIC8vIENyZWF0ZSB0aGUgXCJyZXNldFwiIG1hdGNoXG4gICAgICBjaGFtcGlvbnNoaXBNYXRjaGVzLnB1c2goXG4gICAgICAgIGNyZWF0ZU1hdGNoKFxuICAgICAgICAgIGBDJHtuZXh0Um91bmROdW1iZXJ9LTFgLFxuICAgICAgICAgIG5leHRSb3VuZE51bWJlcixcbiAgICAgICAgICB3aW5uZXJzQnJhY2tldFRlYW0sXG4gICAgICAgICAgbG9zZXJzQnJhY2tldFRlYW0sXG4gICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgXCJjaGFtcGlvbnNoaXBcIlxuICAgICAgICApXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBFaXRoZXIgd2lubmVyJ3MgYnJhY2tldCB0ZWFtIHdvbiBmaXJzdCBtYXRjaCwgb3IgdGhpcyB3YXMgdGhlIHJlc2V0IG1hdGNoXG4gICAgICBpc0NoYW1waW9uc2hpcFJvdW5kID0gdHJ1ZTtcbiAgICAgIC8vIE5vIG5ldyBtYXRjaGVzLCB3aW5uZXIgd2lsbCBiZSBkZXRlcm1pbmVkIGluIHdpbm5lciBkZXRlY3Rpb24gbG9naWNcbiAgICB9XG4gIH1cbiAgLy8gQ2hlY2sgaWYgd2UncmUgcmVhZHkgZm9yIHRoZSBjaGFtcGlvbnNoaXAgbWF0Y2ggLSBvbmUgdGVhbSBpbiBlYWNoIGJyYWNrZXQgYW5kIGxvc2VyJ3MgZmluYWwgaXMgY29tcGxldGVcbiAgZWxzZSBpZiAoXG4gICAgd2lubmVyc0JyYWNrZXRUZWFtcy5sZW5ndGggPT09IDEgJiZcbiAgICBsb3NlcnNCcmFja2V0VGVhbXMubGVuZ3RoID09PSAxICYmXG4gICAgY3VycmVudFJvdW5kLm1hdGNoZXMuc29tZShcbiAgICAgIChtKSA9PlxuICAgICAgICAobS5icmFja2V0ID09PSBcImxvc2Vyc1wiIHx8IG0uaWQuaW5jbHVkZXMoXCJMb3NlcnNMYXN0XCIpKSAmJlxuICAgICAgICBtLmlzQ29tcGxldGVkICYmXG4gICAgICAgIG0ud2lubmVyICYmXG4gICAgICAgIGxvc2Vyc0JyYWNrZXRUZWFtcy5zb21lKCh0KSA9PiB0LmlkID09PSBtLndpbm5lciEuaWQpXG4gICAgKVxuICApIHtcbiAgICAvLyBDaGFtcGlvbnNoaXAgbWF0Y2g6IFdpbm5lcidzIGJyYWNrZXQgY2hhbXBpb24gdnMgTG9zZXIncyBicmFja2V0IGNoYW1waW9uXG4gICAgaXNDaGFtcGlvbnNoaXBSb3VuZCA9IHRydWU7XG4gICAgY2hhbXBpb25zaGlwTWF0Y2hlcy5wdXNoKFxuICAgICAgY3JlYXRlTWF0Y2goXG4gICAgICAgIGBDJHtuZXh0Um91bmROdW1iZXJ9LTFgLFxuICAgICAgICBuZXh0Um91bmROdW1iZXIsXG4gICAgICAgIHdpbm5lcnNCcmFja2V0VGVhbXNbMF0sIC8vIFdpbm5lcidzIGJyYWNrZXQgY2hhbXBpb25cbiAgICAgICAgbG9zZXJzQnJhY2tldFRlYW1zWzBdLCAvLyBMb3NlcidzIGJyYWNrZXQgY2hhbXBpb25cbiAgICAgICAgZmFsc2UsXG4gICAgICAgIFwiY2hhbXBpb25zaGlwXCJcbiAgICAgIClcbiAgICApO1xuICB9XG4gIC8vIENoZWNrIGlmIHdlIGhhdmUgYSBsb3NlciBmcm9tIHdpbm5lcidzIGJyYWNrZXQgZmluYWwgd2FpdGluZyB0byBwbGF5IGFnYWluc3QgbG9zZXIncyBicmFja2V0IHdpbm5lclxuICBlbHNlIGlmIChcbiAgICB3aW5uZXJzQnJhY2tldFRlYW1zLmxlbmd0aCA9PT0gMSAmJiAvLyBXZSBoYXZlIGEgd2lubmVyJ3MgYnJhY2tldCBjaGFtcGlvblxuICAgIGxvc2Vyc0JyYWNrZXRUZWFtcy5sZW5ndGggPj0gMSAmJiAvLyBXZSBoYXZlIGF0IGxlYXN0IG9uZSB0ZWFtIGluIGxvc2VyJ3MgYnJhY2tldFxuICAgIHRvdXJuYW1lbnQud2lubmVyc0JyYWNrZXRGaW5hbExvc2VyIC8vIFdlIGhhdmUgc3RvcmVkIHRoZSB3aW5uZXIncyBicmFja2V0IGZpbmFsIGxvc2VyXG4gICkge1xuICAgIC8vIEZpbmQgdGhlIHdpbm5lciBvZiB0aGUgbG9zZXIncyBicmFja2V0XG4gICAgY29uc3QgbG9zZXJzQnJhY2tldFdpbm5lciA9IGN1cnJlbnRSb3VuZC5tYXRjaGVzXG4gICAgICAuZmlsdGVyKChtKSA9PiBtLmJyYWNrZXQgPT09IFwibG9zZXJzXCIgJiYgbS5pc0NvbXBsZXRlZCAmJiBtLndpbm5lcilcbiAgICAgIC5tYXAoKG0pID0+IG0ud2lubmVyISlcbiAgICAgIC5maW5kKCh3aW5uZXIpID0+IGxvc2Vyc0JyYWNrZXRUZWFtcy5zb21lKCh0KSA9PiB0LmlkID09PSB3aW5uZXIuaWQpKTtcblxuICAgIGlmIChcbiAgICAgIGxvc2Vyc0JyYWNrZXRXaW5uZXIgJiZcbiAgICAgIGxvc2Vyc0JyYWNrZXRXaW5uZXIuaWQgIT09IHRvdXJuYW1lbnQud2lubmVyc0JyYWNrZXRGaW5hbExvc2VyLmlkXG4gICAgKSB7XG4gICAgICAvLyBPbmx5IHNjaGVkdWxlIGlmIHRoZXkncmUgbm90IHRoZSBzYW1lIHRlYW0hXG4gICAgICBuZXh0Um91bmRNYXRjaGVzLnB1c2goXG4gICAgICAgIGNyZWF0ZU1hdGNoKFxuICAgICAgICAgIGBMb3NlcnNMYXN0LSR7bmV4dFJvdW5kTnVtYmVyfWAsXG4gICAgICAgICAgbmV4dFJvdW5kTnVtYmVyLFxuICAgICAgICAgIHRvdXJuYW1lbnQud2lubmVyc0JyYWNrZXRGaW5hbExvc2VyLFxuICAgICAgICAgIGxvc2Vyc0JyYWNrZXRXaW5uZXIsXG4gICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgXCJsb3NlcnNcIlxuICAgICAgICApXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBXYWl0IGZvciB0aGUgbG9zZXJzIGJyYWNrZXQgdG8gcmVzb2x2ZSBwcm9wZXJseVxuICAgICAgY3JlYXRlU3RhbmRhcmRCcmFja2V0TWF0Y2hlcygpO1xuICAgIH1cbiAgfVxuICAvLyBDaGVjayBpZiB0aGlzIGlzIHRoZSB3aW5uZXIncyBicmFja2V0IGZpbmFsIChleGFjdGx5IDIgdGVhbXMgaW4gd2lubmVyJ3MgYnJhY2tldClcbiAgZWxzZSBpZiAod2lubmVyc0JyYWNrZXRUZWFtcy5sZW5ndGggPT09IDIgJiYgbG9zZXJzQnJhY2tldFRlYW1zLmxlbmd0aCA+PSAxKSB7XG4gICAgLy8gQ3JlYXRlIHRoZSB3aW5uZXIncyBicmFja2V0IGZpbmFsIG1hdGNoXG4gICAgbmV4dFJvdW5kTWF0Y2hlcy5wdXNoKFxuICAgICAgY3JlYXRlTWF0Y2goXG4gICAgICAgIGBXJHtuZXh0Um91bmROdW1iZXJ9LTFgLFxuICAgICAgICBuZXh0Um91bmROdW1iZXIsXG4gICAgICAgIHdpbm5lcnNCcmFja2V0VGVhbXNbMF0sXG4gICAgICAgIHdpbm5lcnNCcmFja2V0VGVhbXNbMV0sXG4gICAgICAgIGZhbHNlLFxuICAgICAgICBcIndpbm5lcnNcIlxuICAgICAgKVxuICAgICk7XG5cbiAgICAvLyBDb250aW51ZSB3aXRoIGxvc2VycyBicmFja2V0IG1hdGNoZXMgc2VwYXJhdGVseVxuICAgIGNyZWF0ZUxvc2Vyc0JyYWNrZXRNYXRjaGVzKCk7XG4gIH1cbiAgLy8gT3RoZXJ3aXNlLCBjb250aW51ZSB3aXRoIG5vcm1hbCBicmFja2V0IHBsYXlcbiAgZWxzZSB7XG4gICAgY3JlYXRlU3RhbmRhcmRCcmFja2V0TWF0Y2hlcygpO1xuICB9XG5cbiAgLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGNyZWF0ZSBzdGFuZGFyZCBicmFja2V0IG1hdGNoZXNcbiAgZnVuY3Rpb24gY3JlYXRlU3RhbmRhcmRCcmFja2V0TWF0Y2hlcygpIHtcbiAgICAvLyAtLS0gV2lubmVycyBCcmFja2V0IE1hdGNoZXMgLS0tXG4gICAgbGV0IG1hdGNoQ291bnRlciA9IDE7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB3aW5uZXJzQnJhY2tldFRlYW1zLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICBjb25zdCB0ZWFtMSA9IHdpbm5lcnNCcmFja2V0VGVhbXNbaV07XG4gICAgICBjb25zdCB0ZWFtMiA9IHdpbm5lcnNCcmFja2V0VGVhbXNbaSArIDFdID8/IG51bGw7XG4gICAgICBjb25zdCBpc0J5ZSA9ICF0ZWFtMjtcbiAgICAgIG5leHRSb3VuZE1hdGNoZXMucHVzaChcbiAgICAgICAgY3JlYXRlTWF0Y2goXG4gICAgICAgICAgYFcke25leHRSb3VuZE51bWJlcn0tJHttYXRjaENvdW50ZXJ9YCxcbiAgICAgICAgICBuZXh0Um91bmROdW1iZXIsXG4gICAgICAgICAgdGVhbTEsXG4gICAgICAgICAgdGVhbTIsXG4gICAgICAgICAgaXNCeWUsXG4gICAgICAgICAgXCJ3aW5uZXJzXCJcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICAgIG1hdGNoQ291bnRlcisrO1xuICAgIH1cblxuICAgIC8vIENyZWF0ZSBsb3NlcnMgYnJhY2tldCBtYXRjaGVzIHNlcGFyYXRlbHlcbiAgICBjcmVhdGVMb3NlcnNCcmFja2V0TWF0Y2hlcygpO1xuICB9XG5cbiAgLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGNyZWF0ZSBsb3NlcnMgYnJhY2tldCBtYXRjaGVzXG4gIGZ1bmN0aW9uIGNyZWF0ZUxvc2Vyc0JyYWNrZXRNYXRjaGVzKCkge1xuICAgIC8vIC0tLSBMb3NlcnMgQnJhY2tldCBNYXRjaGVzIC0tLVxuICAgIGNvbnN0IGVsaWdpYmxlTG9zZXJzID0gYWxsVGVhbXMuZmlsdGVyKFxuICAgICAgKHRlYW0pID0+XG4gICAgICAgIChsb3NzQ291bnRzW3RlYW0uaWRdIHx8IDApID09PSAxICYmXG4gICAgICAgICF0b3VybmFtZW50LmVsaW1pbmF0ZWRUZWFtcy5zb21lKCh0KSA9PiB0LmlkID09PSB0ZWFtLmlkKSAmJlxuICAgICAgICAhbmV3bHlFbGltaW5hdGVkLnNvbWUoKHQpID0+IHQuaWQgPT09IHRlYW0uaWQpICYmXG4gICAgICAgIC8vIEV4Y2x1ZGUgd2lubmVyJ3MgYnJhY2tldCBmaW5hbCBsb3NlciBpZiBpdCBleGlzdHMgYnV0IGhhc24ndCBwbGF5ZWQgeWV0IGluIGxvc2Vyc1xuICAgICAgICAhKFxuICAgICAgICAgIHRvdXJuYW1lbnQud2lubmVyc0JyYWNrZXRGaW5hbExvc2VyICYmXG4gICAgICAgICAgdG91cm5hbWVudC53aW5uZXJzQnJhY2tldEZpbmFsTG9zZXIuaWQgPT09IHRlYW0uaWRcbiAgICAgICAgKVxuICAgICk7XG5cbiAgICAvLyBGaW5kIHRlYW1zIHJlY2VudGx5IGRyb3BwZWQgZnJvbSB3aW5uZXJzIGJyYWNrZXRcbiAgICBjb25zdCBqdXN0RHJvcHBlZEZyb21XaW5uZXJzID0gY3VycmVudFJvdW5kLm1hdGNoZXNcbiAgICAgIC5maWx0ZXIoKG0pID0+IG0uYnJhY2tldCA9PT0gXCJ3aW5uZXJzXCIgJiYgbS5sb3NlciAmJiBtLmlzQ29tcGxldGVkKVxuICAgICAgLm1hcCgobSkgPT4gbS5sb3NlciEpXG4gICAgICAuZmlsdGVyKChsb3NlcikgPT4gZWxpZ2libGVMb3NlcnMuc29tZSgodCkgPT4gdC5pZCA9PT0gbG9zZXIuaWQpKTtcblxuICAgIC8vIElmIHRoaXMgaXMgdGhlIHdpbm5lcidzIGJyYWNrZXQgZmluYWwsIHN0b3JlIHRoZSBsb3NlciBmb3IgbGF0ZXIgdXNlXG4gICAgaWYgKFxuICAgICAgY3VycmVudFJvdW5kLm1hdGNoZXMuc29tZShcbiAgICAgICAgKG0pID0+XG4gICAgICAgICAgbS5icmFja2V0ID09PSBcIndpbm5lcnNcIiAmJlxuICAgICAgICAgIHdpbm5lcnNCcmFja2V0VGVhbXMubGVuZ3RoID09PSAxICYmXG4gICAgICAgICAgbS5sb3NlciAmJlxuICAgICAgICAgIG0uaXNDb21wbGV0ZWRcbiAgICAgIClcbiAgICApIHtcbiAgICAgIC8vIFRoaXMgaXMgYSBzcGVjaWFsIGNhc2UgLSB3ZSBmb3VuZCB0aGUgd2lubmVyJ3MgYnJhY2tldCBmaW5hbCBsb3NlclxuICAgICAgY29uc3Qgd2lubmVyc0ZpbmFsTG9zZXIgPSBjdXJyZW50Um91bmQubWF0Y2hlc1xuICAgICAgICAuZmlsdGVyKChtKSA9PiBtLmJyYWNrZXQgPT09IFwid2lubmVyc1wiICYmIG0uaXNDb21wbGV0ZWQgJiYgbS5sb3NlcilcbiAgICAgICAgLm1hcCgobSkgPT4gbS5sb3NlciEpXG4gICAgICAgIC5wb3AoKTtcblxuICAgICAgaWYgKHdpbm5lcnNGaW5hbExvc2VyKSB7XG4gICAgICAgIHRvdXJuYW1lbnQud2lubmVyc0JyYWNrZXRGaW5hbExvc2VyID0gd2lubmVyc0ZpbmFsTG9zZXI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gRXhpc3RpbmcgbG9zZXJzIGJyYWNrZXQgdGVhbXNcbiAgICBjb25zdCBleGlzdGluZ0xvc2VycyA9IGVsaWdpYmxlTG9zZXJzLmZpbHRlcihcbiAgICAgICh0KSA9PiAhanVzdERyb3BwZWRGcm9tV2lubmVycy5zb21lKChqZCkgPT4gamQuaWQgPT09IHQuaWQpXG4gICAgKTtcblxuICAgIC8vIE9yZGVyOiBtb3N0IHJlY2VudCBkcm9wKHMpIGZpcnN0XG4gICAgY29uc3Qgb3JkZXJlZExvc2VycyA9IFsuLi5qdXN0RHJvcHBlZEZyb21XaW5uZXJzLCAuLi5leGlzdGluZ0xvc2Vyc107XG5cbiAgICBpZiAob3JkZXJlZExvc2Vycy5sZW5ndGggPiAwKSB7XG4gICAgICBpZiAob3JkZXJlZExvc2Vycy5sZW5ndGggJSAyID09PSAxKSB7XG4gICAgICAgIC8vIE9kZDogYnllIGdvZXMgdG8gdGhlIG1vc3QgcmVjZW50IHRlYW0gZHJvcHBlZCBmcm9tIHdpbm5lcnMgYnJhY2tldFxuICAgICAgICBsZXQgdGVhbVdpdGhCeWU6IFRlYW0gfCBudWxsID0gbnVsbDtcbiAgICAgICAgaWYgKGp1c3REcm9wcGVkRnJvbVdpbm5lcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHRlYW1XaXRoQnllID1cbiAgICAgICAgICAgIGp1c3REcm9wcGVkRnJvbVdpbm5lcnNbanVzdERyb3BwZWRGcm9tV2lubmVycy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAvLyBSZW1vdmUgdGhlIGJ5ZSB0ZWFtIGZyb20gb3JkZXJlZExvc2Vyc1xuICAgICAgICAgIGNvbnN0IGJ5ZUluZGV4ID0gb3JkZXJlZExvc2Vycy5maW5kSW5kZXgoXG4gICAgICAgICAgICAodCkgPT4gdC5pZCA9PT0gdGVhbVdpdGhCeWUhLmlkXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpZiAoYnllSW5kZXggIT09IC0xKSBvcmRlcmVkTG9zZXJzLnNwbGljZShieWVJbmRleCwgMSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gRGVmZW5zaXZlOiBmYWxsYmFjayB0byBmaXJzdCB0ZWFtIGlmIG5vIHJlY2VudCBkcm9wXG4gICAgICAgICAgdGVhbVdpdGhCeWUgPSBvcmRlcmVkTG9zZXJzLnNoaWZ0KCkhO1xuICAgICAgICB9XG4gICAgICAgIG5leHRSb3VuZE1hdGNoZXMucHVzaChcbiAgICAgICAgICBjcmVhdGVNYXRjaChcbiAgICAgICAgICAgIGBMJHtuZXh0Um91bmROdW1iZXJ9LTFgLFxuICAgICAgICAgICAgbmV4dFJvdW5kTnVtYmVyLFxuICAgICAgICAgICAgdGVhbVdpdGhCeWUsXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAgIFwibG9zZXJzXCJcbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICAgIC8vIFBhaXIgdGhlIHJlc3RcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvcmRlcmVkTG9zZXJzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgY29uc3QgdGVhbTEgPSBvcmRlcmVkTG9zZXJzW2ldO1xuICAgICAgICAgIGNvbnN0IHRlYW0yID0gb3JkZXJlZExvc2Vyc1tpICsgMV0gPz8gbnVsbDtcbiAgICAgICAgICBuZXh0Um91bmRNYXRjaGVzLnB1c2goXG4gICAgICAgICAgICBjcmVhdGVNYXRjaChcbiAgICAgICAgICAgICAgYEwke25leHRSb3VuZE51bWJlcn0tJHtNYXRoLmZsb29yKGkgLyAyKSArIDJ9YCxcbiAgICAgICAgICAgICAgbmV4dFJvdW5kTnVtYmVyLFxuICAgICAgICAgICAgICB0ZWFtMSxcbiAgICAgICAgICAgICAgdGVhbTIsXG4gICAgICAgICAgICAgICF0ZWFtMixcbiAgICAgICAgICAgICAgXCJsb3NlcnNcIlxuICAgICAgICAgICAgKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEV2ZW4gbnVtYmVyOiBwYWlyIGFsbFxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9yZGVyZWRMb3NlcnMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICBjb25zdCB0ZWFtMSA9IG9yZGVyZWRMb3NlcnNbaV07XG4gICAgICAgICAgY29uc3QgdGVhbTIgPSBvcmRlcmVkTG9zZXJzW2kgKyAxXSA/PyBudWxsO1xuICAgICAgICAgIG5leHRSb3VuZE1hdGNoZXMucHVzaChcbiAgICAgICAgICAgIGNyZWF0ZU1hdGNoKFxuICAgICAgICAgICAgICBgTCR7bmV4dFJvdW5kTnVtYmVyfS0ke01hdGguZmxvb3IoaSAvIDIpICsgMX1gLFxuICAgICAgICAgICAgICBuZXh0Um91bmROdW1iZXIsXG4gICAgICAgICAgICAgIHRlYW0xLFxuICAgICAgICAgICAgICB0ZWFtMixcbiAgICAgICAgICAgICAgIXRlYW0yLFxuICAgICAgICAgICAgICBcImxvc2Vyc1wiXG4gICAgICAgICAgICApXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIC0tLSBXaW5uZXIgZGV0ZWN0aW9uIGxvZ2ljIC0tLVxuICBsZXQgd2lubmVyOiBUZWFtIHwgdW5kZWZpbmVkID0gdG91cm5hbWVudC53aW5uZXI7XG5cbiAgaWYgKGlzQ2hhbXBpb25zaGlwUm91bmQpIHtcbiAgICAvLyBGaW5kIHRoZSBsYXN0IGNoYW1waW9uc2hpcCBtYXRjaCBwbGF5ZWRcbiAgICBjb25zdCBsYXN0Q2hhbXBNYXRjaCA9XG4gICAgICBjaGFtcGlvbnNoaXBNYXRjaGVzWzBdIHx8XG4gICAgICBwcmV2Q2hhbXBpb25zaGlwTWF0Y2hlc1twcmV2Q2hhbXBpb25zaGlwTWF0Y2hlcy5sZW5ndGggLSAxXTtcblxuICAgIGlmIChcbiAgICAgIGxhc3RDaGFtcE1hdGNoICYmXG4gICAgICBsYXN0Q2hhbXBNYXRjaC5pc0NvbXBsZXRlZCAmJlxuICAgICAgbGFzdENoYW1wTWF0Y2gud2lubmVyICYmXG4gICAgICBsYXN0Q2hhbXBNYXRjaC5sb3NlclxuICAgICkge1xuICAgICAgY29uc3Qgd2lubmVyc0JyYWNrZXRUZWFtID0gbGFzdENoYW1wTWF0Y2gudGVhbTE7XG4gICAgICBjb25zdCBsb3NlcnNCcmFja2V0VGVhbSA9IGxhc3RDaGFtcE1hdGNoLnRlYW0yO1xuICAgICAgY29uc3QgbG9zZXJzQnJhY2tldFRlYW1Xb24gPVxuICAgICAgICBsb3NlcnNCcmFja2V0VGVhbSAmJiBsYXN0Q2hhbXBNYXRjaC53aW5uZXIuaWQgPT09IGxvc2Vyc0JyYWNrZXRUZWFtLmlkO1xuXG4gICAgICAvLyBJZiBsb3NlcidzIGJyYWNrZXQgdGVhbSB3b24gZmlyc3QgY2hhbXBpb25zaGlwIG1hdGNoLCB3aW5uZXIncyBicmFja2V0IHRlYW0gZ2V0cyBhbm90aGVyIGNoYW5jZVxuICAgICAgaWYgKGxvc2Vyc0JyYWNrZXRUZWFtV29uICYmIHRvdXJuYW1lbnQuY2hhbXBpb25zaGlwTWF0Y2hlc1BsYXllZCA9PT0gMSkge1xuICAgICAgICB3aW5uZXIgPSB1bmRlZmluZWQ7IC8vIE5vIHdpbm5lciB5ZXQsIG5lZWQgcmVzZXQgbWF0Y2hcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEVpdGhlciB3aW5uZXIncyBicmFja2V0IHRlYW0gd29uIGZpcnN0IG1hdGNoLCBvciB0aGlzIHdhcyB0aGUgcmVzZXQgbWF0Y2hcbiAgICAgICAgd2lubmVyID0gbGFzdENoYW1wTWF0Y2gud2lubmVyO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIC0tLSBJTkZJTklURSBSRUNVUlNJT04gR1VBUkQgLS0tXG4gIGNvbnN0IG5vTW9yZU1hdGNoZXMgPVxuICAgIChpc0NoYW1waW9uc2hpcFJvdW5kICYmIGNoYW1waW9uc2hpcE1hdGNoZXMubGVuZ3RoID09PSAwKSB8fFxuICAgICghaXNDaGFtcGlvbnNoaXBSb3VuZCAmJiBuZXh0Um91bmRNYXRjaGVzLmxlbmd0aCA9PT0gMCk7XG5cbiAgaWYgKG5vTW9yZU1hdGNoZXMpIHtcbiAgICAvLyBUb3VybmFtZW50IGlzIG92ZXIsIGRvIG5vdCBhZHZhbmNlIGZ1cnRoZXJcbiAgICByZXR1cm4ge1xuICAgICAgLi4udG91cm5hbWVudCxcbiAgICAgIHdpbm5lcixcbiAgICAgIGN1cnJlbnRSb3VuZDogdG91cm5hbWVudC5jdXJyZW50Um91bmRcbiAgICB9O1xuICB9XG5cbiAgLy8gQ29tcG9zZSB0aGUgbmV3IHRvdXJuYW1lbnQgb2JqZWN0XG4gIHJldHVybiB7XG4gICAgLi4udG91cm5hbWVudCxcbiAgICByb3VuZHM6IFtcbiAgICAgIC4uLnRvdXJuYW1lbnQucm91bmRzLFxuICAgICAge1xuICAgICAgICByb3VuZE51bWJlcjogbmV4dFJvdW5kTnVtYmVyLFxuICAgICAgICBtYXRjaGVzOiBpc0NoYW1waW9uc2hpcFJvdW5kID8gY2hhbXBpb25zaGlwTWF0Y2hlcyA6IG5leHRSb3VuZE1hdGNoZXMsXG4gICAgICAgIGlzRG91YmxlRWxpbWluYXRpb246IHRydWUsXG4gICAgICAgIGlzQ2hhbXBpb25zaGlwUm91bmRcbiAgICAgIH1cbiAgICBdLFxuICAgIGN1cnJlbnRSb3VuZDogbmV4dFJvdW5kTnVtYmVyLFxuICAgIGVsaW1pbmF0ZWRUZWFtczogW1xuICAgICAgLi4udG91cm5hbWVudC5lbGltaW5hdGVkVGVhbXMsXG4gICAgICAuLi5uZXdseUVsaW1pbmF0ZWQuZmlsdGVyKFxuICAgICAgICAodCkgPT4gIXRvdXJuYW1lbnQuZWxpbWluYXRlZFRlYW1zLnNvbWUoKGV0KSA9PiBldC5pZCA9PT0gdC5pZClcbiAgICAgIClcbiAgICBdLFxuICAgIGNoYW1waW9uc2hpcE1hdGNoZXNQbGF5ZWQ6IGlzQ2hhbXBpb25zaGlwUm91bmRcbiAgICAgID8gdG91cm5hbWVudC5jaGFtcGlvbnNoaXBNYXRjaGVzUGxheWVkICsgMVxuICAgICAgOiB0b3VybmFtZW50LmNoYW1waW9uc2hpcE1hdGNoZXNQbGF5ZWQsXG4gICAgd2lubmVyc0JyYWNrZXRGaW5hbExvc2VyOiB0b3VybmFtZW50Lndpbm5lcnNCcmFja2V0RmluYWxMb3NlcixcbiAgICB3aW5uZXJcbiAgfTtcbn07XG5cbi8vIGV4cG9ydCBjb25zdCBhZHZhbmNlVG9OZXh0Um91bmQgPSAodG91cm5hbWVudDogVG91cm5hbWVudCk6IFRvdXJuYW1lbnQgPT4ge1xuLy8gICBjb25zdCBjdXJyZW50Um91bmQgPSB0b3VybmFtZW50LnJvdW5kc1t0b3VybmFtZW50LnJvdW5kcy5sZW5ndGggLSAxXTtcbi8vICAgY29uc3QgbmV4dFJvdW5kTnVtYmVyID0gdG91cm5hbWVudC5jdXJyZW50Um91bmQgKyAxO1xuXG4vLyAgIC8vIFRyYWNrIGFsbCBsb3NzZXMgYWNyb3NzIHRoZSB0b3VybmFtZW50XG4vLyAgIGNvbnN0IGxvc3NDb3VudHM6IFJlY29yZDxzdHJpbmcsIG51bWJlcj4gPSB7fTtcbi8vICAgdG91cm5hbWVudC5yb3VuZHMuZm9yRWFjaCgocm91bmQpID0+IHtcbi8vICAgICByb3VuZC5tYXRjaGVzLmZvckVhY2goKG1hdGNoKSA9PiB7XG4vLyAgICAgICBpZiAobWF0Y2guaXNDb21wbGV0ZWQgJiYgbWF0Y2gubG9zZXIpIHtcbi8vICAgICAgICAgbG9zc0NvdW50c1ttYXRjaC5sb3Nlci5pZF0gPSAobG9zc0NvdW50c1ttYXRjaC5sb3Nlci5pZF0gfHwgMCkgKyAxO1xuLy8gICAgICAgfVxuLy8gICAgIH0pO1xuLy8gICB9KTtcblxuLy8gICAvLyBHYXRoZXIgYWxsIHRlYW1zIGV2ZXIgaW4gdGhlIHRvdXJuYW1lbnRcbi8vICAgY29uc3QgYWxsVGVhbXM6IFRlYW1bXSA9IFtdO1xuLy8gICBjb25zdCB0ZWFtSWRzID0gbmV3IFNldDxzdHJpbmc+KCk7XG4vLyAgIGZvciAoY29uc3Qgcm91bmQgb2YgdG91cm5hbWVudC5yb3VuZHMpIHtcbi8vICAgICBmb3IgKGNvbnN0IG1hdGNoIG9mIHJvdW5kLm1hdGNoZXMpIHtcbi8vICAgICAgIGlmIChtYXRjaC50ZWFtMSAmJiAhdGVhbUlkcy5oYXMobWF0Y2gudGVhbTEuaWQpKSB7XG4vLyAgICAgICAgIGFsbFRlYW1zLnB1c2gobWF0Y2gudGVhbTEpO1xuLy8gICAgICAgICB0ZWFtSWRzLmFkZChtYXRjaC50ZWFtMS5pZCk7XG4vLyAgICAgICB9XG4vLyAgICAgICBpZiAobWF0Y2gudGVhbTIgJiYgIXRlYW1JZHMuaGFzKG1hdGNoLnRlYW0yLmlkKSkge1xuLy8gICAgICAgICBhbGxUZWFtcy5wdXNoKG1hdGNoLnRlYW0yKTtcbi8vICAgICAgICAgdGVhbUlkcy5hZGQobWF0Y2gudGVhbTIuaWQpO1xuLy8gICAgICAgfVxuLy8gICAgIH1cbi8vICAgfVxuXG4vLyAgIC8vIElkZW50aWZ5IG5ld2x5IGVsaW1pbmF0ZWQgdGVhbXMgKDIgbG9zc2VzKVxuLy8gICBjb25zdCBuZXdseUVsaW1pbmF0ZWQ6IFRlYW1bXSA9IFtdO1xuLy8gICBmb3IgKGNvbnN0IHRlYW0gb2YgYWxsVGVhbXMpIHtcbi8vICAgICBpZiAoXG4vLyAgICAgICAobG9zc0NvdW50c1t0ZWFtLmlkXSB8fCAwKSA+PSAyICYmXG4vLyAgICAgICAhdG91cm5hbWVudC5lbGltaW5hdGVkVGVhbXMuc29tZSgodCkgPT4gdC5pZCA9PT0gdGVhbS5pZClcbi8vICAgICApIHtcbi8vICAgICAgIG5ld2x5RWxpbWluYXRlZC5wdXNoKHRlYW0pO1xuLy8gICAgIH1cbi8vICAgfVxuXG4vLyAgIC8vIFdpbm5lcnM6IHRlYW1zIHdpdGggMCBsb3NzZXMgYW5kIG5vdCBlbGltaW5hdGVkXG4vLyAgIGNvbnN0IHdpbm5lcnNCcmFja2V0VGVhbXMgPSBhbGxUZWFtcy5maWx0ZXIoXG4vLyAgICAgKHRlYW0pID0+XG4vLyAgICAgICAobG9zc0NvdW50c1t0ZWFtLmlkXSB8fCAwKSA9PT0gMCAmJlxuLy8gICAgICAgIXRvdXJuYW1lbnQuZWxpbWluYXRlZFRlYW1zLnNvbWUoKHQpID0+IHQuaWQgPT09IHRlYW0uaWQpICYmXG4vLyAgICAgICAhbmV3bHlFbGltaW5hdGVkLnNvbWUoKHQpID0+IHQuaWQgPT09IHRlYW0uaWQpXG4vLyAgICk7XG5cbi8vICAgLy8gTG9zZXJzOiB0ZWFtcyB3aXRoIDEgbG9zcyBhbmQgbm90IGVsaW1pbmF0ZWRcbi8vICAgY29uc3QgbG9zZXJzQnJhY2tldFRlYW1zID0gYWxsVGVhbXMuZmlsdGVyKFxuLy8gICAgICh0ZWFtKSA9PlxuLy8gICAgICAgKGxvc3NDb3VudHNbdGVhbS5pZF0gfHwgMCkgPT09IDEgJiZcbi8vICAgICAgICF0b3VybmFtZW50LmVsaW1pbmF0ZWRUZWFtcy5zb21lKCh0KSA9PiB0LmlkID09PSB0ZWFtLmlkKSAmJlxuLy8gICAgICAgIW5ld2x5RWxpbWluYXRlZC5zb21lKCh0KSA9PiB0LmlkID09PSB0ZWFtLmlkKVxuLy8gICApO1xuXG4vLyAgIGxldCBpc0NoYW1waW9uc2hpcFJvdW5kID0gZmFsc2U7XG4vLyAgIGxldCBjaGFtcGlvbnNoaXBNYXRjaGVzOiBNYXRjaFtdID0gW107XG4vLyAgIGxldCBuZXh0Um91bmRNYXRjaGVzOiBNYXRjaFtdID0gW107XG5cbi8vICAgY29uc3QgcHJldkNoYW1waW9uc2hpcE1hdGNoZXMgPSB0b3VybmFtZW50LnJvdW5kc1xuLy8gICAgIC5maWx0ZXIoKHIpID0+IHIuaXNDaGFtcGlvbnNoaXBSb3VuZClcbi8vICAgICAuZmxhdE1hcCgocikgPT4gci5tYXRjaGVzKVxuLy8gICAgIC5maWx0ZXIoKG0pID0+IG0uYnJhY2tldCA9PT0gXCJjaGFtcGlvbnNoaXBcIik7XG5cbi8vICAgLy8gLS0tIENIQU1QSU9OU0hJUCBMT0dJQyAtLS1cblxuLy8gICAvLyBDaGVjayBpZiBhIGNoYW1waW9uc2hpcCBtYXRjaCBhbHJlYWR5IGhhcHBlbmVkIGFuZCB3YXMgY29tcGxldGVkXG4vLyAgIGlmIChcbi8vICAgICBwcmV2Q2hhbXBpb25zaGlwTWF0Y2hlcy5sZW5ndGggPj0gMSAmJlxuLy8gICAgIHByZXZDaGFtcGlvbnNoaXBNYXRjaGVzW3ByZXZDaGFtcGlvbnNoaXBNYXRjaGVzLmxlbmd0aCAtIDFdLmlzQ29tcGxldGVkXG4vLyAgICkge1xuLy8gICAgIGNvbnN0IGxhc3RDaGFtcE1hdGNoID1cbi8vICAgICAgIHByZXZDaGFtcGlvbnNoaXBNYXRjaGVzW3ByZXZDaGFtcGlvbnNoaXBNYXRjaGVzLmxlbmd0aCAtIDFdO1xuLy8gICAgIGNvbnN0IHdpbm5lcnNCcmFja2V0VGVhbSA9IGxhc3RDaGFtcE1hdGNoLnRlYW0xO1xuLy8gICAgIGNvbnN0IGxvc2Vyc0JyYWNrZXRUZWFtID0gbGFzdENoYW1wTWF0Y2gudGVhbTI7XG5cbi8vICAgICAvLyBJZiBsb3NlcidzIGJyYWNrZXQgdGVhbSB3b24gdGhlIGZpcnN0IGNoYW1waW9uc2hpcCBtYXRjaCwgd2lubmVyJ3MgYnJhY2tldCB0ZWFtIGdldHMgYW5vdGhlciBjaGFuY2Vcbi8vICAgICBpZiAoXG4vLyAgICAgICBsYXN0Q2hhbXBNYXRjaC53aW5uZXI/LmlkID09PSBsb3NlcnNCcmFja2V0VGVhbT8uaWQgJiZcbi8vICAgICAgIHRvdXJuYW1lbnQuY2hhbXBpb25zaGlwTWF0Y2hlc1BsYXllZCA9PT0gMVxuLy8gICAgICkge1xuLy8gICAgICAgaXNDaGFtcGlvbnNoaXBSb3VuZCA9IHRydWU7XG4vLyAgICAgICAvLyBDcmVhdGUgdGhlIFwicmVzZXRcIiBtYXRjaFxuLy8gICAgICAgY2hhbXBpb25zaGlwTWF0Y2hlcy5wdXNoKFxuLy8gICAgICAgICBjcmVhdGVNYXRjaChcbi8vICAgICAgICAgICBgQyR7bmV4dFJvdW5kTnVtYmVyfS0xYCxcbi8vICAgICAgICAgICBuZXh0Um91bmROdW1iZXIsXG4vLyAgICAgICAgICAgd2lubmVyc0JyYWNrZXRUZWFtLFxuLy8gICAgICAgICAgIGxvc2Vyc0JyYWNrZXRUZWFtLFxuLy8gICAgICAgICAgIGZhbHNlLFxuLy8gICAgICAgICAgIFwiY2hhbXBpb25zaGlwXCJcbi8vICAgICAgICAgKVxuLy8gICAgICAgKTtcbi8vICAgICB9IGVsc2Uge1xuLy8gICAgICAgLy8gRWl0aGVyIHdpbm5lcidzIGJyYWNrZXQgdGVhbSB3b24gZmlyc3QgbWF0Y2gsIG9yIHRoaXMgd2FzIHRoZSByZXNldCBtYXRjaFxuLy8gICAgICAgaXNDaGFtcGlvbnNoaXBSb3VuZCA9IHRydWU7XG4vLyAgICAgICAvLyBObyBuZXcgbWF0Y2hlcywgd2lubmVyIHdpbGwgYmUgZGV0ZXJtaW5lZCBpbiB3aW5uZXIgZGV0ZWN0aW9uIGxvZ2ljXG4vLyAgICAgfVxuLy8gICB9XG4vLyAgIC8vIENoZWNrIGlmIHdlJ3JlIHJlYWR5IGZvciB0aGUgY2hhbXBpb25zaGlwIG1hdGNoIC0gb25lIHRlYW0gaW4gZWFjaCBicmFja2V0IGFuZCBsb3NlcidzIGZpbmFsIGlzIGNvbXBsZXRlXG4vLyAgIGVsc2UgaWYgKFxuLy8gICAgIHdpbm5lcnNCcmFja2V0VGVhbXMubGVuZ3RoID09PSAxICYmXG4vLyAgICAgbG9zZXJzQnJhY2tldFRlYW1zLmxlbmd0aCA9PT0gMSAmJlxuLy8gICAgIGN1cnJlbnRSb3VuZC5tYXRjaGVzLnNvbWUoXG4vLyAgICAgICAobSkgPT5cbi8vICAgICAgICAgKG0uYnJhY2tldCA9PT0gXCJsb3NlcnNcIiB8fCBtLmlkLmluY2x1ZGVzKFwiTG9zZXJzTGFzdFwiKSkgJiZcbi8vICAgICAgICAgbS5pc0NvbXBsZXRlZCAmJlxuLy8gICAgICAgICBtLndpbm5lciAmJlxuLy8gICAgICAgICBsb3NlcnNCcmFja2V0VGVhbXMuc29tZSgodCkgPT4gdC5pZCA9PT0gbS53aW5uZXIhLmlkKVxuLy8gICAgIClcbi8vICAgKSB7XG4vLyAgICAgLy8gQ2hhbXBpb25zaGlwIG1hdGNoOiBXaW5uZXIncyBicmFja2V0IGNoYW1waW9uIHZzIExvc2VyJ3MgYnJhY2tldCBjaGFtcGlvblxuLy8gICAgIGlzQ2hhbXBpb25zaGlwUm91bmQgPSB0cnVlO1xuLy8gICAgIGNoYW1waW9uc2hpcE1hdGNoZXMucHVzaChcbi8vICAgICAgIGNyZWF0ZU1hdGNoKFxuLy8gICAgICAgICBgQyR7bmV4dFJvdW5kTnVtYmVyfS0xYCxcbi8vICAgICAgICAgbmV4dFJvdW5kTnVtYmVyLFxuLy8gICAgICAgICB3aW5uZXJzQnJhY2tldFRlYW1zWzBdLCAvLyBXaW5uZXIncyBicmFja2V0IGNoYW1waW9uXG4vLyAgICAgICAgIGxvc2Vyc0JyYWNrZXRUZWFtc1swXSwgLy8gTG9zZXIncyBicmFja2V0IGNoYW1waW9uXG4vLyAgICAgICAgIGZhbHNlLFxuLy8gICAgICAgICBcImNoYW1waW9uc2hpcFwiXG4vLyAgICAgICApXG4vLyAgICAgKTtcbi8vICAgfVxuLy8gICAvLyBDaGVjayBpZiB3ZSBoYXZlIGEgbG9zZXIgZnJvbSB3aW5uZXIncyBicmFja2V0IGZpbmFsIHdhaXRpbmcgdG8gcGxheSBhZ2FpbnN0IGxvc2VyJ3MgYnJhY2tldCB3aW5uZXJcbi8vICAgZWxzZSBpZiAoXG4vLyAgICAgd2lubmVyc0JyYWNrZXRUZWFtcy5sZW5ndGggPT09IDEgJiYgLy8gV2UgaGF2ZSBhIHdpbm5lcidzIGJyYWNrZXQgY2hhbXBpb25cbi8vICAgICBsb3NlcnNCcmFja2V0VGVhbXMubGVuZ3RoID49IDEgJiYgLy8gV2UgaGF2ZSBhdCBsZWFzdCBvbmUgdGVhbSBpbiBsb3NlcidzIGJyYWNrZXRcbi8vICAgICB0b3VybmFtZW50Lndpbm5lcnNCcmFja2V0RmluYWxMb3NlciAvLyBXZSBoYXZlIHN0b3JlZCB0aGUgd2lubmVyJ3MgYnJhY2tldCBmaW5hbCBsb3NlclxuLy8gICApIHtcbi8vICAgICAvLyBGaW5kIHRoZSB3aW5uZXIgb2YgdGhlIGxvc2VyJ3MgYnJhY2tldFxuLy8gICAgIGNvbnN0IGxvc2Vyc0JyYWNrZXRXaW5uZXIgPSBjdXJyZW50Um91bmQubWF0Y2hlc1xuLy8gICAgICAgLmZpbHRlcigobSkgPT4gbS5icmFja2V0ID09PSBcImxvc2Vyc1wiICYmIG0uaXNDb21wbGV0ZWQgJiYgbS53aW5uZXIpXG4vLyAgICAgICAubWFwKChtKSA9PiBtLndpbm5lciEpXG4vLyAgICAgICAuZmluZCgod2lubmVyKSA9PiBsb3NlcnNCcmFja2V0VGVhbXMuc29tZSgodCkgPT4gdC5pZCA9PT0gd2lubmVyLmlkKSk7XG5cbi8vICAgICBpZiAoXG4vLyAgICAgICBsb3NlcnNCcmFja2V0V2lubmVyICYmXG4vLyAgICAgICBsb3NlcnNCcmFja2V0V2lubmVyLmlkICE9PSB0b3VybmFtZW50Lndpbm5lcnNCcmFja2V0RmluYWxMb3Nlci5pZFxuLy8gICAgICkge1xuLy8gICAgICAgLy8gT25seSBzY2hlZHVsZSBpZiB0aGV5J3JlIG5vdCB0aGUgc2FtZSB0ZWFtIVxuLy8gICAgICAgbmV4dFJvdW5kTWF0Y2hlcy5wdXNoKFxuLy8gICAgICAgICBjcmVhdGVNYXRjaChcbi8vICAgICAgICAgICBgTG9zZXJzTGFzdC0ke25leHRSb3VuZE51bWJlcn1gLFxuLy8gICAgICAgICAgIG5leHRSb3VuZE51bWJlcixcbi8vICAgICAgICAgICB0b3VybmFtZW50Lndpbm5lcnNCcmFja2V0RmluYWxMb3Nlcixcbi8vICAgICAgICAgICBsb3NlcnNCcmFja2V0V2lubmVyLFxuLy8gICAgICAgICAgIGZhbHNlLFxuLy8gICAgICAgICAgIFwibG9zZXJzXCJcbi8vICAgICAgICAgKVxuLy8gICAgICAgKTtcbi8vICAgICB9IGVsc2Uge1xuLy8gICAgICAgLy8gV2FpdCBmb3IgdGhlIGxvc2VycyBicmFja2V0IHRvIHJlc29sdmUgcHJvcGVybHlcbi8vICAgICAgIGNyZWF0ZVN0YW5kYXJkQnJhY2tldE1hdGNoZXMoKTtcbi8vICAgICB9XG4vLyAgIH1cbi8vICAgLy8gQ2hlY2sgaWYgdGhpcyBpcyB0aGUgd2lubmVyJ3MgYnJhY2tldCBmaW5hbCAoZXhhY3RseSAyIHRlYW1zIGluIHdpbm5lcidzIGJyYWNrZXQpXG4vLyAgIGVsc2UgaWYgKHdpbm5lcnNCcmFja2V0VGVhbXMubGVuZ3RoID09PSAyICYmIGxvc2Vyc0JyYWNrZXRUZWFtcy5sZW5ndGggPj0gMSkge1xuLy8gICAgIC8vIENyZWF0ZSB0aGUgd2lubmVyJ3MgYnJhY2tldCBmaW5hbCBtYXRjaFxuLy8gICAgIG5leHRSb3VuZE1hdGNoZXMucHVzaChcbi8vICAgICAgIGNyZWF0ZU1hdGNoKFxuLy8gICAgICAgICBgVyR7bmV4dFJvdW5kTnVtYmVyfS0xYCxcbi8vICAgICAgICAgbmV4dFJvdW5kTnVtYmVyLFxuLy8gICAgICAgICB3aW5uZXJzQnJhY2tldFRlYW1zWzBdLFxuLy8gICAgICAgICB3aW5uZXJzQnJhY2tldFRlYW1zWzFdLFxuLy8gICAgICAgICBmYWxzZSxcbi8vICAgICAgICAgXCJ3aW5uZXJzXCJcbi8vICAgICAgIClcbi8vICAgICApO1xuXG4vLyAgICAgLy8gQ29udGludWUgd2l0aCBsb3NlcnMgYnJhY2tldCBtYXRjaGVzIHNlcGFyYXRlbHlcbi8vICAgICBjcmVhdGVMb3NlcnNCcmFja2V0TWF0Y2hlcygpO1xuLy8gICB9XG4vLyAgIC8vIE90aGVyd2lzZSwgY29udGludWUgd2l0aCBub3JtYWwgYnJhY2tldCBwbGF5XG4vLyAgIGVsc2Uge1xuLy8gICAgIGNyZWF0ZVN0YW5kYXJkQnJhY2tldE1hdGNoZXMoKTtcbi8vICAgfVxuXG4vLyAgIC8vIEhlbHBlciBmdW5jdGlvbiB0byBjcmVhdGUgc3RhbmRhcmQgYnJhY2tldCBtYXRjaGVzXG4vLyAgIGZ1bmN0aW9uIGNyZWF0ZVN0YW5kYXJkQnJhY2tldE1hdGNoZXMoKSB7XG4vLyAgICAgLy8gLS0tIFdpbm5lcnMgQnJhY2tldCBNYXRjaGVzIC0tLVxuLy8gICAgIGxldCBtYXRjaENvdW50ZXIgPSAxO1xuLy8gICAgIGZvciAobGV0IGkgPSAwOyBpIDwgd2lubmVyc0JyYWNrZXRUZWFtcy5sZW5ndGg7IGkgKz0gMikge1xuLy8gICAgICAgY29uc3QgdGVhbTEgPSB3aW5uZXJzQnJhY2tldFRlYW1zW2ldO1xuLy8gICAgICAgY29uc3QgdGVhbTIgPSB3aW5uZXJzQnJhY2tldFRlYW1zW2kgKyAxXSA/PyBudWxsO1xuLy8gICAgICAgY29uc3QgaXNCeWUgPSAhdGVhbTI7XG4vLyAgICAgICBuZXh0Um91bmRNYXRjaGVzLnB1c2goXG4vLyAgICAgICAgIGNyZWF0ZU1hdGNoKFxuLy8gICAgICAgICAgIGBXJHtuZXh0Um91bmROdW1iZXJ9LSR7bWF0Y2hDb3VudGVyfWAsXG4vLyAgICAgICAgICAgbmV4dFJvdW5kTnVtYmVyLFxuLy8gICAgICAgICAgIHRlYW0xLFxuLy8gICAgICAgICAgIHRlYW0yLFxuLy8gICAgICAgICAgIGlzQnllLFxuLy8gICAgICAgICAgIFwid2lubmVyc1wiXG4vLyAgICAgICAgIClcbi8vICAgICAgICk7XG4vLyAgICAgICBtYXRjaENvdW50ZXIrKztcbi8vICAgICB9XG5cbi8vICAgICAvLyBDcmVhdGUgbG9zZXJzIGJyYWNrZXQgbWF0Y2hlcyBzZXBhcmF0ZWx5XG4vLyAgICAgY3JlYXRlTG9zZXJzQnJhY2tldE1hdGNoZXMoKTtcbi8vICAgfVxuXG4vLyAgIC8vIEhlbHBlciBmdW5jdGlvbiB0byBjcmVhdGUgbG9zZXJzIGJyYWNrZXQgbWF0Y2hlc1xuLy8gICBmdW5jdGlvbiBjcmVhdGVMb3NlcnNCcmFja2V0TWF0Y2hlcygpIHtcbi8vICAgICAvLyAtLS0gTG9zZXJzIEJyYWNrZXQgTWF0Y2hlcyAtLS1cbi8vICAgICBjb25zdCBlbGlnaWJsZUxvc2VycyA9IGFsbFRlYW1zLmZpbHRlcihcbi8vICAgICAgICh0ZWFtKSA9PlxuLy8gICAgICAgICAobG9zc0NvdW50c1t0ZWFtLmlkXSB8fCAwKSA9PT0gMSAmJlxuLy8gICAgICAgICAhdG91cm5hbWVudC5lbGltaW5hdGVkVGVhbXMuc29tZSgodCkgPT4gdC5pZCA9PT0gdGVhbS5pZCkgJiZcbi8vICAgICAgICAgIW5ld2x5RWxpbWluYXRlZC5zb21lKCh0KSA9PiB0LmlkID09PSB0ZWFtLmlkKSAmJlxuLy8gICAgICAgICAvLyBFeGNsdWRlIHdpbm5lcidzIGJyYWNrZXQgZmluYWwgbG9zZXIgaWYgaXQgZXhpc3RzIGJ1dCBoYXNuJ3QgcGxheWVkIHlldCBpbiBsb3NlcnNcbi8vICAgICAgICAgIShcbi8vICAgICAgICAgICB0b3VybmFtZW50Lndpbm5lcnNCcmFja2V0RmluYWxMb3NlciAmJlxuLy8gICAgICAgICAgIHRvdXJuYW1lbnQud2lubmVyc0JyYWNrZXRGaW5hbExvc2VyLmlkID09PSB0ZWFtLmlkXG4vLyAgICAgICAgIClcbi8vICAgICApO1xuXG4vLyAgICAgLy8gRmluZCB0ZWFtcyByZWNlbnRseSBkcm9wcGVkIGZyb20gd2lubmVycyBicmFja2V0XG4vLyAgICAgY29uc3QganVzdERyb3BwZWRGcm9tV2lubmVycyA9IGN1cnJlbnRSb3VuZC5tYXRjaGVzXG4vLyAgICAgICAuZmlsdGVyKChtKSA9PiBtLmJyYWNrZXQgPT09IFwid2lubmVyc1wiICYmIG0ubG9zZXIgJiYgbS5pc0NvbXBsZXRlZClcbi8vICAgICAgIC5tYXAoKG0pID0+IG0ubG9zZXIhKVxuLy8gICAgICAgLmZpbHRlcigobG9zZXIpID0+IGVsaWdpYmxlTG9zZXJzLnNvbWUoKHQpID0+IHQuaWQgPT09IGxvc2VyLmlkKSk7XG5cbi8vICAgICAvLyBJZiB0aGlzIGlzIHRoZSB3aW5uZXIncyBicmFja2V0IGZpbmFsLCBzdG9yZSB0aGUgbG9zZXIgZm9yIGxhdGVyIHVzZVxuLy8gICAgIGlmIChcbi8vICAgICAgIGN1cnJlbnRSb3VuZC5tYXRjaGVzLnNvbWUoXG4vLyAgICAgICAgIChtKSA9PlxuLy8gICAgICAgICAgIG0uYnJhY2tldCA9PT0gXCJ3aW5uZXJzXCIgJiZcbi8vICAgICAgICAgICB3aW5uZXJzQnJhY2tldFRlYW1zLmxlbmd0aCA9PT0gMSAmJlxuLy8gICAgICAgICAgIG0ubG9zZXIgJiZcbi8vICAgICAgICAgICBtLmlzQ29tcGxldGVkXG4vLyAgICAgICApXG4vLyAgICAgKSB7XG4vLyAgICAgICAvLyBUaGlzIGlzIGEgc3BlY2lhbCBjYXNlIC0gd2UgZm91bmQgdGhlIHdpbm5lcidzIGJyYWNrZXQgZmluYWwgbG9zZXJcbi8vICAgICAgIGNvbnN0IHdpbm5lcnNGaW5hbExvc2VyID0gY3VycmVudFJvdW5kLm1hdGNoZXNcbi8vICAgICAgICAgLmZpbHRlcigobSkgPT4gbS5icmFja2V0ID09PSBcIndpbm5lcnNcIiAmJiBtLmlzQ29tcGxldGVkICYmIG0ubG9zZXIpXG4vLyAgICAgICAgIC5tYXAoKG0pID0+IG0ubG9zZXIhKVxuLy8gICAgICAgICAucG9wKCk7XG5cbi8vICAgICAgIGlmICh3aW5uZXJzRmluYWxMb3Nlcikge1xuLy8gICAgICAgICB0b3VybmFtZW50Lndpbm5lcnNCcmFja2V0RmluYWxMb3NlciA9IHdpbm5lcnNGaW5hbExvc2VyO1xuLy8gICAgICAgfVxuLy8gICAgIH1cblxuLy8gICAgIC8vIEV4aXN0aW5nIGxvc2VycyBicmFja2V0IHRlYW1zXG4vLyAgICAgY29uc3QgZXhpc3RpbmdMb3NlcnMgPSBlbGlnaWJsZUxvc2Vycy5maWx0ZXIoXG4vLyAgICAgICAodCkgPT4gIWp1c3REcm9wcGVkRnJvbVdpbm5lcnMuc29tZSgoamQpID0+IGpkLmlkID09PSB0LmlkKVxuLy8gICAgICk7XG5cbi8vICAgICAvLyBPcmRlcjogbW9zdCByZWNlbnQgZHJvcChzKSBmaXJzdFxuLy8gICAgIGNvbnN0IG9yZGVyZWRMb3NlcnMgPSBbLi4uanVzdERyb3BwZWRGcm9tV2lubmVycywgLi4uZXhpc3RpbmdMb3NlcnNdO1xuXG4vLyAgICAgaWYgKG9yZGVyZWRMb3NlcnMubGVuZ3RoID4gMCkge1xuLy8gICAgICAgaWYgKG9yZGVyZWRMb3NlcnMubGVuZ3RoICUgMiA9PT0gMSkge1xuLy8gICAgICAgICAvLyBPZGQ6IGJ5ZSBnb2VzIHRvIHRoZSBtb3N0IHJlY2VudCB0ZWFtIGRyb3BwZWQgZnJvbSB3aW5uZXJzIGJyYWNrZXRcbi8vICAgICAgICAgbGV0IHRlYW1XaXRoQnllOiBUZWFtIHwgbnVsbCA9IG51bGw7XG4vLyAgICAgICAgIGlmIChqdXN0RHJvcHBlZEZyb21XaW5uZXJzLmxlbmd0aCA+IDApIHtcbi8vICAgICAgICAgICB0ZWFtV2l0aEJ5ZSA9XG4vLyAgICAgICAgICAgICBqdXN0RHJvcHBlZEZyb21XaW5uZXJzW2p1c3REcm9wcGVkRnJvbVdpbm5lcnMubGVuZ3RoIC0gMV07XG4vLyAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBieWUgdGVhbSBmcm9tIG9yZGVyZWRMb3NlcnNcbi8vICAgICAgICAgICBjb25zdCBieWVJbmRleCA9IG9yZGVyZWRMb3NlcnMuZmluZEluZGV4KFxuLy8gICAgICAgICAgICAgKHQpID0+IHQuaWQgPT09IHRlYW1XaXRoQnllIS5pZFxuLy8gICAgICAgICAgICk7XG4vLyAgICAgICAgICAgaWYgKGJ5ZUluZGV4ICE9PSAtMSkgb3JkZXJlZExvc2Vycy5zcGxpY2UoYnllSW5kZXgsIDEpO1xuLy8gICAgICAgICB9IGVsc2Uge1xuLy8gICAgICAgICAgIC8vIERlZmVuc2l2ZTogZmFsbGJhY2sgdG8gZmlyc3QgdGVhbSBpZiBubyByZWNlbnQgZHJvcFxuLy8gICAgICAgICAgIHRlYW1XaXRoQnllID0gb3JkZXJlZExvc2Vycy5zaGlmdCgpITtcbi8vICAgICAgICAgfVxuLy8gICAgICAgICBuZXh0Um91bmRNYXRjaGVzLnB1c2goXG4vLyAgICAgICAgICAgY3JlYXRlTWF0Y2goXG4vLyAgICAgICAgICAgICBgTCR7bmV4dFJvdW5kTnVtYmVyfS0xYCxcbi8vICAgICAgICAgICAgIG5leHRSb3VuZE51bWJlcixcbi8vICAgICAgICAgICAgIHRlYW1XaXRoQnllLFxuLy8gICAgICAgICAgICAgbnVsbCxcbi8vICAgICAgICAgICAgIHRydWUsXG4vLyAgICAgICAgICAgICBcImxvc2Vyc1wiXG4vLyAgICAgICAgICAgKVxuLy8gICAgICAgICApO1xuLy8gICAgICAgICAvLyBQYWlyIHRoZSByZXN0XG4vLyAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3JkZXJlZExvc2Vycy5sZW5ndGg7IGkgKz0gMikge1xuLy8gICAgICAgICAgIGNvbnN0IHRlYW0xID0gb3JkZXJlZExvc2Vyc1tpXTtcbi8vICAgICAgICAgICBjb25zdCB0ZWFtMiA9IG9yZGVyZWRMb3NlcnNbaSArIDFdID8/IG51bGw7XG4vLyAgICAgICAgICAgbmV4dFJvdW5kTWF0Y2hlcy5wdXNoKFxuLy8gICAgICAgICAgICAgY3JlYXRlTWF0Y2goXG4vLyAgICAgICAgICAgICAgIGBMJHtuZXh0Um91bmROdW1iZXJ9LSR7TWF0aC5mbG9vcihpIC8gMikgKyAyfWAsXG4vLyAgICAgICAgICAgICAgIG5leHRSb3VuZE51bWJlcixcbi8vICAgICAgICAgICAgICAgdGVhbTEsXG4vLyAgICAgICAgICAgICAgIHRlYW0yLFxuLy8gICAgICAgICAgICAgICAhdGVhbTIsXG4vLyAgICAgICAgICAgICAgIFwibG9zZXJzXCJcbi8vICAgICAgICAgICAgIClcbi8vICAgICAgICAgICApO1xuLy8gICAgICAgICB9XG4vLyAgICAgICB9IGVsc2Uge1xuLy8gICAgICAgICAvLyBFdmVuIG51bWJlcjogcGFpciBhbGxcbi8vICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvcmRlcmVkTG9zZXJzLmxlbmd0aDsgaSArPSAyKSB7XG4vLyAgICAgICAgICAgY29uc3QgdGVhbTEgPSBvcmRlcmVkTG9zZXJzW2ldO1xuLy8gICAgICAgICAgIGNvbnN0IHRlYW0yID0gb3JkZXJlZExvc2Vyc1tpICsgMV0gPz8gbnVsbDtcbi8vICAgICAgICAgICBuZXh0Um91bmRNYXRjaGVzLnB1c2goXG4vLyAgICAgICAgICAgICBjcmVhdGVNYXRjaChcbi8vICAgICAgICAgICAgICAgYEwke25leHRSb3VuZE51bWJlcn0tJHtNYXRoLmZsb29yKGkgLyAyKSArIDF9YCxcbi8vICAgICAgICAgICAgICAgbmV4dFJvdW5kTnVtYmVyLFxuLy8gICAgICAgICAgICAgICB0ZWFtMSxcbi8vICAgICAgICAgICAgICAgdGVhbTIsXG4vLyAgICAgICAgICAgICAgICF0ZWFtMixcbi8vICAgICAgICAgICAgICAgXCJsb3NlcnNcIlxuLy8gICAgICAgICAgICAgKVxuLy8gICAgICAgICAgICk7XG4vLyAgICAgICAgIH1cbi8vICAgICAgIH1cbi8vICAgICB9XG4vLyAgIH1cblxuLy8gICAvLyAtLS0gV2lubmVyIGRldGVjdGlvbiBsb2dpYyAtLS1cbi8vICAgbGV0IHdpbm5lcjogVGVhbSB8IHVuZGVmaW5lZCA9IHRvdXJuYW1lbnQud2lubmVyO1xuXG4vLyAgIGlmIChpc0NoYW1waW9uc2hpcFJvdW5kKSB7XG4vLyAgICAgLy8gRmluZCB0aGUgbGFzdCBjaGFtcGlvbnNoaXAgbWF0Y2ggcGxheWVkXG4vLyAgICAgY29uc3QgbGFzdENoYW1wTWF0Y2ggPVxuLy8gICAgICAgY2hhbXBpb25zaGlwTWF0Y2hlc1swXSB8fFxuLy8gICAgICAgcHJldkNoYW1waW9uc2hpcE1hdGNoZXNbcHJldkNoYW1waW9uc2hpcE1hdGNoZXMubGVuZ3RoIC0gMV07XG5cbi8vICAgICBpZiAoXG4vLyAgICAgICBsYXN0Q2hhbXBNYXRjaCAmJlxuLy8gICAgICAgbGFzdENoYW1wTWF0Y2guaXNDb21wbGV0ZWQgJiZcbi8vICAgICAgIGxhc3RDaGFtcE1hdGNoLndpbm5lciAmJlxuLy8gICAgICAgbGFzdENoYW1wTWF0Y2gubG9zZXJcbi8vICAgICApIHtcbi8vICAgICAgIGNvbnN0IHdpbm5lcnNCcmFja2V0VGVhbSA9IGxhc3RDaGFtcE1hdGNoLnRlYW0xO1xuLy8gICAgICAgY29uc3QgbG9zZXJzQnJhY2tldFRlYW0gPSBsYXN0Q2hhbXBNYXRjaC50ZWFtMjtcbi8vICAgICAgIGNvbnN0IGxvc2Vyc0JyYWNrZXRUZWFtV29uID1cbi8vICAgICAgICAgbGFzdENoYW1wTWF0Y2gud2lubmVyLmlkID09PSBsb3NlcnNCcmFja2V0VGVhbS5pZDtcblxuLy8gICAgICAgLy8gSWYgbG9zZXIncyBicmFja2V0IHRlYW0gd29uIGZpcnN0IGNoYW1waW9uc2hpcCBtYXRjaCwgd2lubmVyJ3MgYnJhY2tldCB0ZWFtIGdldHMgYW5vdGhlciBjaGFuY2Vcbi8vICAgICAgIGlmIChsb3NlcnNCcmFja2V0VGVhbVdvbiAmJiB0b3VybmFtZW50LmNoYW1waW9uc2hpcE1hdGNoZXNQbGF5ZWQgPT09IDEpIHtcbi8vICAgICAgICAgd2lubmVyID0gdW5kZWZpbmVkOyAvLyBObyB3aW5uZXIgeWV0LCBuZWVkIHJlc2V0IG1hdGNoXG4vLyAgICAgICB9IGVsc2Uge1xuLy8gICAgICAgICAvLyBFaXRoZXIgd2lubmVyJ3MgYnJhY2tldCB0ZWFtIHdvbiBmaXJzdCBtYXRjaCwgb3IgdGhpcyB3YXMgdGhlIHJlc2V0IG1hdGNoXG4vLyAgICAgICAgIHdpbm5lciA9IGxhc3RDaGFtcE1hdGNoLndpbm5lcjtcbi8vICAgICAgIH1cbi8vICAgICB9XG4vLyAgIH1cblxuLy8gICAvLyAtLS0gSU5GSU5JVEUgUkVDVVJTSU9OIEdVQVJEIC0tLVxuLy8gICBjb25zdCBub01vcmVNYXRjaGVzID1cbi8vICAgICAoaXNDaGFtcGlvbnNoaXBSb3VuZCAmJiBjaGFtcGlvbnNoaXBNYXRjaGVzLmxlbmd0aCA9PT0gMCkgfHxcbi8vICAgICAoIWlzQ2hhbXBpb25zaGlwUm91bmQgJiYgbmV4dFJvdW5kTWF0Y2hlcy5sZW5ndGggPT09IDApO1xuXG4vLyAgIGlmIChub01vcmVNYXRjaGVzKSB7XG4vLyAgICAgLy8gVG91cm5hbWVudCBpcyBvdmVyLCBkbyBub3QgYWR2YW5jZSBmdXJ0aGVyXG4vLyAgICAgcmV0dXJuIHtcbi8vICAgICAgIC4uLnRvdXJuYW1lbnQsXG4vLyAgICAgICB3aW5uZXIsXG4vLyAgICAgICBjdXJyZW50Um91bmQ6IHRvdXJuYW1lbnQuY3VycmVudFJvdW5kXG4vLyAgICAgfTtcbi8vICAgfVxuXG4vLyAgIC8vIENvbXBvc2UgdGhlIG5ldyB0b3VybmFtZW50IG9iamVjdFxuXG4vLyAgIHJldHVybiB7XG4vLyAgICAgLi4udG91cm5hbWVudCxcbi8vICAgICByb3VuZHM6IFtcbi8vICAgICAgIC4uLnRvdXJuYW1lbnQucm91bmRzLFxuLy8gICAgICAge1xuLy8gICAgICAgICByb3VuZE51bWJlcjogbmV4dFJvdW5kTnVtYmVyLFxuLy8gICAgICAgICBtYXRjaGVzOiBpc0NoYW1waW9uc2hpcFJvdW5kID8gY2hhbXBpb25zaGlwTWF0Y2hlcyA6IG5leHRSb3VuZE1hdGNoZXMsXG4vLyAgICAgICAgIGlzRG91YmxlRWxpbWluYXRpb246IHRydWUsXG4vLyAgICAgICAgIGlzQ2hhbXBpb25zaGlwUm91bmRcbi8vICAgICAgIH1cbi8vICAgICBdLFxuLy8gICAgIGN1cnJlbnRSb3VuZDogbmV4dFJvdW5kTnVtYmVyLFxuLy8gICAgIGVsaW1pbmF0ZWRUZWFtczogW1xuLy8gICAgICAgLi4udG91cm5hbWVudC5lbGltaW5hdGVkVGVhbXMsXG4vLyAgICAgICAuLi5uZXdseUVsaW1pbmF0ZWQuZmlsdGVyKFxuLy8gICAgICAgICAodCkgPT4gIXRvdXJuYW1lbnQuZWxpbWluYXRlZFRlYW1zLnNvbWUoKGV0KSA9PiBldC5pZCA9PT0gdC5pZClcbi8vICAgICAgIClcbi8vICAgICBdLFxuLy8gICAgIGNoYW1waW9uc2hpcE1hdGNoZXNQbGF5ZWQ6IGlzQ2hhbXBpb25zaGlwUm91bmRcbi8vICAgICAgID8gdG91cm5hbWVudC5jaGFtcGlvbnNoaXBNYXRjaGVzUGxheWVkICsgMVxuLy8gICAgICAgOiB0b3VybmFtZW50LmNoYW1waW9uc2hpcE1hdGNoZXNQbGF5ZWQsXG4vLyAgICAgd2lubmVyc0JyYWNrZXRGaW5hbExvc2VyOiB0b3VybmFtZW50Lndpbm5lcnNCcmFja2V0RmluYWxMb3Nlcixcbi8vICAgICB3aW5uZXJcbi8vICAgfTtcbi8vIH07XG4iXSwibmFtZXMiOlsiY3JlYXRlTWF0Y2giLCJpZCIsInJvdW5kTnVtYmVyIiwidGVhbTEiLCJ0ZWFtMiIsImlzQnllIiwiYnJhY2tldCIsIm5leHRNYXRjaElkIiwibmV4dExvc2VyTWF0Y2hJZCIsImlzQ29tcGxldGVkIiwid2lubmVyIiwidW5kZWZpbmVkIiwibG9zZXIiLCJzY29yZSIsInRlYW0xU2NvcmUiLCJ0ZWFtMlNjb3JlIiwiZWxpbWluYXRlZExhYmVsIiwiY3JlYXRlSW5pdGlhbFJvdW5kcyIsInRlYW1zIiwibnVtVGVhbXMiLCJsZW5ndGgiLCJtYXRjaGVzIiwibnVtUm91bmRzIiwiTWF0aCIsImNlaWwiLCJsb2cyIiwiZmlyc3RSb3VuZE1hdGNoZXMiLCJwb3ciLCJtYXRjaENvdW50ZXIiLCJpIiwibWF0Y2hJZCIsInB1c2giLCJyb3VuZHMiLCJpc0RvdWJsZUVsaW1pbmF0aW9uIiwiaXNDaGFtcGlvbnNoaXBSb3VuZCIsImN1cnJlbnRSb3VuZCIsImVsaW1pbmF0ZWRUZWFtcyIsImNoYW1waW9uc2hpcE1hdGNoZXNQbGF5ZWQiLCJ1cGRhdGVNYXRjaFNjb3JlIiwibWF0Y2giLCJuZXdTY29yZSIsIndpbnMiLCJsb3NzZXMiLCJkZWR1cGVUZWFtcyIsInNlZW4iLCJTZXQiLCJmaWx0ZXIiLCJ0ZWFtIiwiaGFzIiwiYWRkIiwidGVhbXNXaXRoTG9zc2VzIiwibG9zc0NvdW50cyIsIm4iLCJPYmplY3QiLCJrZXlzIiwidGVhbUlkIiwiYWR2YW5jZVRvTmV4dFJvdW5kIiwidG91cm5hbWVudCIsIm5leHRSb3VuZE51bWJlciIsIndpbnNDb3VudHMiLCJmb3JFYWNoIiwicm91bmQiLCJhbGxUZWFtcyIsInRlYW1JZHMiLCJuZXdseUVsaW1pbmF0ZWQiLCJzb21lIiwidCIsIndpbm5lcnNCcmFja2V0VGVhbXMiLCJtYXAiLCJsb3NlcnNCcmFja2V0VGVhbXMiLCJjaGFtcGlvbnNoaXBNYXRjaGVzIiwibmV4dFJvdW5kTWF0Y2hlcyIsInByZXZDaGFtcGlvbnNoaXBNYXRjaGVzIiwiciIsImZsYXRNYXAiLCJtIiwibGFzdENoYW1wTWF0Y2giLCJ3aW5uZXJzQnJhY2tldFRlYW0iLCJsb3NlcnNCcmFja2V0VGVhbSIsImluY2x1ZGVzIiwid2lubmVyc0JyYWNrZXRGaW5hbExvc2VyIiwibG9zZXJzQnJhY2tldFdpbm5lciIsImZpbmQiLCJjcmVhdGVTdGFuZGFyZEJyYWNrZXRNYXRjaGVzIiwiY3JlYXRlTG9zZXJzQnJhY2tldE1hdGNoZXMiLCJlbGlnaWJsZUxvc2VycyIsImp1c3REcm9wcGVkRnJvbVdpbm5lcnMiLCJ3aW5uZXJzRmluYWxMb3NlciIsInBvcCIsImV4aXN0aW5nTG9zZXJzIiwiamQiLCJvcmRlcmVkTG9zZXJzIiwidGVhbVdpdGhCeWUiLCJieWVJbmRleCIsImZpbmRJbmRleCIsInNwbGljZSIsInNoaWZ0IiwiZmxvb3IiLCJsb3NlcnNCcmFja2V0VGVhbVdvbiIsIm5vTW9yZU1hdGNoZXMiLCJldCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./types/tournament/matches.ts\n"));

/***/ })

});
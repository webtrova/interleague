"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/tournament/page",{

/***/ "(app-pages-browser)/./types/tournament/matches.ts":
/*!*************************************!*\
  !*** ./types/tournament/matches.ts ***!
  \*************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   advanceToNextRound: function() { return /* binding */ advanceToNextRound; },\n/* harmony export */   createInitialRounds: function() { return /* binding */ createInitialRounds; },\n/* harmony export */   createMatch: function() { return /* binding */ createMatch; },\n/* harmony export */   updateMatchScore: function() { return /* binding */ updateMatchScore; }\n/* harmony export */ });\n/* harmony import */ var _logTournamentState__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./logTournamentState */ \"(app-pages-browser)/./types/tournament/logTournamentState.ts\");\n\nconst createMatch = function(id, roundNumber, team1, team2) {\n    let isBye = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : false, bracket = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : \"winners\", nextMatchId = arguments.length > 6 ? arguments[6] : void 0, nextLoserMatchId = arguments.length > 7 ? arguments[7] : void 0;\n    var _ref;\n    return {\n        id,\n        roundNumber,\n        team1,\n        team2,\n        isCompleted: isBye,\n        isBye,\n        bracket,\n        winner: isBye ? (_ref = team1 !== null && team1 !== void 0 ? team1 : team2) !== null && _ref !== void 0 ? _ref : undefined : undefined,\n        loser: isBye ? undefined : undefined,\n        score: {\n            team1Score: 0,\n            team2Score: 0\n        },\n        nextMatchId,\n        nextLoserMatchId,\n        eliminatedLabel: undefined\n    };\n};\nconst createInitialRounds = (teams)=>{\n    const numTeams = teams.length;\n    const matches = [];\n    const numRounds = Math.ceil(Math.log2(numTeams));\n    const firstRoundMatches = Math.pow(2, numRounds - 1);\n    let matchCounter = 1;\n    for(let i = 0; i < firstRoundMatches; i++){\n        const team1 = teams[i * 2] || null;\n        const team2 = teams[i * 2 + 1] || null;\n        const isBye = !team1 || !team2;\n        const matchId = \"W1-\".concat(matchCounter);\n        const nextMatchId = \"W2-\".concat(Math.ceil(matchCounter / 2));\n        const nextLoserMatchId = \"L1-\".concat(Math.ceil(matchCounter / 2));\n        matches.push(createMatch(matchId, 1, team1, team2, isBye, \"winners\", nextMatchId, nextLoserMatchId));\n        matchCounter++;\n    }\n    return {\n        rounds: [\n            {\n                roundNumber: 1,\n                matches,\n                isDoubleElimination: true,\n                isChampionshipRound: false\n            }\n        ],\n        currentRound: 1,\n        eliminatedTeams: [],\n        championshipMatchesPlayed: 0\n    };\n};\nconst updateMatchScore = (match, newScore)=>{\n    const isCompleted = newScore.team1Score !== newScore.team2Score;\n    let winner = undefined;\n    let loser = undefined;\n    if (isCompleted) {\n        if (newScore.team1Score > newScore.team2Score) {\n            var _match_team1_wins, _match_team1_losses;\n            winner = match.team1 ? {\n                ...match.team1,\n                wins: ((_match_team1_wins = match.team1.wins) !== null && _match_team1_wins !== void 0 ? _match_team1_wins : 0) + 1,\n                losses: (_match_team1_losses = match.team1.losses) !== null && _match_team1_losses !== void 0 ? _match_team1_losses : 0\n            } : undefined;\n            var _match_team2_wins, _match_team2_losses;\n            loser = match.team2 ? {\n                ...match.team2,\n                wins: (_match_team2_wins = match.team2.wins) !== null && _match_team2_wins !== void 0 ? _match_team2_wins : 0,\n                losses: ((_match_team2_losses = match.team2.losses) !== null && _match_team2_losses !== void 0 ? _match_team2_losses : 0) + 1\n            } : undefined;\n        } else {\n            var _match_team2_wins1, _match_team2_losses1;\n            winner = match.team2 ? {\n                ...match.team2,\n                wins: ((_match_team2_wins1 = match.team2.wins) !== null && _match_team2_wins1 !== void 0 ? _match_team2_wins1 : 0) + 1,\n                losses: (_match_team2_losses1 = match.team2.losses) !== null && _match_team2_losses1 !== void 0 ? _match_team2_losses1 : 0\n            } : undefined;\n            var _match_team1_wins1, _match_team1_losses1;\n            loser = match.team1 ? {\n                ...match.team1,\n                wins: (_match_team1_wins1 = match.team1.wins) !== null && _match_team1_wins1 !== void 0 ? _match_team1_wins1 : 0,\n                losses: ((_match_team1_losses1 = match.team1.losses) !== null && _match_team1_losses1 !== void 0 ? _match_team1_losses1 : 0) + 1\n            } : undefined;\n        }\n    }\n    return {\n        ...match,\n        score: newScore,\n        isCompleted,\n        winner,\n        loser\n    };\n};\n// Helper to deduplicate teams by ID\nfunction dedupeTeams(teams) {\n    const seen = new Set();\n    return teams.filter((team)=>{\n        if (!team) return false;\n        if (seen.has(team.id)) return false;\n        seen.add(team.id);\n        return true;\n    });\n}\n// Helper: get all teams with exactly N losses\nfunction teamsWithLosses(lossCounts, n) {\n    return Object.keys(lossCounts).filter((teamId)=>lossCounts[teamId] === n);\n}\nconst advanceToNextRound = (tournament)=>{\n    const currentRound = tournament.rounds[tournament.rounds.length - 1];\n    const nextRoundNumber = tournament.currentRound + 1;\n    // Track all losses and wins across the tournament\n    const lossCounts = {};\n    const winsCounts = {};\n    tournament.rounds.forEach((round)=>{\n        round.matches.forEach((match)=>{\n            if (match.isCompleted && match.loser) {\n                lossCounts[match.loser.id] = (lossCounts[match.loser.id] || 0) + 1;\n            }\n            if (match.isCompleted && match.winner) {\n                winsCounts[match.winner.id] = (winsCounts[match.winner.id] || 0) + 1;\n            }\n        });\n    });\n    // WINNER GUARD: If a winner has already been determined, do not create any more rounds\n    if (tournament.winner) {\n        return {\n            ...tournament,\n            currentRound: tournament.currentRound\n        };\n    }\n    // Gather all teams ever in the tournament, attaching wins\n    const allTeams = [];\n    const teamIds = new Set();\n    for (const round of tournament.rounds){\n        for (const match of round.matches){\n            if (match.team1 && !teamIds.has(match.team1.id)) {\n                allTeams.push({\n                    ...match.team1,\n                    wins: winsCounts[match.team1.id] || 0,\n                    losses: lossCounts[match.team1.id] || 0\n                });\n                teamIds.add(match.team1.id);\n            }\n            if (match.team2 && !teamIds.has(match.team2.id)) {\n                allTeams.push({\n                    ...match.team2,\n                    wins: winsCounts[match.team2.id] || 0,\n                    losses: lossCounts[match.team2.id] || 0\n                });\n                teamIds.add(match.team2.id);\n            }\n        }\n    }\n    // Identify newly eliminated teams (2 losses)\n    const newlyEliminated = [];\n    for (const team of allTeams){\n        if ((lossCounts[team.id] || 0) >= 2 && !tournament.eliminatedTeams.some((t)=>t.id === team.id)) {\n            newlyEliminated.push(team);\n        }\n    }\n    // Winners: teams with 0 losses and not eliminated\n    const winnersBracketTeams = allTeams.filter((team)=>(lossCounts[team.id] || 0) === 0 && !tournament.eliminatedTeams.some((t)=>t.id === team.id) && !newlyEliminated.some((t)=>t.id === team.id) && !team.id.startsWith(\"tbd-\") // Exclude phantom TBD teams\n    ).map((team)=>({\n            ...team,\n            losses: lossCounts[team.id] || 0,\n            wins: winsCounts[team.id] || 0\n        }));\n    // Losers: teams with 1 loss and not eliminated\n    const losersBracketTeams = allTeams.filter((team)=>(lossCounts[team.id] || 0) === 1 && !tournament.eliminatedTeams.some((t)=>t.id === team.id) && !newlyEliminated.some((t)=>t.id === team.id) && // Don't include the winners bracket final loser in regular losers bracket teams\n        !(tournament.winnersBracketFinalLoser && tournament.winnersBracketFinalLoser.id === team.id)).map((team)=>({\n            ...team,\n            losses: lossCounts[team.id] || 0,\n            wins: winsCounts[team.id] || 0\n        }));\n    let isChampionshipRound = false;\n    let championshipMatches = [];\n    let nextRoundMatches = [];\n    const prevChampionshipMatches = tournament.rounds.filter((r)=>r.isChampionshipRound).flatMap((r)=>r.matches).filter((m)=>m.bracket === \"championship\");\n    // --- CHAMPIONSHIP LOGIC ---\n    // Check if a championship match already happened and was completed\n    if (prevChampionshipMatches.length >= 1 && prevChampionshipMatches[prevChampionshipMatches.length - 1].isCompleted) {\n        var _lastChampMatch_winner;\n        const lastChampMatch = prevChampionshipMatches[prevChampionshipMatches.length - 1];\n        const winnersBracketTeam = lastChampMatch.team1;\n        const losersBracketTeam = lastChampMatch.team2;\n        // If loser's bracket team won the first championship match, winner's bracket team gets another chance\n        if (((_lastChampMatch_winner = lastChampMatch.winner) === null || _lastChampMatch_winner === void 0 ? void 0 : _lastChampMatch_winner.id) === (losersBracketTeam === null || losersBracketTeam === void 0 ? void 0 : losersBracketTeam.id) && tournament.championshipMatchesPlayed === 1) {\n            isChampionshipRound = true;\n            // Create the \"reset\" match\n            championshipMatches.push(createMatch(\"C\".concat(nextRoundNumber, \"-1\"), nextRoundNumber, winnersBracketTeam, losersBracketTeam, false, \"championship\"));\n        } else {\n            // Either winner's bracket team won first match, or this was the reset match\n            isChampionshipRound = true;\n        // No new matches, winner will be determined in winner detection logic\n        }\n    } else if (winnersBracketTeams.length === 1 && losersBracketTeams.length === 1 && currentRound.matches.some((m)=>(m.bracket === \"losers\" || m.id.includes(\"LosersLast\")) && m.isCompleted && m.winner && (losersBracketTeams.some((t)=>t.id === m.winner.id) || tournament.winnersBracketFinalLoser && m.winner.id === tournament.winnersBracketFinalLoser.id))) {\n        // Find the winner of the losers bracket final\n        const losersBracketWinner = currentRound.matches.filter((m)=>(m.bracket === \"losers\" || m.id.includes(\"LosersLast\")) && m.isCompleted && m.winner).map((m)=>m.winner).pop();\n        if (losersBracketWinner) {\n            // Only schedule the championship if there is no winnersBracketFinalLoser waiting to play\n            if (!tournament.winnersBracketFinalLoser) {\n                // Schedule championship match immediately (no extra round)\n                nextRoundMatches.push(createMatch(\"C\".concat(nextRoundNumber, \"-1\"), nextRoundNumber, winnersBracketTeams[0], losersBracketWinner, false, \"championship\"));\n                isChampionshipRound = true;\n            // Do NOT schedule any waiting cards\n            } else {\n                // Instead, schedule the losers bracket final (LLWB vs LWLB), and show the winners bracket champion as waiting\n                nextRoundMatches.push(createMatch(\"LosersLast-\".concat(nextRoundNumber), nextRoundNumber, tournament.winnersBracketFinalLoser, losersBracketTeams[0], false, \"losers\"));\n                nextRoundMatches.push(createMatch(\"WinnersBracketChampion-waiting-\".concat(nextRoundNumber), nextRoundNumber, winnersBracketTeams[0], null, true, \"winners\"));\n            }\n        }\n    } else if (winnersBracketTeams.length === 1 && tournament.winnersBracketFinalLoser) {\n        if (losersBracketTeams.length === 1) {\n            // Prevent duplicate losers bracket final: check all previous rounds for this match\n            let alreadyPlayed = false;\n            for (let round of tournament.rounds){\n                if (!round.matches) continue;\n                for (let m of round.matches){\n                    var _m_team1, _m_team2;\n                    const ids = [\n                        (_m_team1 = m.team1) === null || _m_team1 === void 0 ? void 0 : _m_team1.id,\n                        (_m_team2 = m.team2) === null || _m_team2 === void 0 ? void 0 : _m_team2.id\n                    ].filter(Boolean).sort();\n                    const currIds = [\n                        tournament.winnersBracketFinalLoser.id,\n                        losersBracketTeams[0].id\n                    ].sort();\n                    if (ids.length === 2 && ids[0] === currIds[0] && ids[1] === currIds[1]) {\n                        alreadyPlayed = true;\n                        break;\n                    }\n                }\n                if (alreadyPlayed) break;\n            }\n            if (!alreadyPlayed) {\n                // Only now schedule WBFL vs LBL\n                nextRoundMatches.push(createMatch(\"LosersLast-\".concat(nextRoundNumber), nextRoundNumber, tournament.winnersBracketFinalLoser, losersBracketTeams[0], false, \"losers\"));\n            }\n        // If match already played, do not schedule again; championship logic will handle next step\n        } else if (losersBracketTeams.length === 2) {\n            // Schedule the match between the last two losers bracket teams\n            nextRoundMatches.push(createMatch(\"L\".concat(nextRoundNumber, \"-1\"), nextRoundNumber, losersBracketTeams[0], losersBracketTeams[1], false, \"losers\"));\n            // WBFL is waiting for the winner\n            nextRoundMatches.push(createMatch(\"WinnersFinalLoser-waiting-\".concat(nextRoundNumber), nextRoundNumber, tournament.winnersBracketFinalLoser, null, true, \"losers\"));\n        } else if (losersBracketTeams.length > 2) {\n            // More than 2 teams: pair off as usual, WBFL waits\n            for(let i = 0; i < losersBracketTeams.length; i += 2){\n                const team1 = losersBracketTeams[i];\n                var _losersBracketTeams_;\n                const team2 = (_losersBracketTeams_ = losersBracketTeams[i + 1]) !== null && _losersBracketTeams_ !== void 0 ? _losersBracketTeams_ : null;\n                nextRoundMatches.push(createMatch(\"L\".concat(nextRoundNumber, \"-\").concat(Math.floor(i / 2) + 1), nextRoundNumber, team1, team2, !team2, \"losers\"));\n            }\n            nextRoundMatches.push(createMatch(\"WinnersFinalLoser-waiting-\".concat(nextRoundNumber), nextRoundNumber, tournament.winnersBracketFinalLoser, null, true, \"losers\"));\n        } else {\n            // WBFL is waiting for the losers bracket to resolve\n            nextRoundMatches.push(createMatch(\"WinnersFinalLoser-waiting-\".concat(nextRoundNumber), nextRoundNumber, tournament.winnersBracketFinalLoser, null, true, \"losers\"));\n        }\n        // Always show a waiting card for the winners bracket champion if not in championship\n        nextRoundMatches.push(createMatch(\"WinnersBracketChampion-waiting-\".concat(nextRoundNumber), nextRoundNumber, winnersBracketTeams[0], null, true, \"winners\"));\n    } else if (winnersBracketTeams.length === 2) {\n        // Create the winner's bracket final match\n        nextRoundMatches.push(createMatch(\"W\".concat(nextRoundNumber, \"-1\"), nextRoundNumber, winnersBracketTeams[0], winnersBracketTeams[1], false, \"winners\"));\n        // Continue with losers bracket matches separately\n        createLosersBracketMatches();\n    } else {\n        createStandardBracketMatches();\n    }\n    // Helper function to create standard bracket matches\n    function createStandardBracketMatches() {\n        // --- Winners Bracket Matches ---\n        let matchCounter = 1;\n        for(let i = 0; i < winnersBracketTeams.length; i += 2){\n            const team1 = winnersBracketTeams[i];\n            var _winnersBracketTeams_;\n            const team2 = (_winnersBracketTeams_ = winnersBracketTeams[i + 1]) !== null && _winnersBracketTeams_ !== void 0 ? _winnersBracketTeams_ : null;\n            const isBye = !team2;\n            nextRoundMatches.push(createMatch(\"W\".concat(nextRoundNumber, \"-\").concat(matchCounter), nextRoundNumber, team1, team2, isBye, \"winners\"));\n            matchCounter++;\n        }\n        // Create losers bracket matches separately\n        createLosersBracketMatches();\n    }\n    // Helper function to create losers bracket matches\n    function createLosersBracketMatches() {\n        // --- Losers Bracket Matches ---\n        const eligibleLosers = allTeams.filter((team)=>(lossCounts[team.id] || 0) === 1 && !tournament.eliminatedTeams.some((t)=>t.id === team.id) && !newlyEliminated.some((t)=>t.id === team.id) && // Exclude winner's bracket final loser if it exists\n            !(tournament.winnersBracketFinalLoser && tournament.winnersBracketFinalLoser.id === team.id));\n        // Find teams recently dropped from winners bracket\n        const justDroppedFromWinners = currentRound.matches.filter((m)=>m.bracket === \"winners\" && m.loser && m.isCompleted).map((m)=>m.loser).filter((loser)=>eligibleLosers.some((t)=>t.id === loser.id));\n        // If this is the winner's bracket final, store the loser for later use\n        if (currentRound.matches.some((m)=>m.bracket === \"winners\" && winnersBracketTeams.length === 1 && m.loser && m.isCompleted)) {\n            // This is a special case - we found the winner's bracket final loser\n            const winnersFinalLoser = currentRound.matches.filter((m)=>m.bracket === \"winners\" && m.isCompleted && m.loser).map((m)=>m.loser).pop();\n            if (winnersFinalLoser && !tournament.eliminatedTeams.some((t)=>t.id === winnersFinalLoser.id)) {\n                tournament.winnersBracketFinalLoser = winnersFinalLoser;\n            }\n        }\n        // Existing losers bracket teams\n        const existingLosers = eligibleLosers.filter((t)=>!justDroppedFromWinners.some((jd)=>jd.id === t.id));\n        // Order: most recent drop(s) first\n        const orderedLosers = [\n            ...justDroppedFromWinners,\n            ...existingLosers\n        ];\n        if (orderedLosers.length > 0) {\n            if (orderedLosers.length % 2 === 1) {\n                // Odd: bye goes to the most recent team dropped from winners bracket\n                let teamWithBye = null;\n                if (justDroppedFromWinners.length > 0) {\n                    teamWithBye = justDroppedFromWinners[justDroppedFromWinners.length - 1];\n                    // Remove the bye team from orderedLosers\n                    const byeIndex = orderedLosers.findIndex((t)=>t.id === teamWithBye.id);\n                    if (byeIndex !== -1) orderedLosers.splice(byeIndex, 1);\n                } else {\n                    // Defensive: fallback to first team if no recent drop\n                    teamWithBye = orderedLosers.shift();\n                }\n                nextRoundMatches.push(createMatch(\"L\".concat(nextRoundNumber, \"-1\"), nextRoundNumber, teamWithBye, null, true, \"losers\"));\n                // Pair the rest\n                for(let i = 0; i < orderedLosers.length; i += 2){\n                    const team1 = orderedLosers[i];\n                    var _orderedLosers_;\n                    const team2 = (_orderedLosers_ = orderedLosers[i + 1]) !== null && _orderedLosers_ !== void 0 ? _orderedLosers_ : null;\n                    nextRoundMatches.push(createMatch(\"L\".concat(nextRoundNumber, \"-\").concat(Math.floor(i / 2) + 2), nextRoundNumber, team1, team2, !team2, \"losers\"));\n                }\n            } else {\n                // Even number: pair all\n                for(let i = 0; i < orderedLosers.length; i += 2){\n                    const team1 = orderedLosers[i];\n                    var _orderedLosers_1;\n                    const team2 = (_orderedLosers_1 = orderedLosers[i + 1]) !== null && _orderedLosers_1 !== void 0 ? _orderedLosers_1 : null;\n                    nextRoundMatches.push(createMatch(\"L\".concat(nextRoundNumber, \"-\").concat(Math.floor(i / 2) + 1), nextRoundNumber, team1, team2, !team2, \"losers\"));\n                }\n            }\n        }\n    }\n    // --- Winner detection logic ---\n    let winner = tournament.winner;\n    if (isChampionshipRound) {\n        // Find the last championship match played\n        const lastChampMatch = championshipMatches[0] || prevChampionshipMatches[prevChampionshipMatches.length - 1];\n        if (lastChampMatch && lastChampMatch.isCompleted && lastChampMatch.winner && lastChampMatch.loser) {\n            const winnersBracketTeam = lastChampMatch.team1;\n            const losersBracketTeam = lastChampMatch.team2;\n            const losersBracketTeamWon = losersBracketTeam && lastChampMatch.winner.id === losersBracketTeam.id;\n            // If loser's bracket team won first championship match, winner's bracket team gets another chance\n            if (losersBracketTeamWon && tournament.championshipMatchesPlayed === 1) {\n                winner = undefined; // No winner yet, need reset match\n            } else {\n                // Either winner's bracket team won first match, or this was the reset match\n                winner = lastChampMatch.winner;\n            }\n        }\n    }\n    // --- INFINITE RECURSION GUARD ---\n    const noMoreMatches = isChampionshipRound && championshipMatches.length === 0 || !isChampionshipRound && nextRoundMatches.length === 0;\n    if (noMoreMatches) {\n        // Tournament is over, do not advance further\n        return {\n            ...tournament,\n            winner,\n            currentRound: tournament.currentRound\n        };\n    }\n    // Debug log before returning the new tournament object\n    (0,_logTournamentState__WEBPACK_IMPORTED_MODULE_0__.logTournamentState)({\n        roundNumber: nextRoundNumber,\n        winnersBracketTeams,\n        losersBracketTeams,\n        matches: isChampionshipRound ? championshipMatches : nextRoundMatches,\n        winnersBracketFinalLoser: tournament.winnersBracketFinalLoser\n    });\n    // Compose the new tournament object\n    return {\n        ...tournament,\n        rounds: [\n            ...tournament.rounds,\n            {\n                roundNumber: nextRoundNumber,\n                matches: isChampionshipRound ? championshipMatches : nextRoundMatches,\n                isDoubleElimination: true,\n                isChampionshipRound\n            }\n        ],\n        currentRound: nextRoundNumber,\n        eliminatedTeams: [\n            ...tournament.eliminatedTeams,\n            ...newlyEliminated.filter((t)=>!tournament.eliminatedTeams.some((et)=>et.id === t.id))\n        ],\n        championshipMatchesPlayed: isChampionshipRound ? tournament.championshipMatchesPlayed + 1 : tournament.championshipMatchesPlayed,\n        winnersBracketFinalLoser: tournament.winnersBracketFinalLoser,\n        winner\n    };\n}; // export const advanceToNextRound = (tournament: Tournament): Tournament => {\n //   const currentRound = tournament.rounds[tournament.rounds.length - 1];\n //   const nextRoundNumber = tournament.currentRound + 1;\n //   // Track all losses across the tournament\n //   const lossCounts: Record<string, number> = {};\n //   tournament.rounds.forEach((round) => {\n //     round.matches.forEach((match) => {\n //       if (match.isCompleted && match.loser) {\n //         lossCounts[match.loser.id] = (lossCounts[match.loser.id] || 0) + 1;\n //       }\n //     });\n //   });\n //   // Gather all teams ever in the tournament\n //   const allTeams: Team[] = [];\n //   const teamIds = new Set<string>();\n //   for (const round of tournament.rounds) {\n //     for (const match of round.matches) {\n //       if (match.team1 && !teamIds.has(match.team1.id)) {\n //         allTeams.push(match.team1);\n //         teamIds.add(match.team1.id);\n //       }\n //       if (match.team2 && !teamIds.has(match.team2.id)) {\n //         allTeams.push(match.team2);\n //         teamIds.add(match.team2.id);\n //       }\n //     }\n //   }\n //   // Identify newly eliminated teams (2 losses)\n //   const newlyEliminated: Team[] = [];\n //   for (const team of allTeams) {\n //     if (\n //       (lossCounts[team.id] || 0) >= 2 &&\n //       !tournament.eliminatedTeams.some((t) => t.id === team.id)\n //     ) {\n //       newlyEliminated.push(team);\n //     }\n //   }\n //   // Winners: teams with 0 losses and not eliminated\n //   const winnersBracketTeams = allTeams.filter(\n //     (team) =>\n //       (lossCounts[team.id] || 0) === 0 &&\n //       !tournament.eliminatedTeams.some((t) => t.id === team.id) &&\n //       !newlyEliminated.some((t) => t.id === team.id)\n //   );\n //   // Losers: teams with 1 loss and not eliminated\n //   const losersBracketTeams = allTeams.filter(\n //     (team) =>\n //       (lossCounts[team.id] || 0) === 1 &&\n //       !tournament.eliminatedTeams.some((t) => t.id === team.id) &&\n //       !newlyEliminated.some((t) => t.id === team.id)\n //   );\n //   let isChampionshipRound = false;\n //   let championshipMatches: Match[] = [];\n //   let nextRoundMatches: Match[] = [];\n //   const prevChampionshipMatches = tournament.rounds\n //     .filter((r) => r.isChampionshipRound)\n //     .flatMap((r) => r.matches)\n //     .filter((m) => m.bracket === \"championship\");\n //   // --- CHAMPIONSHIP LOGIC ---\n //   // Check if a championship match already happened and was completed\n //   if (\n //     prevChampionshipMatches.length >= 1 &&\n //     prevChampionshipMatches[prevChampionshipMatches.length - 1].isCompleted\n //   ) {\n //     const lastChampMatch =\n //       prevChampionshipMatches[prevChampionshipMatches.length - 1];\n //     const winnersBracketTeam = lastChampMatch.team1;\n //     const losersBracketTeam = lastChampMatch.team2;\n //     // If loser's bracket team won the first championship match, winner's bracket team gets another chance\n //     if (\n //       lastChampMatch.winner?.id === losersBracketTeam?.id &&\n //       tournament.championshipMatchesPlayed === 1\n //     ) {\n //       isChampionshipRound = true;\n //       // Create the \"reset\" match\n //       championshipMatches.push(\n //         createMatch(\n //           `C${nextRoundNumber}-1`,\n //           nextRoundNumber,\n //           winnersBracketTeam,\n //           losersBracketTeam,\n //           false,\n //           \"championship\"\n //         )\n //       );\n //     } else {\n //       // Either winner's bracket team won first match, or this was the reset match\n //       isChampionshipRound = true;\n //       // No new matches, winner will be determined in winner detection logic\n //     }\n //   }\n //   // Check if we're ready for the championship match - one team in each bracket and loser's final is complete\n //   else if (\n //     winnersBracketTeams.length === 1 &&\n //     losersBracketTeams.length === 1 &&\n //     currentRound.matches.some(\n //       (m) =>\n //         (m.bracket === \"losers\" || m.id.includes(\"LosersLast\")) &&\n //         m.isCompleted &&\n //         m.winner &&\n //         losersBracketTeams.some((t) => t.id === m.winner!.id)\n //     )\n //   ) {\n //     // Championship match: Winner's bracket champion vs Loser's bracket champion\n //     isChampionshipRound = true;\n //     championshipMatches.push(\n //       createMatch(\n //         `C${nextRoundNumber}-1`,\n //         nextRoundNumber,\n //         winnersBracketTeams[0], // Winner's bracket champion\n //         losersBracketTeams[0], // Loser's bracket champion\n //         false,\n //         \"championship\"\n //       )\n //     );\n //   }\n //   // Check if we have a loser from winner's bracket final waiting to play against loser's bracket winner\n //   else if (\n //     winnersBracketTeams.length === 1 && // We have a winner's bracket champion\n //     losersBracketTeams.length >= 1 && // We have at least one team in loser's bracket\n //     tournament.winnersBracketFinalLoser // We have stored the winner's bracket final loser\n //   ) {\n //     // Find the winner of the loser's bracket\n //     const losersBracketWinner = currentRound.matches\n //       .filter((m) => m.bracket === \"losers\" && m.isCompleted && m.winner)\n //       .map((m) => m.winner!)\n //       .find((winner) => losersBracketTeams.some((t) => t.id === winner.id));\n //     if (\n //       losersBracketWinner &&\n //       losersBracketWinner.id !== tournament.winnersBracketFinalLoser.id\n //     ) {\n //       // Only schedule if they're not the same team!\n //       nextRoundMatches.push(\n //         createMatch(\n //           `LosersLast-${nextRoundNumber}`,\n //           nextRoundNumber,\n //           tournament.winnersBracketFinalLoser,\n //           losersBracketWinner,\n //           false,\n //           \"losers\"\n //         )\n //       );\n //     } else {\n //       // Wait for the losers bracket to resolve properly\n //       createStandardBracketMatches();\n //     }\n //   }\n //   // Check if this is the winner's bracket final (exactly 2 teams in winner's bracket)\n //   else if (winnersBracketTeams.length === 2 && losersBracketTeams.length >= 1) {\n //     // Create the winner's bracket final match\n //     nextRoundMatches.push(\n //       createMatch(\n //         `W${nextRoundNumber}-1`,\n //         nextRoundNumber,\n //         winnersBracketTeams[0],\n //         winnersBracketTeams[1],\n //         false,\n //         \"winners\"\n //       )\n //     );\n //     // Continue with losers bracket matches separately\n //     createLosersBracketMatches();\n //   }\n //   // Otherwise, continue with normal bracket play\n //   else {\n //     createStandardBracketMatches();\n //   }\n //   // Helper function to create standard bracket matches\n //   function createStandardBracketMatches() {\n //     // --- Winners Bracket Matches ---\n //     let matchCounter = 1;\n //     for (let i = 0; i < winnersBracketTeams.length; i += 2) {\n //       const team1 = winnersBracketTeams[i];\n //       const team2 = winnersBracketTeams[i + 1] ?? null;\n //       const isBye = !team2;\n //       nextRoundMatches.push(\n //         createMatch(\n //           `W${nextRoundNumber}-${matchCounter}`,\n //           nextRoundNumber,\n //           team1,\n //           team2,\n //           isBye,\n //           \"winners\"\n //         )\n //       );\n //       matchCounter++;\n //     }\n //     // Create losers bracket matches separately\n //     createLosersBracketMatches();\n //   }\n //   // Helper function to create losers bracket matches\n //   function createLosersBracketMatches() {\n //     // --- Losers Bracket Matches ---\n //     const eligibleLosers = allTeams.filter(\n //       (team) =>\n //         (lossCounts[team.id] || 0) === 1 &&\n //         !tournament.eliminatedTeams.some((t) => t.id === team.id) &&\n //         !newlyEliminated.some((t) => t.id === team.id) &&\n //         // Exclude winner's bracket final loser if it exists but hasn't played yet in losers\n //         !(\n //           tournament.winnersBracketFinalLoser &&\n //           tournament.winnersBracketFinalLoser.id === team.id\n //         )\n //     );\n //     // Find teams recently dropped from winners bracket\n //     const justDroppedFromWinners = currentRound.matches\n //       .filter((m) => m.bracket === \"winners\" && m.loser && m.isCompleted)\n //       .map((m) => m.loser!)\n //       .filter((loser) => eligibleLosers.some((t) => t.id === loser.id));\n //     // If this is the winner's bracket final, store the loser for later use\n //     if (\n //       currentRound.matches.some(\n //         (m) =>\n //           m.bracket === \"winners\" &&\n //           winnersBracketTeams.length === 1 &&\n //           m.loser &&\n //           m.isCompleted\n //       )\n //     ) {\n //       // This is a special case - we found the winner's bracket final loser\n //       const winnersFinalLoser = currentRound.matches\n //         .filter((m) => m.bracket === \"winners\" && m.isCompleted && m.loser)\n //         .map((m) => m.loser!)\n //         .pop();\n //       if (winnersFinalLoser) {\n //         tournament.winnersBracketFinalLoser = winnersFinalLoser;\n //       }\n //     }\n //     // Existing losers bracket teams\n //     const existingLosers = eligibleLosers.filter(\n //       (t) => !justDroppedFromWinners.some((jd) => jd.id === t.id)\n //     );\n //     // Order: most recent drop(s) first\n //     const orderedLosers = [...justDroppedFromWinners, ...existingLosers];\n //     if (orderedLosers.length > 0) {\n //       if (orderedLosers.length % 2 === 1) {\n //         // Odd: bye goes to the most recent team dropped from winners bracket\n //         let teamWithBye: Team | null = null;\n //         if (justDroppedFromWinners.length > 0) {\n //           teamWithBye =\n //             justDroppedFromWinners[justDroppedFromWinners.length - 1];\n //           // Remove the bye team from orderedLosers\n //           const byeIndex = orderedLosers.findIndex(\n //             (t) => t.id === teamWithBye!.id\n //           );\n //           if (byeIndex !== -1) orderedLosers.splice(byeIndex, 1);\n //         } else {\n //           // Defensive: fallback to first team if no recent drop\n //           teamWithBye = orderedLosers.shift()!;\n //         }\n //         nextRoundMatches.push(\n //           createMatch(\n //             `L${nextRoundNumber}-1`,\n //             nextRoundNumber,\n //             teamWithBye,\n //             null,\n //             true,\n //             \"losers\"\n //           )\n //         );\n //         // Pair the rest\n //         for (let i = 0; i < orderedLosers.length; i += 2) {\n //           const team1 = orderedLosers[i];\n //           const team2 = orderedLosers[i + 1] ?? null;\n //           nextRoundMatches.push(\n //             createMatch(\n //               `L${nextRoundNumber}-${Math.floor(i / 2) + 2}`,\n //               nextRoundNumber,\n //               team1,\n //               team2,\n //               !team2,\n //               \"losers\"\n //             )\n //           );\n //         }\n //       } else {\n //         // Even number: pair all\n //         for (let i = 0; i < orderedLosers.length; i += 2) {\n //           const team1 = orderedLosers[i];\n //           const team2 = orderedLosers[i + 1] ?? null;\n //           nextRoundMatches.push(\n //             createMatch(\n //               `L${nextRoundNumber}-${Math.floor(i / 2) + 1}`,\n //               nextRoundNumber,\n //               team1,\n //               team2,\n //               !team2,\n //               \"losers\"\n //             )\n //           );\n //         }\n //       }\n //     }\n //   }\n //   // --- Winner detection logic ---\n //   let winner: Team | undefined = tournament.winner;\n //   if (isChampionshipRound) {\n //     // Find the last championship match played\n //     const lastChampMatch =\n //       championshipMatches[0] ||\n //       prevChampionshipMatches[prevChampionshipMatches.length - 1];\n //     if (\n //       lastChampMatch &&\n //       lastChampMatch.isCompleted &&\n //       lastChampMatch.winner &&\n //       lastChampMatch.loser\n //     ) {\n //       const winnersBracketTeam = lastChampMatch.team1;\n //       const losersBracketTeam = lastChampMatch.team2;\n //       const losersBracketTeamWon =\n //         lastChampMatch.winner.id === losersBracketTeam.id;\n //       // If loser's bracket team won first championship match, winner's bracket team gets another chance\n //       if (losersBracketTeamWon && tournament.championshipMatchesPlayed === 1) {\n //         winner = undefined; // No winner yet, need reset match\n //       } else {\n //         // Either winner's bracket team won first match, or this was the reset match\n //         winner = lastChampMatch.winner;\n //       }\n //     }\n //   }\n //   // --- INFINITE RECURSION GUARD ---\n //   const noMoreMatches =\n //     (isChampionshipRound && championshipMatches.length === 0) ||\n //     (!isChampionshipRound && nextRoundMatches.length === 0);\n //   if (noMoreMatches) {\n //     // Tournament is over, do not advance further\n //     return {\n //       ...tournament,\n //       winner,\n //       currentRound: tournament.currentRound\n //     };\n //   }\n //   // Compose the new tournament object\n //   return {\n //     ...tournament,\n //     rounds: [\n //       ...tournament.rounds,\n //       {\n //         roundNumber: nextRoundNumber,\n //         matches: isChampionshipRound ? championshipMatches : nextRoundMatches,\n //         isDoubleElimination: true,\n //         isChampionshipRound\n //       }\n //     ],\n //     currentRound: nextRoundNumber,\n //     eliminatedTeams: [\n //       ...tournament.eliminatedTeams,\n //       ...newlyEliminated.filter(\n //         (t) => !tournament.eliminatedTeams.some((et) => et.id === t.id)\n //       )\n //     ],\n //     championshipMatchesPlayed: isChampionshipRound\n //       ? tournament.championshipMatchesPlayed + 1\n //       : tournament.championshipMatchesPlayed,\n //     winnersBracketFinalLoser: tournament.winnersBracketFinalLoser,\n //     winner\n //   };\n // };\n // import type { Team } from \"./mlb-teams\";\n // export interface Match {\n //   id: string;\n //   roundNumber: number;\n //   team1: Team | null;\n //   team2: Team | null;\n //   isCompleted: boolean;\n //   isBye?: boolean;\n //   winner?: Team;\n //   loser?: Team;\n //   bracket: \"winners\" | \"losers\" | \"championship\";\n //   score: { team1Score: number; team2Score: number };\n //   nextMatchId?: string;\n //   nextLoserMatchId?: string;\n //   eliminatedLabel?: string; // label for eliminated teams in losers bracket\n //   requiresRematch?: boolean; // indicates if a championship rematch is required\n // }\n // export interface Round {\n //   roundNumber: number;\n //   matches: Match[];\n //   isDoubleElimination: boolean;\n //   isChampionshipRound: boolean;\n // }\n // export interface Tournament {\n //   rounds: Round[];\n //   currentRound: number;\n //   eliminatedTeams: Team[];\n //   championshipMatchesPlayed: number;\n //   winner?: Team;\n //   winnersBracketFinalLoser?: Team; // tracks the winner's bracket final loser for championship rematch logic\n // }\n // export const createMatch = (\n //   id: string,\n //   roundNumber: number,\n //   team1: Team | null,\n //   team2: Team | null,\n //   isBye: boolean = false,\n //   bracket: \"winners\" | \"losers\" | \"championship\" = \"winners\",\n //   nextMatchId?: string,\n //   nextLoserMatchId?: string\n // ): Match => ({\n //   id,\n //   roundNumber,\n //   team1,\n //   team2,\n //   isCompleted: isBye,\n //   isBye,\n //   bracket,\n //   winner: isBye ? (team1 ?? team2 ?? undefined) : undefined,\n //   loser: isBye ? undefined : undefined,\n //   score: { team1Score: 0, team2Score: 0 },\n //   nextMatchId,\n //   nextLoserMatchId,\n //   eliminatedLabel: undefined\n // });\n // export const createInitialRounds = (teams: Team[]): Tournament => {\n //   const numTeams = teams.length;\n //   const matches: Match[] = [];\n //   const numRounds = Math.ceil(Math.log2(numTeams));\n //   const firstRoundMatches = Math.pow(2, numRounds - 1);\n //   let matchCounter = 1;\n //   for (let i = 0; i < firstRoundMatches; i++) {\n //     const team1 = teams[i * 2] || null;\n //     const team2 = teams[i * 2 + 1] || null;\n //     const isBye = !team1 || !team2;\n //     const matchId = `W1-${matchCounter}`;\n //     const nextMatchId = `W2-${Math.ceil(matchCounter / 2)}`;\n //     const nextLoserMatchId = `L1-${Math.ceil(matchCounter / 2)}`;\n //     matches.push(\n //       createMatch(\n //         matchId,\n //         1,\n //         team1,\n //         team2,\n //         isBye,\n //         \"winners\",\n //         nextMatchId,\n //         nextLoserMatchId\n //       )\n //     );\n //     matchCounter++;\n //   }\n //   return {\n //     rounds: [\n //       {\n //         roundNumber: 1,\n //         matches,\n //         isDoubleElimination: true,\n //         isChampionshipRound: false\n //       }\n //     ],\n //     currentRound: 1,\n //     eliminatedTeams: [],\n //     championshipMatchesPlayed: 0\n //   };\n // };\n // export const updateMatchScore = (\n //   match: Match,\n //   newScore: { team1Score: number; team2Score: number }\n // ): Match => {\n //   // Mark match as completed if both teams have a score entered (even if scores are equal)\n //   const isCompleted =\n //     typeof newScore.team1Score === \"number\" &&\n //     typeof newScore.team2Score === \"number\" &&\n //     (!isNaN(newScore.team1Score) && !isNaN(newScore.team2Score));\n //   let winner: Team | undefined = undefined;\n //   let loser: Team | undefined = undefined;\n //   if (isCompleted) {\n //     if (newScore.team1Score > newScore.team2Score) {\n //       winner = match.team1 ? { ...match.team1, wins: (match.team1.wins ?? 0) + 1, losses: match.team1.losses ?? 0 } : undefined;\n //       loser = match.team2 ? { ...match.team2, wins: match.team2.wins ?? 0, losses: (match.team2.losses ?? 0) + 1 } : undefined;\n //     } else {\n //       winner = match.team2 ? { ...match.team2, wins: (match.team2.wins ?? 0) + 1, losses: match.team2.losses ?? 0 } : undefined;\n //       loser = match.team1 ? { ...match.team1, wins: match.team1.wins ?? 0, losses: (match.team1.losses ?? 0) + 1 } : undefined;\n //     }\n //   }\n //   return {\n //     ...match,\n //     score: newScore,\n //     isCompleted,\n //     winner,\n //     loser\n //   };\n // };\n // // Helper to deduplicate teams by ID\n // function dedupeTeams(teams: Team[]): Team[] {\n //   const seen = new Set<string>();\n //   return teams.filter(team => {\n //     if (!team) return false;\n //     if (seen.has(team.id)) return false;\n //     seen.add(team.id);\n //     return true;\n //   });\n // }\n // // Helper: get all teams with exactly N losses\n // function teamsWithLosses(lossCounts: Record<string, number>, n: number): string[] {\n //   return Object.keys(lossCounts).filter(teamId => lossCounts[teamId] === n);\n // }\n // export const advanceToNextRound = (tournament: Tournament): Tournament => {\n //   const currentRound = tournament.rounds[tournament.rounds.length - 1];\n //   const nextRoundNumber = tournament.currentRound + 1;\n //   // Track all losses and wins across the tournament\n //   const lossCounts: Record<string, number> = {};\n //   const winsCounts: Record<string, number> = {};\n //   tournament.rounds.forEach((round) => {\n //     round.matches.forEach((match) => {\n //       if (match.isCompleted && match.loser) {\n //         lossCounts[match.loser.id] = (lossCounts[match.loser.id] || 0) + 1;\n //       }\n //       if (match.isCompleted && match.winner) {\n //         winsCounts[match.winner.id] = (winsCounts[match.winner.id] || 0) + 1;\n //       }\n //     });\n //   });\n //   // Gather all teams ever in the tournament, attaching wins\n //   const allTeams: Team[] = [];\n //   const teamIds = new Set<string>();\n //   for (const round of tournament.rounds) {\n //     for (const match of round.matches) {\n //       if (match.team1 && !teamIds.has(match.team1.id)) {\n //         allTeams.push({\n //           ...match.team1,\n //           wins: winsCounts[match.team1.id] || 0,\n //           losses: lossCounts[match.team1.id] || 0\n //         });\n //         teamIds.add(match.team1.id);\n //       }\n //       if (match.team2 && !teamIds.has(match.team2.id)) {\n //         allTeams.push({\n //           ...match.team2,\n //           wins: winsCounts[match.team2.id] || 0,\n //           losses: lossCounts[match.team2.id] || 0\n //         });\n //         teamIds.add(match.team2.id);\n //       }\n //     }\n //   }\n //   // Identify newly eliminated teams (2 losses)\n //   const newlyEliminated: Team[] = [];\n //   for (const team of allTeams) {\n //     if (\n //       (lossCounts[team.id] || 0) >= 2 &&\n //       !tournament.eliminatedTeams.some((t) => t.id === team.id)\n //     ) {\n //       newlyEliminated.push(team);\n //     }\n //   }\n //   // Winners: teams with 0 losses and not eliminated\n //   const winnersBracketTeams = allTeams\n //     .filter(\n //       (team) =>\n //         (lossCounts[team.id] || 0) === 0 &&\n //         !tournament.eliminatedTeams.some((t) => t.id === team.id) &&\n //         !newlyEliminated.some((t) => t.id === team.id) &&\n //         !team.id.startsWith('tbd-') // Exclude any phantom TBD teams\n //     )\n //     .map((team) => ({ ...team, losses: lossCounts[team.id] || 0, wins: winsCounts[team.id] || 0 }));\n //   // Losers: teams with 1 loss and not eliminated\n //   const losersBracketTeams = allTeams\n //     .filter(\n //       (team) =>\n //         (lossCounts[team.id] || 0) === 1 &&\n //         !tournament.eliminatedTeams.some((t) => t.id === team.id) &&\n //         !newlyEliminated.some((t) => t.id === team.id)\n //     )\n //     .map((team) => ({\n //       ...team,\n //       losses: lossCounts[team.id] || 0,\n //       wins: winsCounts[team.id] || 0\n //     }));\n //   let isChampionshipRound = false;\n //   let championshipMatches: Match[] = [];\n //   let nextRoundMatches: Match[] = [];\n //   const prevChampionshipMatches = tournament.rounds\n //     .filter((r) => r.isChampionshipRound)\n //     .flatMap((r) => r.matches)\n //     .filter((m) => m.bracket === \"championship\");\n //   // --- CHAMPIONSHIP LOGIC ---\n //   // Check if a championship match already happened and was completed\n //   if (\n //     prevChampionshipMatches.length >= 1 &&\n //     prevChampionshipMatches[prevChampionshipMatches.length - 1].isCompleted\n //   ) {\n //     const lastChampMatch =\n //       prevChampionshipMatches[prevChampionshipMatches.length - 1];\n //     const winnersBracketTeam = lastChampMatch.team1;\n //     const losersBracketTeam = lastChampMatch.team2;\n //     // If loser's bracket team won the first championship match, winner's bracket team gets another chance\n //     if (\n //       lastChampMatch.winner?.id === losersBracketTeam?.id &&\n //       tournament.championshipMatchesPlayed === 1\n //     ) {\n //       isChampionshipRound = true;\n //       // Create the \"reset\" match with requiresRematch: true\n //       championshipMatches.push({\n //         ...createMatch(\n //           `C${nextRoundNumber}-1`,\n //           nextRoundNumber,\n //           winnersBracketTeam,\n //           losersBracketTeam,\n //           false,\n //           \"championship\"\n //         ),\n //         requiresRematch: true\n //       });\n //       // Increment the winner's bracket team's loss count for the record\n //       if (winnersBracketTeam && typeof winnersBracketTeam.losses === \"number\") {\n //         winnersBracketTeam.losses += 1;\n //       }\n //     } else {\n //       // Either winner's bracket team won first match, or this was the reset match\n //       isChampionshipRound = true;\n //       // No new matches, winner will be determined in winner detection logic\n //     }\n //   }\n //   // Check if we're ready for the championship match - one team in each bracket and loser's final is complete\n //   else if (\n //     winnersBracketTeams.length === 1 &&\n //     // If ANY losers bracket match in the current round is incomplete, show waiting cards\n //     currentRound.matches.some(\n //       (m) =>\n //         (m.bracket === \"losers\" || m.id.includes(\"LosersLast\")) &&\n //         !m.isCompleted\n //     )\n //   ) {\n //     // Not ready for championship: show waiting cards for both\n //     nextRoundMatches.push(\n //       createMatch(\n //         `W${nextRoundNumber}-waiting`,\n //         nextRoundNumber,\n //         winnersBracketTeams[0],\n //         {\n //           id: `tbd-${nextRoundNumber}-waiting`,\n //           name: \"TBD\",\n //           city: \"\",\n //           losses: 0\n //         },\n //         true,\n //         \"winners\"\n //       )\n //     );\n //     if (tournament.winnersBracketFinalLoser) {\n //       nextRoundMatches.push(\n //         createMatch(\n //           `LosersLast-${nextRoundNumber}`,\n //           nextRoundNumber,\n //           tournament.winnersBracketFinalLoser,\n //           {\n //             id: `tbd-losers-${nextRoundNumber}`,\n //             name: \"TBD\",\n //             city: \"\",\n //             losses: 0\n //           },\n //           true,\n //           \"losers\"\n //         )\n //       );\n //     }\n //     logTournamentState({\n //       roundNumber: nextRoundNumber,\n //       winnersBracketTeams,\n //       losersBracketTeams,\n //       matches: nextRoundMatches,\n //       winnersBracketFinalLoser: tournament.winnersBracketFinalLoser\n //     });\n //     createLosersBracketMatches();\n //   }\n //   // Check if we have a loser from winner's bracket final waiting to play against loser's bracket winner\n //   else if (\n //     winnersBracketTeams.length === 1 &&\n //     tournament.winnersBracketFinalLoser\n //   ) {\n //     // Always show the waiting card for the losers bracket final loser, even if the opponent is TBD\n //     let losersBracketWinner = null;\n //     if (losersBracketTeams.length >= 1) {\n //       losersBracketWinner = currentRound.matches\n //         .filter((m) => m.bracket === \"losers\" && m.isCompleted && m.winner)\n //         .map((m) => m.winner!)\n //         .find((winner) => losersBracketTeams.some((t) => t.id === winner.id));\n //     }\n //     const opponent =\n //       losersBracketWinner &&\n //       losersBracketWinner.id !== tournament.winnersBracketFinalLoser.id\n //         ? losersBracketWinner\n //         : {\n //             id: `tbd-losers-${nextRoundNumber}`,\n //             name: \"TBD\",\n //             city: \"\",\n //             losses: 0\n //           };\n //     const isBye =\n //       !losersBracketWinner ||\n //       losersBracketWinner.id === tournament.winnersBracketFinalLoser.id;\n //     nextRoundMatches.push(\n //       createMatch(\n //         `LosersLast-${nextRoundNumber}`,\n //         nextRoundNumber,\n //         tournament.winnersBracketFinalLoser,\n //         opponent,\n //         isBye,\n //         \"losers\"\n //       )\n //     );\n //     // Always render the winners bracket champion as a non-scoreable waiting card if the losers bracket is not resolved\n //     nextRoundMatches.push(\n //       createMatch(\n //         `W${nextRoundNumber}-waiting`,\n //         nextRoundNumber,\n //         winnersBracketTeams[0],\n //         {\n //           id: `tbd-${nextRoundNumber}-waiting`,\n //           name: \"TBD\",\n //           city: \"\",\n //           losses: 0\n //         },\n //         true, // isBye: true to ensure it's not scoreable\n //         \"winners\"\n //       )\n //     );\n //     createLosersBracketMatches();\n //   }\n //   // Otherwise, continue with normal bracket play\n //   else {\n //     // If only one team in winners and losers bracket is not resolved, always show waiting cards\n //     if (winnersBracketTeams.length === 1 && losersBracketTeams.length >= 1) {\n //       nextRoundMatches.push(\n //         createMatch(\n //           `W${nextRoundNumber}-waiting`,\n //           nextRoundNumber,\n //           winnersBracketTeams[0],\n //           {\n //             id: `tbd-${nextRoundNumber}-waiting`,\n //             name: \"TBD\",\n //             city: \"\",\n //             losses: 0\n //           },\n //           true,\n //           \"winners\"\n //         )\n //       );\n //       if (tournament.winnersBracketFinalLoser) {\n //         nextRoundMatches.push(\n //           createMatch(\n //             `LosersLast-${nextRoundNumber}`,\n //             nextRoundNumber,\n //             tournament.winnersBracketFinalLoser,\n //             {\n //               id: `tbd-losers-${nextRoundNumber}`,\n //               name: \"TBD\",\n //               city: \"\",\n //               losses: 0\n //             },\n //             true,\n //             \"losers\"\n //           )\n //         );\n //       }\n //     }\n //   }\n //   // Helper function to create standard bracket matches\n //   function createStandardBracketMatches() {\n //     // --- Winners Bracket Matches ---\n //     let matchCounter = 1;\n //     for (let i = 0; i < winnersBracketTeams.length; i += 2) {\n //       const team1 = winnersBracketTeams[i];\n //       const team2 = winnersBracketTeams[i + 1] ?? null;\n //       const isBye = !team2;\n //       nextRoundMatches.push(\n //         createMatch(\n //           `W${nextRoundNumber}-${matchCounter}`,\n //           nextRoundNumber,\n //           team1,\n //           team2,\n //           isBye,\n //           \"winners\"\n //         )\n //       );\n //       matchCounter++;\n //     }\n //     // Create losers bracket matches separately\n //     createLosersBracketMatches();\n //   }\n //   // Helper function to create losers bracket matches\n //   function createLosersBracketMatches() {\n //     // --- Losers Bracket Matches ---\n //     const eligibleLosers = allTeams.filter(\n //       (team) =>\n //         (lossCounts[team.id] || 0) === 1 &&\n //         !tournament.eliminatedTeams.some((t) => t.id === team.id) &&\n //         !newlyEliminated.some((t) => t.id === team.id) &&\n //         // Exclude winner's bracket final loser if it exists but hasn't played yet in losers\n //         !(\n //           tournament.winnersBracketFinalLoser &&\n //           tournament.winnersBracketFinalLoser.id === team.id\n //         )\n //     );\n //     // Find teams recently dropped from winners bracket\n //     const justDroppedFromWinners = currentRound.matches\n //       .filter((m) => m.bracket === \"winners\" && m.loser && m.isCompleted)\n //       .map((m) => m.loser!)\n //       .filter((loser) => eligibleLosers.some((t) => t.id === loser.id));\n //     // If this is the winner's bracket final, store the loser for later use\n //     if (\n //       currentRound.matches.some(\n //         (m) =>\n //           m.bracket === \"winners\" &&\n //           winnersBracketTeams.length === 1 &&\n //           m.loser &&\n //           m.isCompleted\n //       )\n //     ) {\n //       // This is a special case - we found the winner's bracket final loser\n //       const winnersFinalLoser = currentRound.matches\n //         .filter((m) => m.bracket === \"winners\" && m.isCompleted && m.loser)\n //         .map((m) => m.loser!)\n //         .pop();\n //       if (winnersFinalLoser) {\n //         tournament.winnersBracketFinalLoser = winnersFinalLoser;\n //       }\n //     }\n //     // Existing losers bracket teams\n //     const existingLosers = eligibleLosers.filter(\n //       (t) => !justDroppedFromWinners.some((jd) => jd.id === t.id)\n //     );\n //     // Order: most recent drop(s) first\n //     const orderedLosers = [...justDroppedFromWinners, ...existingLosers];\n //     if (orderedLosers.length > 0) {\n //       if (orderedLosers.length % 2 === 1) {\n //         // Odd: bye goes to the most recent team dropped from winners bracket\n //         let teamWithBye: Team | null = null;\n //         if (justDroppedFromWinners.length > 0) {\n //           teamWithBye =\n //             justDroppedFromWinners[justDroppedFromWinners.length - 1];\n //           // Remove the bye team from orderedLosers\n //           const byeIndex = orderedLosers.findIndex(\n //             (t) => t.id === teamWithBye!.id\n //           );\n //           if (byeIndex !== -1) orderedLosers.splice(byeIndex, 1);\n //         } else {\n //           // Defensive: fallback to first team if no recent drop\n //           teamWithBye = orderedLosers.shift()!;\n //         }\n //         nextRoundMatches.push(\n //           createMatch(\n //             `L${nextRoundNumber}-1`,\n //             nextRoundNumber,\n //             teamWithBye,\n //             null,\n //             true,\n //             \"losers\"\n //           )\n //         );\n //         // Pair the rest\n //         for (let i = 0; i < orderedLosers.length; i += 2) {\n //           const team1 = orderedLosers[i];\n //           const team2 = orderedLosers[i + 1] ?? null;\n //           nextRoundMatches.push(\n //             createMatch(\n //               `L${nextRoundNumber}-${Math.floor(i / 2) + 2}`,\n //               nextRoundNumber,\n //               team1,\n //               team2,\n //               !team2,\n //               \"losers\"\n //             )\n //           );\n //         }\n //       } else {\n //         // Even number: pair all\n //         for (let i = 0; i < orderedLosers.length; i += 2) {\n //           const team1 = orderedLosers[i];\n //           const team2 = orderedLosers[i + 1] ?? null;\n //           nextRoundMatches.push(\n //             createMatch(\n //               `L${nextRoundNumber}-${Math.floor(i / 2) + 1}`,\n //               nextRoundNumber,\n //               team1,\n //               team2,\n //               !team2,\n //               \"losers\"\n //             )\n //           );\n //         }\n //       }\n //     }\n //   }\n //   // --- Winner detection logic ---\n //   let winner: Team | undefined = tournament.winner;\n //   if (isChampionshipRound) {\n //     // Find the last championship match played\n //     const lastChampMatch =\n //       championshipMatches[0] ||\n //       prevChampionshipMatches[prevChampionshipMatches.length - 1];\n //     if (\n //       lastChampMatch &&\n //       lastChampMatch.isCompleted &&\n //       lastChampMatch.winner &&\n //       lastChampMatch.loser\n //     ) {\n //       const winnersBracketTeam = lastChampMatch.team1;\n //       const losersBracketTeam = lastChampMatch.team2;\n //       const losersBracketTeamWon =\n //         losersBracketTeam && lastChampMatch.winner.id === losersBracketTeam.id;\n //       // If loser's bracket team won first championship match, winner's bracket team gets another chance\n //       if (losersBracketTeamWon && tournament.championshipMatchesPlayed === 1) {\n //         // Do NOT increment the winner's bracket team's loss count or set winner yet\n //         // Wait for the rematch to be played\n //         winner = undefined; // No winner yet, need reset match\n //       } else if (\n //         lastChampMatch.requiresRematch &&\n //         !lastChampMatch.isCompleted\n //       ) {\n //         // If the rematch is required but not completed, do not set winner or increment losses\n //         winner = undefined;\n //       } else {\n //         // If this is the rematch and it's completed, increment loss for winner's bracket team ONLY IF they lose again\n //         if (\n //           lastChampMatch.requiresRematch &&\n //           lastChampMatch.isCompleted &&\n //           winnersBracketTeam &&\n //           lastChampMatch.winner.id !== winnersBracketTeam.id &&\n //           typeof winnersBracketTeam.losses === \"number\"\n //         ) {\n //           winnersBracketTeam.losses += 1;\n //         }\n //         winner = lastChampMatch.winner;\n //       }\n //     }\n //   }\n //   // --- INFINITE RECURSION GUARD ---\n //   const noMoreMatches =\n //     (isChampionshipRound && championshipMatches.length === 0) ||\n //     (!isChampionshipRound && nextRoundMatches.length === 0);\n //   if (noMoreMatches) {\n //     // Tournament is over, do not advance further\n //     return {\n //       ...tournament,\n //       winner,\n //       currentRound: tournament.currentRound\n //     };\n //   }\n //   // <--- PLACE THE DEBUG CALL HERE, just before returning the new tournament object!\n //   logTournamentState({\n //     roundNumber: nextRoundNumber,\n //     winnersBracketTeams,\n //     losersBracketTeams,\n //     matches: isChampionshipRound ? championshipMatches : nextRoundMatches,\n //     winnersBracketFinalLoser: tournament.winnersBracketFinalLoser\n //   });\n //   // Compose the new tournament object\n //   return {\n //     ...tournament,\n //     rounds: [\n //       ...tournament.rounds,\n //       {\n //         roundNumber: nextRoundNumber,\n //         matches: isChampionshipRound ? championshipMatches : nextRoundMatches,\n //         isDoubleElimination: true,\n //         isChampionshipRound\n //       }\n //     ],\n //     currentRound: nextRoundNumber,\n //     eliminatedTeams: [\n //       ...tournament.eliminatedTeams,\n //       ...newlyEliminated.filter(\n //         (t) => !tournament.eliminatedTeams.some((et) => et.id === t.id)\n //       )\n //     ],\n //     championshipMatchesPlayed: isChampionshipRound\n //       ? tournament.championshipMatchesPlayed + 1\n //       : tournament.championshipMatchesPlayed,\n //     winnersBracketFinalLoser: tournament.winnersBracketFinalLoser,\n //     winner\n //   };\n // };\n // function logTournamentState({\n //   roundNumber,\n //   winnersBracketTeams,\n //   losersBracketTeams,\n //   matches,\n //   winnersBracketFinalLoser\n // }: {\n //   roundNumber: number,\n //   winnersBracketTeams: any[],\n //   losersBracketTeams: any[],\n //   matches: any[],\n //   winnersBracketFinalLoser: any\n // }) {\n //   // eslint-disable-next-line no-console\n //   console.log('--- TOURNAMENT DEBUG ---');\n //   console.log('Round:', roundNumber);\n //   console.log('Winners Bracket Teams:', winnersBracketTeams.map(t => `${t.name} (${t.id})`).join(', '));\n //   console.log('Losers Bracket Teams:', losersBracketTeams.map(t => `${t.name} (${t.id})`).join(', '));\n //   console.log('Matches:');\n //   matches.forEach(m =>\n //     console.log(`  [${m.bracket}] ${m.team1?.name ?? 'TBD'} vs ${m.team2?.name ?? 'TBD'} | isCompleted: ${m.isCompleted} | isBye: ${m.isBye}`)\n //   );\n //   if (winnersBracketFinalLoser) {\n //     console.log('Winners Bracket Final Loser:', winnersBracketFinalLoser.name, winnersBracketFinalLoser.id);\n //   }\n //   console.log('------------------------');\n // }\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3R5cGVzL3RvdXJuYW1lbnQvbWF0Y2hlcy50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUMwRDtBQW1DbkQsTUFBTUMsY0FBYyxTQUN6QkMsSUFDQUMsYUFDQUMsT0FDQUM7UUFDQUMseUVBQWlCLE9BQ2pCQywyRUFBaUQsV0FDakRDLDREQUNBQztRQVNpQkw7V0FSTjtRQUNYRjtRQUNBQztRQUNBQztRQUNBQztRQUNBSyxhQUFhSjtRQUNiQTtRQUNBQztRQUNBSSxRQUFRTCxRQUFTRixDQUFBQSxPQUFBQSxrQkFBQUEsbUJBQUFBLFFBQVNDLG1CQUFURCxrQkFBQUEsT0FBa0JRLFlBQWFBO1FBQ2hEQyxPQUFPUCxRQUFRTSxZQUFZQTtRQUMzQkUsT0FBTztZQUFFQyxZQUFZO1lBQUdDLFlBQVk7UUFBRTtRQUN0Q1I7UUFDQUM7UUFDQVEsaUJBQWlCTDtJQUNuQjtBQUFBLEVBQUc7QUFFSSxNQUFNTSxzQkFBc0IsQ0FBQ0M7SUFDbEMsTUFBTUMsV0FBV0QsTUFBTUUsTUFBTTtJQUM3QixNQUFNQyxVQUFtQixFQUFFO0lBQzNCLE1BQU1DLFlBQVlDLEtBQUtDLElBQUksQ0FBQ0QsS0FBS0UsSUFBSSxDQUFDTjtJQUV0QyxNQUFNTyxvQkFBb0JILEtBQUtJLEdBQUcsQ0FBQyxHQUFHTCxZQUFZO0lBQ2xELElBQUlNLGVBQWU7SUFFbkIsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlILG1CQUFtQkcsSUFBSztRQUMxQyxNQUFNMUIsUUFBUWUsS0FBSyxDQUFDVyxJQUFJLEVBQUUsSUFBSTtRQUM5QixNQUFNekIsUUFBUWMsS0FBSyxDQUFDVyxJQUFJLElBQUksRUFBRSxJQUFJO1FBQ2xDLE1BQU14QixRQUFRLENBQUNGLFNBQVMsQ0FBQ0M7UUFFekIsTUFBTTBCLFVBQVUsTUFBbUIsT0FBYkY7UUFDdEIsTUFBTXJCLGNBQWMsTUFBa0MsT0FBNUJnQixLQUFLQyxJQUFJLENBQUNJLGVBQWU7UUFDbkQsTUFBTXBCLG1CQUFtQixN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Qiw4Q0FBOEM7Q0FDOUMsU0FBUztDQUNULE1BQU07Q0FDTix3RkFBd0Y7Q0FDeEYseUJBQXlCO0NBQ3pCLG9DQUFvQztDQUNwQywyQkFBMkI7Q0FDM0IsMEJBQTBCO0NBQzFCLDZFQUE2RTtDQUM3RSxvRUFBb0U7Q0FDcEUsUUFBUTtDQUVSLHlDQUF5QztDQUN6QyxhQUFhO0NBQ2IscUJBQXFCO0NBQ3JCLGdCQUFnQjtDQUNoQiw4QkFBOEI7Q0FDOUIsVUFBVTtDQUNWLHdDQUF3QztDQUN4QyxpRkFBaUY7Q0FDakYscUNBQXFDO0NBQ3JDLDhCQUE4QjtDQUM5QixVQUFVO0NBQ1YsU0FBUztDQUNULHFDQUFxQztDQUNyQyx5QkFBeUI7Q0FDekIsdUNBQXVDO0NBQ3ZDLG1DQUFtQztDQUNuQywwRUFBMEU7Q0FDMUUsVUFBVTtDQUNWLFNBQVM7Q0FDVCxxREFBcUQ7Q0FDckQsbURBQW1EO0NBQ25ELGdEQUFnRDtDQUNoRCxxRUFBcUU7Q0FDckUsYUFBYTtDQUNiLE9BQU87Q0FDUCxLQUFLO0NBRUwsZ0NBQWdDO0NBQ2hDLGlCQUFpQjtDQUNqQix5QkFBeUI7Q0FDekIsd0JBQXdCO0NBQ3hCLGFBQWE7Q0FDYiw2QkFBNkI7Q0FDN0IsT0FBTztDQUNQLHlCQUF5QjtDQUN6QixnQ0FBZ0M7Q0FDaEMsK0JBQStCO0NBQy9CLG9CQUFvQjtDQUNwQixrQ0FBa0M7Q0FDbEMsT0FBTztDQUNQLDJDQUEyQztDQUMzQyw2Q0FBNkM7Q0FDN0Msd0NBQXdDO0NBQ3hDLDJHQUEyRztDQUMzRyx5R0FBeUc7Q0FDekcsNkJBQTZCO0NBQzdCLHlCQUF5QjtDQUN6QixpSkFBaUo7Q0FDakosT0FBTztDQUNQLG9DQUFvQztDQUNwQywrR0FBK0c7Q0FDL0csTUFBTTtDQUNOLDZDQUE2QztDQUM3QyxJQUFJIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3R5cGVzL3RvdXJuYW1lbnQvbWF0Y2hlcy50cz9kYTIyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0eXBlIHsgVGVhbSB9IGZyb20gXCIuL21sYi10ZWFtc1wiO1xuaW1wb3J0IHsgbG9nVG91cm5hbWVudFN0YXRlIH0gZnJvbSBcIi4vbG9nVG91cm5hbWVudFN0YXRlXCI7XG5cbmV4cG9ydCBpbnRlcmZhY2UgTWF0Y2gge1xuICBpZDogc3RyaW5nO1xuICByb3VuZE51bWJlcjogbnVtYmVyO1xuICB0ZWFtMTogVGVhbSB8IG51bGw7XG4gIHRlYW0yOiBUZWFtIHwgbnVsbDtcbiAgaXNDb21wbGV0ZWQ6IGJvb2xlYW47XG4gIGlzQnllPzogYm9vbGVhbjtcbiAgd2lubmVyPzogVGVhbTtcbiAgbG9zZXI/OiBUZWFtO1xuICBicmFja2V0OiBcIndpbm5lcnNcIiB8IFwibG9zZXJzXCIgfCBcImNoYW1waW9uc2hpcFwiO1xuICBzY29yZTogeyB0ZWFtMVNjb3JlOiBudW1iZXI7IHRlYW0yU2NvcmU6IG51bWJlciB9O1xuICBuZXh0TWF0Y2hJZD86IHN0cmluZztcbiAgbmV4dExvc2VyTWF0Y2hJZD86IHN0cmluZztcbiAgZWxpbWluYXRlZExhYmVsPzogc3RyaW5nOyAvLyBsYWJlbCBmb3IgZWxpbWluYXRlZCB0ZWFtcyBpbiBsb3NlcnMgYnJhY2tldFxuICByZXF1aXJlc1JlbWF0Y2g/OiBib29sZWFuOyAvLyBpbmRpY2F0ZXMgaWYgYSBjaGFtcGlvbnNoaXAgcmVtYXRjaCBpcyByZXF1aXJlZFxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFJvdW5kIHtcbiAgcm91bmROdW1iZXI6IG51bWJlcjtcbiAgbWF0Y2hlczogTWF0Y2hbXTtcbiAgaXNEb3VibGVFbGltaW5hdGlvbjogYm9vbGVhbjtcbiAgaXNDaGFtcGlvbnNoaXBSb3VuZDogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBUb3VybmFtZW50IHtcbiAgcm91bmRzOiBSb3VuZFtdO1xuICBjdXJyZW50Um91bmQ6IG51bWJlcjtcbiAgZWxpbWluYXRlZFRlYW1zOiBUZWFtW107XG4gIGNoYW1waW9uc2hpcE1hdGNoZXNQbGF5ZWQ6IG51bWJlcjtcbiAgd2lubmVyPzogVGVhbTtcbiAgd2lubmVyc0JyYWNrZXRGaW5hbExvc2VyPzogVGVhbTsgLy8gdHJhY2tzIHRoZSB3aW5uZXIncyBicmFja2V0IGZpbmFsIGxvc2VyIGZvciBjaGFtcGlvbnNoaXAgcmVtYXRjaCBsb2dpY1xufVxuXG5leHBvcnQgY29uc3QgY3JlYXRlTWF0Y2ggPSAoXG4gIGlkOiBzdHJpbmcsXG4gIHJvdW5kTnVtYmVyOiBudW1iZXIsXG4gIHRlYW0xOiBUZWFtIHwgbnVsbCxcbiAgdGVhbTI6IFRlYW0gfCBudWxsLFxuICBpc0J5ZTogYm9vbGVhbiA9IGZhbHNlLFxuICBicmFja2V0OiBcIndpbm5lcnNcIiB8IFwibG9zZXJzXCIgfCBcImNoYW1waW9uc2hpcFwiID0gXCJ3aW5uZXJzXCIsXG4gIG5leHRNYXRjaElkPzogc3RyaW5nLFxuICBuZXh0TG9zZXJNYXRjaElkPzogc3RyaW5nXG4pOiBNYXRjaCA9PiAoe1xuICBpZCxcbiAgcm91bmROdW1iZXIsXG4gIHRlYW0xLFxuICB0ZWFtMixcbiAgaXNDb21wbGV0ZWQ6IGlzQnllLFxuICBpc0J5ZSxcbiAgYnJhY2tldCxcbiAgd2lubmVyOiBpc0J5ZSA/ICh0ZWFtMSA/PyB0ZWFtMiA/PyB1bmRlZmluZWQpIDogdW5kZWZpbmVkLFxuICBsb3NlcjogaXNCeWUgPyB1bmRlZmluZWQgOiB1bmRlZmluZWQsXG4gIHNjb3JlOiB7IHRlYW0xU2NvcmU6IDAsIHRlYW0yU2NvcmU6IDAgfSxcbiAgbmV4dE1hdGNoSWQsXG4gIG5leHRMb3Nlck1hdGNoSWQsXG4gIGVsaW1pbmF0ZWRMYWJlbDogdW5kZWZpbmVkXG59KTtcblxuZXhwb3J0IGNvbnN0IGNyZWF0ZUluaXRpYWxSb3VuZHMgPSAodGVhbXM6IFRlYW1bXSk6IFRvdXJuYW1lbnQgPT4ge1xuICBjb25zdCBudW1UZWFtcyA9IHRlYW1zLmxlbmd0aDtcbiAgY29uc3QgbWF0Y2hlczogTWF0Y2hbXSA9IFtdO1xuICBjb25zdCBudW1Sb3VuZHMgPSBNYXRoLmNlaWwoTWF0aC5sb2cyKG51bVRlYW1zKSk7XG5cbiAgY29uc3QgZmlyc3RSb3VuZE1hdGNoZXMgPSBNYXRoLnBvdygyLCBudW1Sb3VuZHMgLSAxKTtcbiAgbGV0IG1hdGNoQ291bnRlciA9IDE7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBmaXJzdFJvdW5kTWF0Y2hlczsgaSsrKSB7XG4gICAgY29uc3QgdGVhbTEgPSB0ZWFtc1tpICogMl0gfHwgbnVsbDtcbiAgICBjb25zdCB0ZWFtMiA9IHRlYW1zW2kgKiAyICsgMV0gfHwgbnVsbDtcbiAgICBjb25zdCBpc0J5ZSA9ICF0ZWFtMSB8fCAhdGVhbTI7XG5cbiAgICBjb25zdCBtYXRjaElkID0gYFcxLSR7bWF0Y2hDb3VudGVyfWA7XG4gICAgY29uc3QgbmV4dE1hdGNoSWQgPSBgVzItJHtNYXRoLmNlaWwobWF0Y2hDb3VudGVyIC8gMil9YDtcbiAgICBjb25zdCBuZXh0TG9zZXJNYXRjaElkID0gYEwxLSR7TWF0aC5jZWlsKG1hdGNoQ291bnRlciAvIDIpfWA7XG5cbiAgICBtYXRjaGVzLnB1c2goXG4gICAgICBjcmVhdGVNYXRjaChcbiAgICAgICAgbWF0Y2hJZCxcbiAgICAgICAgMSxcbiAgICAgICAgdGVhbTEsXG4gICAgICAgIHRlYW0yLFxuICAgICAgICBpc0J5ZSxcbiAgICAgICAgXCJ3aW5uZXJzXCIsXG4gICAgICAgIG5leHRNYXRjaElkLFxuICAgICAgICBuZXh0TG9zZXJNYXRjaElkXG4gICAgICApXG4gICAgKTtcbiAgICBtYXRjaENvdW50ZXIrKztcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgcm91bmRzOiBbXG4gICAgICB7XG4gICAgICAgIHJvdW5kTnVtYmVyOiAxLFxuICAgICAgICBtYXRjaGVzLFxuICAgICAgICBpc0RvdWJsZUVsaW1pbmF0aW9uOiB0cnVlLFxuICAgICAgICBpc0NoYW1waW9uc2hpcFJvdW5kOiBmYWxzZVxuICAgICAgfVxuICAgIF0sXG4gICAgY3VycmVudFJvdW5kOiAxLFxuICAgIGVsaW1pbmF0ZWRUZWFtczogW10sXG4gICAgY2hhbXBpb25zaGlwTWF0Y2hlc1BsYXllZDogMFxuICB9O1xufTtcblxuZXhwb3J0IGNvbnN0IHVwZGF0ZU1hdGNoU2NvcmUgPSAoXG4gIG1hdGNoOiBNYXRjaCxcbiAgbmV3U2NvcmU6IHsgdGVhbTFTY29yZTogbnVtYmVyOyB0ZWFtMlNjb3JlOiBudW1iZXIgfVxuKTogTWF0Y2ggPT4ge1xuICBjb25zdCBpc0NvbXBsZXRlZCA9IG5ld1Njb3JlLnRlYW0xU2NvcmUgIT09IG5ld1Njb3JlLnRlYW0yU2NvcmU7XG4gIGxldCB3aW5uZXI6IFRlYW0gfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG4gIGxldCBsb3NlcjogVGVhbSB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcbiAgaWYgKGlzQ29tcGxldGVkKSB7XG4gICAgaWYgKG5ld1Njb3JlLnRlYW0xU2NvcmUgPiBuZXdTY29yZS50ZWFtMlNjb3JlKSB7XG4gICAgICB3aW5uZXIgPSBtYXRjaC50ZWFtMSA/IHsgLi4ubWF0Y2gudGVhbTEsIHdpbnM6IChtYXRjaC50ZWFtMS53aW5zID8/IDApICsgMSwgbG9zc2VzOiBtYXRjaC50ZWFtMS5sb3NzZXMgPz8gMCB9IDogdW5kZWZpbmVkO1xuICAgICAgbG9zZXIgPSBtYXRjaC50ZWFtMiA/IHsgLi4ubWF0Y2gudGVhbTIsIHdpbnM6IG1hdGNoLnRlYW0yLndpbnMgPz8gMCwgbG9zc2VzOiAobWF0Y2gudGVhbTIubG9zc2VzID8/IDApICsgMSB9IDogdW5kZWZpbmVkO1xuICAgIH0gZWxzZSB7XG4gICAgICB3aW5uZXIgPSBtYXRjaC50ZWFtMiA/IHsgLi4ubWF0Y2gudGVhbTIsIHdpbnM6IChtYXRjaC50ZWFtMi53aW5zID8/IDApICsgMSwgbG9zc2VzOiBtYXRjaC50ZWFtMi5sb3NzZXMgPz8gMCB9IDogdW5kZWZpbmVkO1xuICAgICAgbG9zZXIgPSBtYXRjaC50ZWFtMSA/IHsgLi4ubWF0Y2gudGVhbTEsIHdpbnM6IG1hdGNoLnRlYW0xLndpbnMgPz8gMCwgbG9zc2VzOiAobWF0Y2gudGVhbTEubG9zc2VzID8/IDApICsgMSB9IDogdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIC4uLm1hdGNoLFxuICAgIHNjb3JlOiBuZXdTY29yZSxcbiAgICBpc0NvbXBsZXRlZCxcbiAgICB3aW5uZXIsXG4gICAgbG9zZXJcbiAgfTtcbn07XG5cbi8vIEhlbHBlciB0byBkZWR1cGxpY2F0ZSB0ZWFtcyBieSBJRFxuZnVuY3Rpb24gZGVkdXBlVGVhbXModGVhbXM6IFRlYW1bXSk6IFRlYW1bXSB7XG4gIGNvbnN0IHNlZW4gPSBuZXcgU2V0PHN0cmluZz4oKTtcbiAgcmV0dXJuIHRlYW1zLmZpbHRlcih0ZWFtID0+IHtcbiAgICBpZiAoIXRlYW0pIHJldHVybiBmYWxzZTtcbiAgICBpZiAoc2Vlbi5oYXModGVhbS5pZCkpIHJldHVybiBmYWxzZTtcbiAgICBzZWVuLmFkZCh0ZWFtLmlkKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSk7XG59XG5cbi8vIEhlbHBlcjogZ2V0IGFsbCB0ZWFtcyB3aXRoIGV4YWN0bHkgTiBsb3NzZXNcbmZ1bmN0aW9uIHRlYW1zV2l0aExvc3Nlcyhsb3NzQ291bnRzOiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+LCBuOiBudW1iZXIpOiBzdHJpbmdbXSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyhsb3NzQ291bnRzKS5maWx0ZXIodGVhbUlkID0+IGxvc3NDb3VudHNbdGVhbUlkXSA9PT0gbik7XG59XG5leHBvcnQgY29uc3QgYWR2YW5jZVRvTmV4dFJvdW5kID0gKHRvdXJuYW1lbnQ6IFRvdXJuYW1lbnQpOiBUb3VybmFtZW50ID0+IHtcbiAgY29uc3QgY3VycmVudFJvdW5kID0gdG91cm5hbWVudC5yb3VuZHNbdG91cm5hbWVudC5yb3VuZHMubGVuZ3RoIC0gMV07XG4gIGNvbnN0IG5leHRSb3VuZE51bWJlciA9IHRvdXJuYW1lbnQuY3VycmVudFJvdW5kICsgMTtcblxuICAvLyBUcmFjayBhbGwgbG9zc2VzIGFuZCB3aW5zIGFjcm9zcyB0aGUgdG91cm5hbWVudFxuICBjb25zdCBsb3NzQ291bnRzOiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+ID0ge307XG4gIGNvbnN0IHdpbnNDb3VudHM6IFJlY29yZDxzdHJpbmcsIG51bWJlcj4gPSB7fTtcbiAgdG91cm5hbWVudC5yb3VuZHMuZm9yRWFjaCgocm91bmQpID0+IHtcbiAgICByb3VuZC5tYXRjaGVzLmZvckVhY2goKG1hdGNoKSA9PiB7XG4gICAgICBpZiAobWF0Y2guaXNDb21wbGV0ZWQgJiYgbWF0Y2gubG9zZXIpIHtcbiAgICAgICAgbG9zc0NvdW50c1ttYXRjaC5sb3Nlci5pZF0gPSAobG9zc0NvdW50c1ttYXRjaC5sb3Nlci5pZF0gfHwgMCkgKyAxO1xuICAgICAgfVxuICAgICAgaWYgKG1hdGNoLmlzQ29tcGxldGVkICYmIG1hdGNoLndpbm5lcikge1xuICAgICAgICB3aW5zQ291bnRzW21hdGNoLndpbm5lci5pZF0gPSAod2luc0NvdW50c1ttYXRjaC53aW5uZXIuaWRdIHx8IDApICsgMTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG5cbiAgLy8gV0lOTkVSIEdVQVJEOiBJZiBhIHdpbm5lciBoYXMgYWxyZWFkeSBiZWVuIGRldGVybWluZWQsIGRvIG5vdCBjcmVhdGUgYW55IG1vcmUgcm91bmRzXG4gIGlmICh0b3VybmFtZW50Lndpbm5lcikge1xuICAgIHJldHVybiB7XG4gICAgICAuLi50b3VybmFtZW50LFxuICAgICAgY3VycmVudFJvdW5kOiB0b3VybmFtZW50LmN1cnJlbnRSb3VuZFxuICAgIH07XG4gIH1cblxuICAvLyBHYXRoZXIgYWxsIHRlYW1zIGV2ZXIgaW4gdGhlIHRvdXJuYW1lbnQsIGF0dGFjaGluZyB3aW5zXG4gIGNvbnN0IGFsbFRlYW1zOiBUZWFtW10gPSBbXTtcbiAgY29uc3QgdGVhbUlkcyA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuICBmb3IgKGNvbnN0IHJvdW5kIG9mIHRvdXJuYW1lbnQucm91bmRzKSB7XG4gICAgZm9yIChjb25zdCBtYXRjaCBvZiByb3VuZC5tYXRjaGVzKSB7XG4gICAgICBpZiAobWF0Y2gudGVhbTEgJiYgIXRlYW1JZHMuaGFzKG1hdGNoLnRlYW0xLmlkKSkge1xuICAgICAgICBhbGxUZWFtcy5wdXNoKHtcbiAgICAgICAgICAuLi5tYXRjaC50ZWFtMSxcbiAgICAgICAgICB3aW5zOiB3aW5zQ291bnRzW21hdGNoLnRlYW0xLmlkXSB8fCAwLFxuICAgICAgICAgIGxvc3NlczogbG9zc0NvdW50c1ttYXRjaC50ZWFtMS5pZF0gfHwgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGVhbUlkcy5hZGQobWF0Y2gudGVhbTEuaWQpO1xuICAgICAgfVxuICAgICAgaWYgKG1hdGNoLnRlYW0yICYmICF0ZWFtSWRzLmhhcyhtYXRjaC50ZWFtMi5pZCkpIHtcbiAgICAgICAgYWxsVGVhbXMucHVzaCh7XG4gICAgICAgICAgLi4ubWF0Y2gudGVhbTIsXG4gICAgICAgICAgd2luczogd2luc0NvdW50c1ttYXRjaC50ZWFtMi5pZF0gfHwgMCxcbiAgICAgICAgICBsb3NzZXM6IGxvc3NDb3VudHNbbWF0Y2gudGVhbTIuaWRdIHx8IDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRlYW1JZHMuYWRkKG1hdGNoLnRlYW0yLmlkKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBJZGVudGlmeSBuZXdseSBlbGltaW5hdGVkIHRlYW1zICgyIGxvc3NlcylcbiAgY29uc3QgbmV3bHlFbGltaW5hdGVkOiBUZWFtW10gPSBbXTtcbiAgZm9yIChjb25zdCB0ZWFtIG9mIGFsbFRlYW1zKSB7XG4gICAgaWYgKFxuICAgICAgKGxvc3NDb3VudHNbdGVhbS5pZF0gfHwgMCkgPj0gMiAmJlxuICAgICAgIXRvdXJuYW1lbnQuZWxpbWluYXRlZFRlYW1zLnNvbWUoKHQpID0+IHQuaWQgPT09IHRlYW0uaWQpXG4gICAgKSB7XG4gICAgICBuZXdseUVsaW1pbmF0ZWQucHVzaCh0ZWFtKTtcbiAgICB9XG4gIH1cblxuICAvLyBXaW5uZXJzOiB0ZWFtcyB3aXRoIDAgbG9zc2VzIGFuZCBub3QgZWxpbWluYXRlZFxuICBjb25zdCB3aW5uZXJzQnJhY2tldFRlYW1zID0gYWxsVGVhbXNcbiAgICAuZmlsdGVyKFxuICAgICAgKHRlYW0pID0+XG4gICAgICAgIChsb3NzQ291bnRzW3RlYW0uaWRdIHx8IDApID09PSAwICYmXG4gICAgICAgICF0b3VybmFtZW50LmVsaW1pbmF0ZWRUZWFtcy5zb21lKCh0KSA9PiB0LmlkID09PSB0ZWFtLmlkKSAmJlxuICAgICAgICAhbmV3bHlFbGltaW5hdGVkLnNvbWUoKHQpID0+IHQuaWQgPT09IHRlYW0uaWQpICYmXG4gICAgICAgICF0ZWFtLmlkLnN0YXJ0c1dpdGgoXCJ0YmQtXCIpIC8vIEV4Y2x1ZGUgcGhhbnRvbSBUQkQgdGVhbXNcbiAgICApXG4gICAgLm1hcCgodGVhbSkgPT4gKHtcbiAgICAgIC4uLnRlYW0sXG4gICAgICBsb3NzZXM6IGxvc3NDb3VudHNbdGVhbS5pZF0gfHwgMCxcbiAgICAgIHdpbnM6IHdpbnNDb3VudHNbdGVhbS5pZF0gfHwgMFxuICAgIH0pKTtcblxuICAvLyBMb3NlcnM6IHRlYW1zIHdpdGggMSBsb3NzIGFuZCBub3QgZWxpbWluYXRlZFxuICBjb25zdCBsb3NlcnNCcmFja2V0VGVhbXMgPSBhbGxUZWFtc1xuICAgIC5maWx0ZXIoXG4gICAgICAodGVhbSkgPT5cbiAgICAgICAgKGxvc3NDb3VudHNbdGVhbS5pZF0gfHwgMCkgPT09IDEgJiZcbiAgICAgICAgIXRvdXJuYW1lbnQuZWxpbWluYXRlZFRlYW1zLnNvbWUoKHQpID0+IHQuaWQgPT09IHRlYW0uaWQpICYmXG4gICAgICAgICFuZXdseUVsaW1pbmF0ZWQuc29tZSgodCkgPT4gdC5pZCA9PT0gdGVhbS5pZCkgJiZcbiAgICAgICAgLy8gRG9uJ3QgaW5jbHVkZSB0aGUgd2lubmVycyBicmFja2V0IGZpbmFsIGxvc2VyIGluIHJlZ3VsYXIgbG9zZXJzIGJyYWNrZXQgdGVhbXNcbiAgICAgICAgIShcbiAgICAgICAgICB0b3VybmFtZW50Lndpbm5lcnNCcmFja2V0RmluYWxMb3NlciAmJlxuICAgICAgICAgIHRvdXJuYW1lbnQud2lubmVyc0JyYWNrZXRGaW5hbExvc2VyLmlkID09PSB0ZWFtLmlkXG4gICAgICAgIClcbiAgICApXG4gICAgLm1hcCgodGVhbSkgPT4gKHtcbiAgICAgIC4uLnRlYW0sXG4gICAgICBsb3NzZXM6IGxvc3NDb3VudHNbdGVhbS5pZF0gfHwgMCxcbiAgICAgIHdpbnM6IHdpbnNDb3VudHNbdGVhbS5pZF0gfHwgMFxuICAgIH0pKTtcblxuICBsZXQgaXNDaGFtcGlvbnNoaXBSb3VuZCA9IGZhbHNlO1xuICBsZXQgY2hhbXBpb25zaGlwTWF0Y2hlczogTWF0Y2hbXSA9IFtdO1xuICBsZXQgbmV4dFJvdW5kTWF0Y2hlczogTWF0Y2hbXSA9IFtdO1xuXG4gIGNvbnN0IHByZXZDaGFtcGlvbnNoaXBNYXRjaGVzID0gdG91cm5hbWVudC5yb3VuZHNcbiAgICAuZmlsdGVyKChyKSA9PiByLmlzQ2hhbXBpb25zaGlwUm91bmQpXG4gICAgLmZsYXRNYXAoKHIpID0+IHIubWF0Y2hlcylcbiAgICAuZmlsdGVyKChtKSA9PiBtLmJyYWNrZXQgPT09IFwiY2hhbXBpb25zaGlwXCIpO1xuXG4gIC8vIC0tLSBDSEFNUElPTlNISVAgTE9HSUMgLS0tXG5cbiAgLy8gQ2hlY2sgaWYgYSBjaGFtcGlvbnNoaXAgbWF0Y2ggYWxyZWFkeSBoYXBwZW5lZCBhbmQgd2FzIGNvbXBsZXRlZFxuICBpZiAoXG4gICAgcHJldkNoYW1waW9uc2hpcE1hdGNoZXMubGVuZ3RoID49IDEgJiZcbiAgICBwcmV2Q2hhbXBpb25zaGlwTWF0Y2hlc1twcmV2Q2hhbXBpb25zaGlwTWF0Y2hlcy5sZW5ndGggLSAxXS5pc0NvbXBsZXRlZFxuICApIHtcbiAgICBjb25zdCBsYXN0Q2hhbXBNYXRjaCA9XG4gICAgICBwcmV2Q2hhbXBpb25zaGlwTWF0Y2hlc1twcmV2Q2hhbXBpb25zaGlwTWF0Y2hlcy5sZW5ndGggLSAxXTtcbiAgICBjb25zdCB3aW5uZXJzQnJhY2tldFRlYW0gPSBsYXN0Q2hhbXBNYXRjaC50ZWFtMTtcbiAgICBjb25zdCBsb3NlcnNCcmFja2V0VGVhbSA9IGxhc3RDaGFtcE1hdGNoLnRlYW0yO1xuXG4gICAgLy8gSWYgbG9zZXIncyBicmFja2V0IHRlYW0gd29uIHRoZSBmaXJzdCBjaGFtcGlvbnNoaXAgbWF0Y2gsIHdpbm5lcidzIGJyYWNrZXQgdGVhbSBnZXRzIGFub3RoZXIgY2hhbmNlXG4gICAgaWYgKFxuICAgICAgbGFzdENoYW1wTWF0Y2gud2lubmVyPy5pZCA9PT0gbG9zZXJzQnJhY2tldFRlYW0/LmlkICYmXG4gICAgICB0b3VybmFtZW50LmNoYW1waW9uc2hpcE1hdGNoZXNQbGF5ZWQgPT09IDFcbiAgICApIHtcbiAgICAgIGlzQ2hhbXBpb25zaGlwUm91bmQgPSB0cnVlO1xuICAgICAgLy8gQ3JlYXRlIHRoZSBcInJlc2V0XCIgbWF0Y2hcbiAgICAgIGNoYW1waW9uc2hpcE1hdGNoZXMucHVzaChcbiAgICAgICAgY3JlYXRlTWF0Y2goXG4gICAgICAgICAgYEMke25leHRSb3VuZE51bWJlcn0tMWAsXG4gICAgICAgICAgbmV4dFJvdW5kTnVtYmVyLFxuICAgICAgICAgIHdpbm5lcnNCcmFja2V0VGVhbSxcbiAgICAgICAgICBsb3NlcnNCcmFja2V0VGVhbSxcbiAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICBcImNoYW1waW9uc2hpcFwiXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEVpdGhlciB3aW5uZXIncyBicmFja2V0IHRlYW0gd29uIGZpcnN0IG1hdGNoLCBvciB0aGlzIHdhcyB0aGUgcmVzZXQgbWF0Y2hcbiAgICAgIGlzQ2hhbXBpb25zaGlwUm91bmQgPSB0cnVlO1xuICAgICAgLy8gTm8gbmV3IG1hdGNoZXMsIHdpbm5lciB3aWxsIGJlIGRldGVybWluZWQgaW4gd2lubmVyIGRldGVjdGlvbiBsb2dpY1xuICAgIH1cbiAgfVxuICAvLyBDaGVjayBpZiB3ZSdyZSByZWFkeSBmb3IgdGhlIGNoYW1waW9uc2hpcCBtYXRjaCAtIG9uZSB0ZWFtIGluIGVhY2ggYnJhY2tldCBhbmQgbG9zZXIncyBmaW5hbCBpcyBjb21wbGV0ZVxuICBlbHNlIGlmIChcbiAgICB3aW5uZXJzQnJhY2tldFRlYW1zLmxlbmd0aCA9PT0gMSAmJlxuICAgIGxvc2Vyc0JyYWNrZXRUZWFtcy5sZW5ndGggPT09IDEgJiZcbiAgICBjdXJyZW50Um91bmQubWF0Y2hlcy5zb21lKFxuICAgICAgKG0pID0+XG4gICAgICAgIChtLmJyYWNrZXQgPT09IFwibG9zZXJzXCIgfHwgbS5pZC5pbmNsdWRlcyhcIkxvc2Vyc0xhc3RcIikpICYmXG4gICAgICAgIG0uaXNDb21wbGV0ZWQgJiZcbiAgICAgICAgbS53aW5uZXIgJiZcbiAgICAgICAgKGxvc2Vyc0JyYWNrZXRUZWFtcy5zb21lKCh0KSA9PiB0LmlkID09PSBtLndpbm5lciEuaWQpIHx8XG4gICAgICAgICAgKHRvdXJuYW1lbnQud2lubmVyc0JyYWNrZXRGaW5hbExvc2VyICYmXG4gICAgICAgICAgICBtLndpbm5lciEuaWQgPT09IHRvdXJuYW1lbnQud2lubmVyc0JyYWNrZXRGaW5hbExvc2VyLmlkKSlcbiAgICApXG4gICkge1xuICAgIC8vIEZpbmQgdGhlIHdpbm5lciBvZiB0aGUgbG9zZXJzIGJyYWNrZXQgZmluYWxcbiAgICBjb25zdCBsb3NlcnNCcmFja2V0V2lubmVyID0gY3VycmVudFJvdW5kLm1hdGNoZXNcbiAgICAgIC5maWx0ZXIoXG4gICAgICAgIChtKSA9PlxuICAgICAgICAgIChtLmJyYWNrZXQgPT09IFwibG9zZXJzXCIgfHwgbS5pZC5pbmNsdWRlcyhcIkxvc2Vyc0xhc3RcIikpICYmXG4gICAgICAgICAgbS5pc0NvbXBsZXRlZCAmJlxuICAgICAgICAgIG0ud2lubmVyXG4gICAgICApXG4gICAgICAubWFwKChtKSA9PiBtLndpbm5lciEpXG4gICAgICAucG9wKCk7XG5cbiAgICBpZiAobG9zZXJzQnJhY2tldFdpbm5lcikge1xuICAgICAgLy8gT25seSBzY2hlZHVsZSB0aGUgY2hhbXBpb25zaGlwIGlmIHRoZXJlIGlzIG5vIHdpbm5lcnNCcmFja2V0RmluYWxMb3NlciB3YWl0aW5nIHRvIHBsYXlcbiAgICAgIGlmICghdG91cm5hbWVudC53aW5uZXJzQnJhY2tldEZpbmFsTG9zZXIpIHtcbiAgICAgICAgLy8gU2NoZWR1bGUgY2hhbXBpb25zaGlwIG1hdGNoIGltbWVkaWF0ZWx5IChubyBleHRyYSByb3VuZClcbiAgICAgICAgbmV4dFJvdW5kTWF0Y2hlcy5wdXNoKFxuICAgICAgICAgIGNyZWF0ZU1hdGNoKFxuICAgICAgICAgICAgYEMke25leHRSb3VuZE51bWJlcn0tMWAsXG4gICAgICAgICAgICBuZXh0Um91bmROdW1iZXIsXG4gICAgICAgICAgICB3aW5uZXJzQnJhY2tldFRlYW1zWzBdLCAvLyBXaW5uZXIncyBicmFja2V0IGNoYW1waW9uXG4gICAgICAgICAgICBsb3NlcnNCcmFja2V0V2lubmVyLCAvLyBMb3NlcidzIGJyYWNrZXQgY2hhbXBpb25cbiAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgXCJjaGFtcGlvbnNoaXBcIlxuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgICAgaXNDaGFtcGlvbnNoaXBSb3VuZCA9IHRydWU7XG4gICAgICAgIC8vIERvIE5PVCBzY2hlZHVsZSBhbnkgd2FpdGluZyBjYXJkc1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gSW5zdGVhZCwgc2NoZWR1bGUgdGhlIGxvc2VycyBicmFja2V0IGZpbmFsIChMTFdCIHZzIExXTEIpLCBhbmQgc2hvdyB0aGUgd2lubmVycyBicmFja2V0IGNoYW1waW9uIGFzIHdhaXRpbmdcbiAgICAgICAgbmV4dFJvdW5kTWF0Y2hlcy5wdXNoKFxuICAgICAgICAgIGNyZWF0ZU1hdGNoKFxuICAgICAgICAgICAgYExvc2Vyc0xhc3QtJHtuZXh0Um91bmROdW1iZXJ9YCxcbiAgICAgICAgICAgIG5leHRSb3VuZE51bWJlcixcbiAgICAgICAgICAgIHRvdXJuYW1lbnQud2lubmVyc0JyYWNrZXRGaW5hbExvc2VyLFxuICAgICAgICAgICAgbG9zZXJzQnJhY2tldFRlYW1zWzBdLFxuICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICBcImxvc2Vyc1wiXG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgICBuZXh0Um91bmRNYXRjaGVzLnB1c2goXG4gICAgICAgICAgY3JlYXRlTWF0Y2goXG4gICAgICAgICAgICBgV2lubmVyc0JyYWNrZXRDaGFtcGlvbi13YWl0aW5nLSR7bmV4dFJvdW5kTnVtYmVyfWAsXG4gICAgICAgICAgICBuZXh0Um91bmROdW1iZXIsXG4gICAgICAgICAgICB3aW5uZXJzQnJhY2tldFRlYW1zWzBdLFxuICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgIHRydWUsXG4gICAgICAgICAgICBcIndpbm5lcnNcIlxuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLy8gQ2hlY2sgaWYgd2UgbmVlZCB0byBjcmVhdGUgdGhlIGZpbmFsIGxvc2VycyBicmFja2V0IG1hdGNoICh3aW5uZXJzIGJyYWNrZXQgZmluYWwgbG9zZXIgdnMgbG9zZXJzIGJyYWNrZXQgd2lubmVyKVxuICBlbHNlIGlmIChcbiAgICB3aW5uZXJzQnJhY2tldFRlYW1zLmxlbmd0aCA9PT0gMSAmJlxuICAgIHRvdXJuYW1lbnQud2lubmVyc0JyYWNrZXRGaW5hbExvc2VyXG4gICkge1xuICAgIGlmIChsb3NlcnNCcmFja2V0VGVhbXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAvLyBQcmV2ZW50IGR1cGxpY2F0ZSBsb3NlcnMgYnJhY2tldCBmaW5hbDogY2hlY2sgYWxsIHByZXZpb3VzIHJvdW5kcyBmb3IgdGhpcyBtYXRjaFxuICAgICAgbGV0IGFscmVhZHlQbGF5ZWQgPSBmYWxzZTtcbiAgICAgIGZvciAobGV0IHJvdW5kIG9mIHRvdXJuYW1lbnQucm91bmRzKSB7XG4gICAgICAgIGlmICghcm91bmQubWF0Y2hlcykgY29udGludWU7XG4gICAgICAgIGZvciAobGV0IG0gb2Ygcm91bmQubWF0Y2hlcykge1xuICAgICAgICAgIGNvbnN0IGlkcyA9IFttLnRlYW0xPy5pZCwgbS50ZWFtMj8uaWRdLmZpbHRlcihCb29sZWFuKS5zb3J0KCk7XG4gICAgICAgICAgY29uc3QgY3VycklkcyA9IFt0b3VybmFtZW50Lndpbm5lcnNCcmFja2V0RmluYWxMb3Nlci5pZCwgbG9zZXJzQnJhY2tldFRlYW1zWzBdLmlkXS5zb3J0KCk7XG4gICAgICAgICAgaWYgKGlkcy5sZW5ndGggPT09IDIgJiYgaWRzWzBdID09PSBjdXJySWRzWzBdICYmIGlkc1sxXSA9PT0gY3Vycklkc1sxXSkge1xuICAgICAgICAgICAgYWxyZWFkeVBsYXllZCA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFscmVhZHlQbGF5ZWQpIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKCFhbHJlYWR5UGxheWVkKSB7XG4gICAgICAgIC8vIE9ubHkgbm93IHNjaGVkdWxlIFdCRkwgdnMgTEJMXG4gICAgICAgIG5leHRSb3VuZE1hdGNoZXMucHVzaChcbiAgICAgICAgICBjcmVhdGVNYXRjaChcbiAgICAgICAgICAgIGBMb3NlcnNMYXN0LSR7bmV4dFJvdW5kTnVtYmVyfWAsXG4gICAgICAgICAgICBuZXh0Um91bmROdW1iZXIsXG4gICAgICAgICAgICB0b3VybmFtZW50Lndpbm5lcnNCcmFja2V0RmluYWxMb3NlcixcbiAgICAgICAgICAgIGxvc2Vyc0JyYWNrZXRUZWFtc1swXSxcbiAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgXCJsb3NlcnNcIlxuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIC8vIElmIG1hdGNoIGFscmVhZHkgcGxheWVkLCBkbyBub3Qgc2NoZWR1bGUgYWdhaW47IGNoYW1waW9uc2hpcCBsb2dpYyB3aWxsIGhhbmRsZSBuZXh0IHN0ZXBcbiAgICB9IGVsc2UgaWYgKGxvc2Vyc0JyYWNrZXRUZWFtcy5sZW5ndGggPT09IDIpIHtcbiAgICAgIC8vIFNjaGVkdWxlIHRoZSBtYXRjaCBiZXR3ZWVuIHRoZSBsYXN0IHR3byBsb3NlcnMgYnJhY2tldCB0ZWFtc1xuICAgICAgbmV4dFJvdW5kTWF0Y2hlcy5wdXNoKFxuICAgICAgICBjcmVhdGVNYXRjaChcbiAgICAgICAgICBgTCR7bmV4dFJvdW5kTnVtYmVyfS0xYCxcbiAgICAgICAgICBuZXh0Um91bmROdW1iZXIsXG4gICAgICAgICAgbG9zZXJzQnJhY2tldFRlYW1zWzBdLFxuICAgICAgICAgIGxvc2Vyc0JyYWNrZXRUZWFtc1sxXSxcbiAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICBcImxvc2Vyc1wiXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgICAvLyBXQkZMIGlzIHdhaXRpbmcgZm9yIHRoZSB3aW5uZXJcbiAgICAgIG5leHRSb3VuZE1hdGNoZXMucHVzaChcbiAgICAgICAgY3JlYXRlTWF0Y2goXG4gICAgICAgICAgYFdpbm5lcnNGaW5hbExvc2VyLXdhaXRpbmctJHtuZXh0Um91bmROdW1iZXJ9YCxcbiAgICAgICAgICBuZXh0Um91bmROdW1iZXIsXG4gICAgICAgICAgdG91cm5hbWVudC53aW5uZXJzQnJhY2tldEZpbmFsTG9zZXIsXG4gICAgICAgICAgbnVsbCxcbiAgICAgICAgICB0cnVlLFxuICAgICAgICAgIFwibG9zZXJzXCJcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKGxvc2Vyc0JyYWNrZXRUZWFtcy5sZW5ndGggPiAyKSB7XG4gICAgICAvLyBNb3JlIHRoYW4gMiB0ZWFtczogcGFpciBvZmYgYXMgdXN1YWwsIFdCRkwgd2FpdHNcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbG9zZXJzQnJhY2tldFRlYW1zLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgIGNvbnN0IHRlYW0xID0gbG9zZXJzQnJhY2tldFRlYW1zW2ldO1xuICAgICAgICBjb25zdCB0ZWFtMiA9IGxvc2Vyc0JyYWNrZXRUZWFtc1tpICsgMV0gPz8gbnVsbDtcbiAgICAgICAgbmV4dFJvdW5kTWF0Y2hlcy5wdXNoKFxuICAgICAgICAgIGNyZWF0ZU1hdGNoKFxuICAgICAgICAgICAgYEwke25leHRSb3VuZE51bWJlcn0tJHtNYXRoLmZsb29yKGkgLyAyKSArIDF9YCxcbiAgICAgICAgICAgIG5leHRSb3VuZE51bWJlcixcbiAgICAgICAgICAgIHRlYW0xLFxuICAgICAgICAgICAgdGVhbTIsXG4gICAgICAgICAgICAhdGVhbTIsXG4gICAgICAgICAgICBcImxvc2Vyc1wiXG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgbmV4dFJvdW5kTWF0Y2hlcy5wdXNoKFxuICAgICAgICBjcmVhdGVNYXRjaChcbiAgICAgICAgICBgV2lubmVyc0ZpbmFsTG9zZXItd2FpdGluZy0ke25leHRSb3VuZE51bWJlcn1gLFxuICAgICAgICAgIG5leHRSb3VuZE51bWJlcixcbiAgICAgICAgICB0b3VybmFtZW50Lndpbm5lcnNCcmFja2V0RmluYWxMb3NlcixcbiAgICAgICAgICBudWxsLFxuICAgICAgICAgIHRydWUsXG4gICAgICAgICAgXCJsb3NlcnNcIlxuICAgICAgICApXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBXQkZMIGlzIHdhaXRpbmcgZm9yIHRoZSBsb3NlcnMgYnJhY2tldCB0byByZXNvbHZlXG4gICAgICBuZXh0Um91bmRNYXRjaGVzLnB1c2goXG4gICAgICAgIGNyZWF0ZU1hdGNoKFxuICAgICAgICAgIGBXaW5uZXJzRmluYWxMb3Nlci13YWl0aW5nLSR7bmV4dFJvdW5kTnVtYmVyfWAsXG4gICAgICAgICAgbmV4dFJvdW5kTnVtYmVyLFxuICAgICAgICAgIHRvdXJuYW1lbnQud2lubmVyc0JyYWNrZXRGaW5hbExvc2VyLFxuICAgICAgICAgIG51bGwsXG4gICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICBcImxvc2Vyc1wiXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfVxuICAgIC8vIEFsd2F5cyBzaG93IGEgd2FpdGluZyBjYXJkIGZvciB0aGUgd2lubmVycyBicmFja2V0IGNoYW1waW9uIGlmIG5vdCBpbiBjaGFtcGlvbnNoaXBcbiAgICBuZXh0Um91bmRNYXRjaGVzLnB1c2goXG4gICAgICBjcmVhdGVNYXRjaChcbiAgICAgICAgYFdpbm5lcnNCcmFja2V0Q2hhbXBpb24td2FpdGluZy0ke25leHRSb3VuZE51bWJlcn1gLFxuICAgICAgICBuZXh0Um91bmROdW1iZXIsXG4gICAgICAgIHdpbm5lcnNCcmFja2V0VGVhbXNbMF0sXG4gICAgICAgIG51bGwsXG4gICAgICAgIHRydWUsXG4gICAgICAgIFwid2lubmVyc1wiXG4gICAgICApXG4gICAgKTtcbiAgfVxuICAvLyBDaGVjayBpZiB0aGlzIGlzIHRoZSB3aW5uZXIncyBicmFja2V0IGZpbmFsIChleGFjdGx5IDIgdGVhbXMgaW4gd2lubmVyJ3MgYnJhY2tldClcbiAgZWxzZSBpZiAod2lubmVyc0JyYWNrZXRUZWFtcy5sZW5ndGggPT09IDIpIHtcbiAgICAvLyBDcmVhdGUgdGhlIHdpbm5lcidzIGJyYWNrZXQgZmluYWwgbWF0Y2hcbiAgICBuZXh0Um91bmRNYXRjaGVzLnB1c2goXG4gICAgICBjcmVhdGVNYXRjaChcbiAgICAgICAgYFcke25leHRSb3VuZE51bWJlcn0tMWAsXG4gICAgICAgIG5leHRSb3VuZE51bWJlcixcbiAgICAgICAgd2lubmVyc0JyYWNrZXRUZWFtc1swXSxcbiAgICAgICAgd2lubmVyc0JyYWNrZXRUZWFtc1sxXSxcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIFwid2lubmVyc1wiXG4gICAgICApXG4gICAgKTtcblxuICAgIC8vIENvbnRpbnVlIHdpdGggbG9zZXJzIGJyYWNrZXQgbWF0Y2hlcyBzZXBhcmF0ZWx5XG4gICAgY3JlYXRlTG9zZXJzQnJhY2tldE1hdGNoZXMoKTtcbiAgfVxuICAvLyBPdGhlcndpc2UsIGNvbnRpbnVlIHdpdGggbm9ybWFsIGJyYWNrZXQgcGxheVxuICBlbHNlIHtcbiAgICBjcmVhdGVTdGFuZGFyZEJyYWNrZXRNYXRjaGVzKCk7XG4gIH1cblxuICAvLyBIZWxwZXIgZnVuY3Rpb24gdG8gY3JlYXRlIHN0YW5kYXJkIGJyYWNrZXQgbWF0Y2hlc1xuICBmdW5jdGlvbiBjcmVhdGVTdGFuZGFyZEJyYWNrZXRNYXRjaGVzKCkge1xuICAgIC8vIC0tLSBXaW5uZXJzIEJyYWNrZXQgTWF0Y2hlcyAtLS1cbiAgICBsZXQgbWF0Y2hDb3VudGVyID0gMTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHdpbm5lcnNCcmFja2V0VGVhbXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgIGNvbnN0IHRlYW0xID0gd2lubmVyc0JyYWNrZXRUZWFtc1tpXTtcbiAgICAgIGNvbnN0IHRlYW0yID0gd2lubmVyc0JyYWNrZXRUZWFtc1tpICsgMV0gPz8gbnVsbDtcbiAgICAgIGNvbnN0IGlzQnllID0gIXRlYW0yO1xuICAgICAgbmV4dFJvdW5kTWF0Y2hlcy5wdXNoKFxuICAgICAgICBjcmVhdGVNYXRjaChcbiAgICAgICAgICBgVyR7bmV4dFJvdW5kTnVtYmVyfS0ke21hdGNoQ291bnRlcn1gLFxuICAgICAgICAgIG5leHRSb3VuZE51bWJlcixcbiAgICAgICAgICB0ZWFtMSxcbiAgICAgICAgICB0ZWFtMixcbiAgICAgICAgICBpc0J5ZSxcbiAgICAgICAgICBcIndpbm5lcnNcIlxuICAgICAgICApXG4gICAgICApO1xuICAgICAgbWF0Y2hDb3VudGVyKys7XG4gICAgfVxuXG4gICAgLy8gQ3JlYXRlIGxvc2VycyBicmFja2V0IG1hdGNoZXMgc2VwYXJhdGVseVxuICAgIGNyZWF0ZUxvc2Vyc0JyYWNrZXRNYXRjaGVzKCk7XG4gIH1cblxuICAvLyBIZWxwZXIgZnVuY3Rpb24gdG8gY3JlYXRlIGxvc2VycyBicmFja2V0IG1hdGNoZXNcbiAgZnVuY3Rpb24gY3JlYXRlTG9zZXJzQnJhY2tldE1hdGNoZXMoKSB7XG4gICAgLy8gLS0tIExvc2VycyBCcmFja2V0IE1hdGNoZXMgLS0tXG4gICAgY29uc3QgZWxpZ2libGVMb3NlcnMgPSBhbGxUZWFtcy5maWx0ZXIoXG4gICAgICAodGVhbSkgPT5cbiAgICAgICAgKGxvc3NDb3VudHNbdGVhbS5pZF0gfHwgMCkgPT09IDEgJiZcbiAgICAgICAgIXRvdXJuYW1lbnQuZWxpbWluYXRlZFRlYW1zLnNvbWUoKHQpID0+IHQuaWQgPT09IHRlYW0uaWQpICYmXG4gICAgICAgICFuZXdseUVsaW1pbmF0ZWQuc29tZSgodCkgPT4gdC5pZCA9PT0gdGVhbS5pZCkgJiZcbiAgICAgICAgLy8gRXhjbHVkZSB3aW5uZXIncyBicmFja2V0IGZpbmFsIGxvc2VyIGlmIGl0IGV4aXN0c1xuICAgICAgICAhKFxuICAgICAgICAgIHRvdXJuYW1lbnQud2lubmVyc0JyYWNrZXRGaW5hbExvc2VyICYmXG4gICAgICAgICAgdG91cm5hbWVudC53aW5uZXJzQnJhY2tldEZpbmFsTG9zZXIuaWQgPT09IHRlYW0uaWRcbiAgICAgICAgKVxuICAgICk7XG5cbiAgICAvLyBGaW5kIHRlYW1zIHJlY2VudGx5IGRyb3BwZWQgZnJvbSB3aW5uZXJzIGJyYWNrZXRcbiAgICBjb25zdCBqdXN0RHJvcHBlZEZyb21XaW5uZXJzID0gY3VycmVudFJvdW5kLm1hdGNoZXNcbiAgICAgIC5maWx0ZXIoKG0pID0+IG0uYnJhY2tldCA9PT0gXCJ3aW5uZXJzXCIgJiYgbS5sb3NlciAmJiBtLmlzQ29tcGxldGVkKVxuICAgICAgLm1hcCgobSkgPT4gbS5sb3NlciEpXG4gICAgICAuZmlsdGVyKChsb3NlcikgPT4gZWxpZ2libGVMb3NlcnMuc29tZSgodCkgPT4gdC5pZCA9PT0gbG9zZXIuaWQpKTtcblxuICAgIC8vIElmIHRoaXMgaXMgdGhlIHdpbm5lcidzIGJyYWNrZXQgZmluYWwsIHN0b3JlIHRoZSBsb3NlciBmb3IgbGF0ZXIgdXNlXG4gICAgaWYgKFxuICAgICAgY3VycmVudFJvdW5kLm1hdGNoZXMuc29tZShcbiAgICAgICAgKG0pID0+XG4gICAgICAgICAgbS5icmFja2V0ID09PSBcIndpbm5lcnNcIiAmJlxuICAgICAgICAgIHdpbm5lcnNCcmFja2V0VGVhbXMubGVuZ3RoID09PSAxICYmXG4gICAgICAgICAgbS5sb3NlciAmJlxuICAgICAgICAgIG0uaXNDb21wbGV0ZWRcbiAgICAgIClcbiAgICApIHtcbiAgICAgIC8vIFRoaXMgaXMgYSBzcGVjaWFsIGNhc2UgLSB3ZSBmb3VuZCB0aGUgd2lubmVyJ3MgYnJhY2tldCBmaW5hbCBsb3NlclxuICAgICAgY29uc3Qgd2lubmVyc0ZpbmFsTG9zZXIgPSBjdXJyZW50Um91bmQubWF0Y2hlc1xuICAgICAgICAuZmlsdGVyKChtKSA9PiBtLmJyYWNrZXQgPT09IFwid2lubmVyc1wiICYmIG0uaXNDb21wbGV0ZWQgJiYgbS5sb3NlcilcbiAgICAgICAgLm1hcCgobSkgPT4gbS5sb3NlciEpXG4gICAgICAgIC5wb3AoKTtcblxuICAgICAgaWYgKFxuICAgICAgICB3aW5uZXJzRmluYWxMb3NlciAmJlxuICAgICAgICAhdG91cm5hbWVudC5lbGltaW5hdGVkVGVhbXMuc29tZSgodCkgPT4gdC5pZCA9PT0gd2lubmVyc0ZpbmFsTG9zZXIuaWQpXG4gICAgICApIHtcbiAgICAgICAgdG91cm5hbWVudC53aW5uZXJzQnJhY2tldEZpbmFsTG9zZXIgPSB3aW5uZXJzRmluYWxMb3NlcjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBFeGlzdGluZyBsb3NlcnMgYnJhY2tldCB0ZWFtc1xuICAgIGNvbnN0IGV4aXN0aW5nTG9zZXJzID0gZWxpZ2libGVMb3NlcnMuZmlsdGVyKFxuICAgICAgKHQpID0+ICFqdXN0RHJvcHBlZEZyb21XaW5uZXJzLnNvbWUoKGpkKSA9PiBqZC5pZCA9PT0gdC5pZClcbiAgICApO1xuXG4gICAgLy8gT3JkZXI6IG1vc3QgcmVjZW50IGRyb3AocykgZmlyc3RcbiAgICBjb25zdCBvcmRlcmVkTG9zZXJzID0gWy4uLmp1c3REcm9wcGVkRnJvbVdpbm5lcnMsIC4uLmV4aXN0aW5nTG9zZXJzXTtcblxuICAgIGlmIChvcmRlcmVkTG9zZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgIGlmIChvcmRlcmVkTG9zZXJzLmxlbmd0aCAlIDIgPT09IDEpIHtcbiAgICAgICAgLy8gT2RkOiBieWUgZ29lcyB0byB0aGUgbW9zdCByZWNlbnQgdGVhbSBkcm9wcGVkIGZyb20gd2lubmVycyBicmFja2V0XG4gICAgICAgIGxldCB0ZWFtV2l0aEJ5ZTogVGVhbSB8IG51bGwgPSBudWxsO1xuICAgICAgICBpZiAoanVzdERyb3BwZWRGcm9tV2lubmVycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdGVhbVdpdGhCeWUgPVxuICAgICAgICAgICAganVzdERyb3BwZWRGcm9tV2lubmVyc1tqdXN0RHJvcHBlZEZyb21XaW5uZXJzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgIC8vIFJlbW92ZSB0aGUgYnllIHRlYW0gZnJvbSBvcmRlcmVkTG9zZXJzXG4gICAgICAgICAgY29uc3QgYnllSW5kZXggPSBvcmRlcmVkTG9zZXJzLmZpbmRJbmRleChcbiAgICAgICAgICAgICh0KSA9PiB0LmlkID09PSB0ZWFtV2l0aEJ5ZSEuaWRcbiAgICAgICAgICApO1xuICAgICAgICAgIGlmIChieWVJbmRleCAhPT0gLTEpIG9yZGVyZWRMb3NlcnMuc3BsaWNlKGJ5ZUluZGV4LCAxKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBEZWZlbnNpdmU6IGZhbGxiYWNrIHRvIGZpcnN0IHRlYW0gaWYgbm8gcmVjZW50IGRyb3BcbiAgICAgICAgICB0ZWFtV2l0aEJ5ZSA9IG9yZGVyZWRMb3NlcnMuc2hpZnQoKSE7XG4gICAgICAgIH1cbiAgICAgICAgbmV4dFJvdW5kTWF0Y2hlcy5wdXNoKFxuICAgICAgICAgIGNyZWF0ZU1hdGNoKFxuICAgICAgICAgICAgYEwke25leHRSb3VuZE51bWJlcn0tMWAsXG4gICAgICAgICAgICBuZXh0Um91bmROdW1iZXIsXG4gICAgICAgICAgICB0ZWFtV2l0aEJ5ZSxcbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICB0cnVlLFxuICAgICAgICAgICAgXCJsb3NlcnNcIlxuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgICAgLy8gUGFpciB0aGUgcmVzdFxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9yZGVyZWRMb3NlcnMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICBjb25zdCB0ZWFtMSA9IG9yZGVyZWRMb3NlcnNbaV07XG4gICAgICAgICAgY29uc3QgdGVhbTIgPSBvcmRlcmVkTG9zZXJzW2kgKyAxXSA/PyBudWxsO1xuICAgICAgICAgIG5leHRSb3VuZE1hdGNoZXMucHVzaChcbiAgICAgICAgICAgIGNyZWF0ZU1hdGNoKFxuICAgICAgICAgICAgICBgTCR7bmV4dFJvdW5kTnVtYmVyfS0ke01hdGguZmxvb3IoaSAvIDIpICsgMn1gLFxuICAgICAgICAgICAgICBuZXh0Um91bmROdW1iZXIsXG4gICAgICAgICAgICAgIHRlYW0xLFxuICAgICAgICAgICAgICB0ZWFtMixcbiAgICAgICAgICAgICAgIXRlYW0yLFxuICAgICAgICAgICAgICBcImxvc2Vyc1wiXG4gICAgICAgICAgICApXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRXZlbiBudW1iZXI6IHBhaXIgYWxsXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3JkZXJlZExvc2Vycy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgIGNvbnN0IHRlYW0xID0gb3JkZXJlZExvc2Vyc1tpXTtcbiAgICAgICAgICBjb25zdCB0ZWFtMiA9IG9yZGVyZWRMb3NlcnNbaSArIDFdID8/IG51bGw7XG4gICAgICAgICAgbmV4dFJvdW5kTWF0Y2hlcy5wdXNoKFxuICAgICAgICAgICAgY3JlYXRlTWF0Y2goXG4gICAgICAgICAgICAgIGBMJHtuZXh0Um91bmROdW1iZXJ9LSR7TWF0aC5mbG9vcihpIC8gMikgKyAxfWAsXG4gICAgICAgICAgICAgIG5leHRSb3VuZE51bWJlcixcbiAgICAgICAgICAgICAgdGVhbTEsXG4gICAgICAgICAgICAgIHRlYW0yLFxuICAgICAgICAgICAgICAhdGVhbTIsXG4gICAgICAgICAgICAgIFwibG9zZXJzXCJcbiAgICAgICAgICAgIClcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gLS0tIFdpbm5lciBkZXRlY3Rpb24gbG9naWMgLS0tXG4gIGxldCB3aW5uZXI6IFRlYW0gfCB1bmRlZmluZWQgPSB0b3VybmFtZW50Lndpbm5lcjtcblxuICBpZiAoaXNDaGFtcGlvbnNoaXBSb3VuZCkge1xuICAgIC8vIEZpbmQgdGhlIGxhc3QgY2hhbXBpb25zaGlwIG1hdGNoIHBsYXllZFxuICAgIGNvbnN0IGxhc3RDaGFtcE1hdGNoID1cbiAgICAgIGNoYW1waW9uc2hpcE1hdGNoZXNbMF0gfHxcbiAgICAgIHByZXZDaGFtcGlvbnNoaXBNYXRjaGVzW3ByZXZDaGFtcGlvbnNoaXBNYXRjaGVzLmxlbmd0aCAtIDFdO1xuXG4gICAgaWYgKFxuICAgICAgbGFzdENoYW1wTWF0Y2ggJiZcbiAgICAgIGxhc3RDaGFtcE1hdGNoLmlzQ29tcGxldGVkICYmXG4gICAgICBsYXN0Q2hhbXBNYXRjaC53aW5uZXIgJiZcbiAgICAgIGxhc3RDaGFtcE1hdGNoLmxvc2VyXG4gICAgKSB7XG4gICAgICBjb25zdCB3aW5uZXJzQnJhY2tldFRlYW0gPSBsYXN0Q2hhbXBNYXRjaC50ZWFtMTtcbiAgICAgIGNvbnN0IGxvc2Vyc0JyYWNrZXRUZWFtID0gbGFzdENoYW1wTWF0Y2gudGVhbTI7XG4gICAgICBjb25zdCBsb3NlcnNCcmFja2V0VGVhbVdvbiA9XG4gICAgICAgIGxvc2Vyc0JyYWNrZXRUZWFtICYmIGxhc3RDaGFtcE1hdGNoLndpbm5lci5pZCA9PT0gbG9zZXJzQnJhY2tldFRlYW0uaWQ7XG5cbiAgICAgIC8vIElmIGxvc2VyJ3MgYnJhY2tldCB0ZWFtIHdvbiBmaXJzdCBjaGFtcGlvbnNoaXAgbWF0Y2gsIHdpbm5lcidzIGJyYWNrZXQgdGVhbSBnZXRzIGFub3RoZXIgY2hhbmNlXG4gICAgICBpZiAobG9zZXJzQnJhY2tldFRlYW1Xb24gJiYgdG91cm5hbWVudC5jaGFtcGlvbnNoaXBNYXRjaGVzUGxheWVkID09PSAxKSB7XG4gICAgICAgIHdpbm5lciA9IHVuZGVmaW5lZDsgLy8gTm8gd2lubmVyIHlldCwgbmVlZCByZXNldCBtYXRjaFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRWl0aGVyIHdpbm5lcidzIGJyYWNrZXQgdGVhbSB3b24gZmlyc3QgbWF0Y2gsIG9yIHRoaXMgd2FzIHRoZSByZXNldCBtYXRjaFxuICAgICAgICB3aW5uZXIgPSBsYXN0Q2hhbXBNYXRjaC53aW5uZXI7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gLS0tIElORklOSVRFIFJFQ1VSU0lPTiBHVUFSRCAtLS1cbiAgY29uc3Qgbm9Nb3JlTWF0Y2hlcyA9XG4gICAgKGlzQ2hhbXBpb25zaGlwUm91bmQgJiYgY2hhbXBpb25zaGlwTWF0Y2hlcy5sZW5ndGggPT09IDApIHx8XG4gICAgKCFpc0NoYW1waW9uc2hpcFJvdW5kICYmIG5leHRSb3VuZE1hdGNoZXMubGVuZ3RoID09PSAwKTtcblxuICBpZiAobm9Nb3JlTWF0Y2hlcykge1xuICAgIC8vIFRvdXJuYW1lbnQgaXMgb3ZlciwgZG8gbm90IGFkdmFuY2UgZnVydGhlclxuICAgIHJldHVybiB7XG4gICAgICAuLi50b3VybmFtZW50LFxuICAgICAgd2lubmVyLFxuICAgICAgY3VycmVudFJvdW5kOiB0b3VybmFtZW50LmN1cnJlbnRSb3VuZFxuICAgIH07XG4gIH1cblxuICAvLyBEZWJ1ZyBsb2cgYmVmb3JlIHJldHVybmluZyB0aGUgbmV3IHRvdXJuYW1lbnQgb2JqZWN0XG4gIGxvZ1RvdXJuYW1lbnRTdGF0ZSh7XG4gICAgcm91bmROdW1iZXI6IG5leHRSb3VuZE51bWJlcixcbiAgICB3aW5uZXJzQnJhY2tldFRlYW1zLFxuICAgIGxvc2Vyc0JyYWNrZXRUZWFtcyxcbiAgICBtYXRjaGVzOiBpc0NoYW1waW9uc2hpcFJvdW5kID8gY2hhbXBpb25zaGlwTWF0Y2hlcyA6IG5leHRSb3VuZE1hdGNoZXMsXG4gICAgd2lubmVyc0JyYWNrZXRGaW5hbExvc2VyOiB0b3VybmFtZW50Lndpbm5lcnNCcmFja2V0RmluYWxMb3NlclxuICB9KTtcblxuICAvLyBDb21wb3NlIHRoZSBuZXcgdG91cm5hbWVudCBvYmplY3RcbiAgcmV0dXJuIHtcbiAgICAuLi50b3VybmFtZW50LFxuICAgIHJvdW5kczogW1xuICAgICAgLi4udG91cm5hbWVudC5yb3VuZHMsXG4gICAgICB7XG4gICAgICAgIHJvdW5kTnVtYmVyOiBuZXh0Um91bmROdW1iZXIsXG4gICAgICAgIG1hdGNoZXM6IGlzQ2hhbXBpb25zaGlwUm91bmQgPyBjaGFtcGlvbnNoaXBNYXRjaGVzIDogbmV4dFJvdW5kTWF0Y2hlcyxcbiAgICAgICAgaXNEb3VibGVFbGltaW5hdGlvbjogdHJ1ZSxcbiAgICAgICAgaXNDaGFtcGlvbnNoaXBSb3VuZFxuICAgICAgfVxuICAgIF0sXG4gICAgY3VycmVudFJvdW5kOiBuZXh0Um91bmROdW1iZXIsXG4gICAgZWxpbWluYXRlZFRlYW1zOiBbXG4gICAgICAuLi50b3VybmFtZW50LmVsaW1pbmF0ZWRUZWFtcyxcbiAgICAgIC4uLm5ld2x5RWxpbWluYXRlZC5maWx0ZXIoXG4gICAgICAgICh0KSA9PiAhdG91cm5hbWVudC5lbGltaW5hdGVkVGVhbXMuc29tZSgoZXQpID0+IGV0LmlkID09PSB0LmlkKVxuICAgICAgKVxuICAgIF0sXG4gICAgY2hhbXBpb25zaGlwTWF0Y2hlc1BsYXllZDogaXNDaGFtcGlvbnNoaXBSb3VuZFxuICAgICAgPyB0b3VybmFtZW50LmNoYW1waW9uc2hpcE1hdGNoZXNQbGF5ZWQgKyAxXG4gICAgICA6IHRvdXJuYW1lbnQuY2hhbXBpb25zaGlwTWF0Y2hlc1BsYXllZCxcbiAgICB3aW5uZXJzQnJhY2tldEZpbmFsTG9zZXI6IHRvdXJuYW1lbnQud2lubmVyc0JyYWNrZXRGaW5hbExvc2VyLFxuICAgIHdpbm5lclxuICB9O1xufTtcbi8vIGV4cG9ydCBjb25zdCBhZHZhbmNlVG9OZXh0Um91bmQgPSAodG91cm5hbWVudDogVG91cm5hbWVudCk6IFRvdXJuYW1lbnQgPT4ge1xuLy8gICBjb25zdCBjdXJyZW50Um91bmQgPSB0b3VybmFtZW50LnJvdW5kc1t0b3VybmFtZW50LnJvdW5kcy5sZW5ndGggLSAxXTtcbi8vICAgY29uc3QgbmV4dFJvdW5kTnVtYmVyID0gdG91cm5hbWVudC5jdXJyZW50Um91bmQgKyAxO1xuXG4vLyAgIC8vIFRyYWNrIGFsbCBsb3NzZXMgYWNyb3NzIHRoZSB0b3VybmFtZW50XG4vLyAgIGNvbnN0IGxvc3NDb3VudHM6IFJlY29yZDxzdHJpbmcsIG51bWJlcj4gPSB7fTtcbi8vICAgdG91cm5hbWVudC5yb3VuZHMuZm9yRWFjaCgocm91bmQpID0+IHtcbi8vICAgICByb3VuZC5tYXRjaGVzLmZvckVhY2goKG1hdGNoKSA9PiB7XG4vLyAgICAgICBpZiAobWF0Y2guaXNDb21wbGV0ZWQgJiYgbWF0Y2gubG9zZXIpIHtcbi8vICAgICAgICAgbG9zc0NvdW50c1ttYXRjaC5sb3Nlci5pZF0gPSAobG9zc0NvdW50c1ttYXRjaC5sb3Nlci5pZF0gfHwgMCkgKyAxO1xuLy8gICAgICAgfVxuLy8gICAgIH0pO1xuLy8gICB9KTtcblxuLy8gICAvLyBHYXRoZXIgYWxsIHRlYW1zIGV2ZXIgaW4gdGhlIHRvdXJuYW1lbnRcbi8vICAgY29uc3QgYWxsVGVhbXM6IFRlYW1bXSA9IFtdO1xuLy8gICBjb25zdCB0ZWFtSWRzID0gbmV3IFNldDxzdHJpbmc+KCk7XG4vLyAgIGZvciAoY29uc3Qgcm91bmQgb2YgdG91cm5hbWVudC5yb3VuZHMpIHtcbi8vICAgICBmb3IgKGNvbnN0IG1hdGNoIG9mIHJvdW5kLm1hdGNoZXMpIHtcbi8vICAgICAgIGlmIChtYXRjaC50ZWFtMSAmJiAhdGVhbUlkcy5oYXMobWF0Y2gudGVhbTEuaWQpKSB7XG4vLyAgICAgICAgIGFsbFRlYW1zLnB1c2gobWF0Y2gudGVhbTEpO1xuLy8gICAgICAgICB0ZWFtSWRzLmFkZChtYXRjaC50ZWFtMS5pZCk7XG4vLyAgICAgICB9XG4vLyAgICAgICBpZiAobWF0Y2gudGVhbTIgJiYgIXRlYW1JZHMuaGFzKG1hdGNoLnRlYW0yLmlkKSkge1xuLy8gICAgICAgICBhbGxUZWFtcy5wdXNoKG1hdGNoLnRlYW0yKTtcbi8vICAgICAgICAgdGVhbUlkcy5hZGQobWF0Y2gudGVhbTIuaWQpO1xuLy8gICAgICAgfVxuLy8gICAgIH1cbi8vICAgfVxuXG4vLyAgIC8vIElkZW50aWZ5IG5ld2x5IGVsaW1pbmF0ZWQgdGVhbXMgKDIgbG9zc2VzKVxuLy8gICBjb25zdCBuZXdseUVsaW1pbmF0ZWQ6IFRlYW1bXSA9IFtdO1xuLy8gICBmb3IgKGNvbnN0IHRlYW0gb2YgYWxsVGVhbXMpIHtcbi8vICAgICBpZiAoXG4vLyAgICAgICAobG9zc0NvdW50c1t0ZWFtLmlkXSB8fCAwKSA+PSAyICYmXG4vLyAgICAgICAhdG91cm5hbWVudC5lbGltaW5hdGVkVGVhbXMuc29tZSgodCkgPT4gdC5pZCA9PT0gdGVhbS5pZClcbi8vICAgICApIHtcbi8vICAgICAgIG5ld2x5RWxpbWluYXRlZC5wdXNoKHRlYW0pO1xuLy8gICAgIH1cbi8vICAgfVxuXG4vLyAgIC8vIFdpbm5lcnM6IHRlYW1zIHdpdGggMCBsb3NzZXMgYW5kIG5vdCBlbGltaW5hdGVkXG4vLyAgIGNvbnN0IHdpbm5lcnNCcmFja2V0VGVhbXMgPSBhbGxUZWFtcy5maWx0ZXIoXG4vLyAgICAgKHRlYW0pID0+XG4vLyAgICAgICAobG9zc0NvdW50c1t0ZWFtLmlkXSB8fCAwKSA9PT0gMCAmJlxuLy8gICAgICAgIXRvdXJuYW1lbnQuZWxpbWluYXRlZFRlYW1zLnNvbWUoKHQpID0+IHQuaWQgPT09IHRlYW0uaWQpICYmXG4vLyAgICAgICAhbmV3bHlFbGltaW5hdGVkLnNvbWUoKHQpID0+IHQuaWQgPT09IHRlYW0uaWQpXG4vLyAgICk7XG5cbi8vICAgLy8gTG9zZXJzOiB0ZWFtcyB3aXRoIDEgbG9zcyBhbmQgbm90IGVsaW1pbmF0ZWRcbi8vICAgY29uc3QgbG9zZXJzQnJhY2tldFRlYW1zID0gYWxsVGVhbXMuZmlsdGVyKFxuLy8gICAgICh0ZWFtKSA9PlxuLy8gICAgICAgKGxvc3NDb3VudHNbdGVhbS5pZF0gfHwgMCkgPT09IDEgJiZcbi8vICAgICAgICF0b3VybmFtZW50LmVsaW1pbmF0ZWRUZWFtcy5zb21lKCh0KSA9PiB0LmlkID09PSB0ZWFtLmlkKSAmJlxuLy8gICAgICAgIW5ld2x5RWxpbWluYXRlZC5zb21lKCh0KSA9PiB0LmlkID09PSB0ZWFtLmlkKVxuLy8gICApO1xuXG4vLyAgIGxldCBpc0NoYW1waW9uc2hpcFJvdW5kID0gZmFsc2U7XG4vLyAgIGxldCBjaGFtcGlvbnNoaXBNYXRjaGVzOiBNYXRjaFtdID0gW107XG4vLyAgIGxldCBuZXh0Um91bmRNYXRjaGVzOiBNYXRjaFtdID0gW107XG5cbi8vICAgY29uc3QgcHJldkNoYW1waW9uc2hpcE1hdGNoZXMgPSB0b3VybmFtZW50LnJvdW5kc1xuLy8gICAgIC5maWx0ZXIoKHIpID0+IHIuaXNDaGFtcGlvbnNoaXBSb3VuZClcbi8vICAgICAuZmxhdE1hcCgocikgPT4gci5tYXRjaGVzKVxuLy8gICAgIC5maWx0ZXIoKG0pID0+IG0uYnJhY2tldCA9PT0gXCJjaGFtcGlvbnNoaXBcIik7XG5cbi8vICAgLy8gLS0tIENIQU1QSU9OU0hJUCBMT0dJQyAtLS1cblxuLy8gICAvLyBDaGVjayBpZiBhIGNoYW1waW9uc2hpcCBtYXRjaCBhbHJlYWR5IGhhcHBlbmVkIGFuZCB3YXMgY29tcGxldGVkXG4vLyAgIGlmIChcbi8vICAgICBwcmV2Q2hhbXBpb25zaGlwTWF0Y2hlcy5sZW5ndGggPj0gMSAmJlxuLy8gICAgIHByZXZDaGFtcGlvbnNoaXBNYXRjaGVzW3ByZXZDaGFtcGlvbnNoaXBNYXRjaGVzLmxlbmd0aCAtIDFdLmlzQ29tcGxldGVkXG4vLyAgICkge1xuLy8gICAgIGNvbnN0IGxhc3RDaGFtcE1hdGNoID1cbi8vICAgICAgIHByZXZDaGFtcGlvbnNoaXBNYXRjaGVzW3ByZXZDaGFtcGlvbnNoaXBNYXRjaGVzLmxlbmd0aCAtIDFdO1xuLy8gICAgIGNvbnN0IHdpbm5lcnNCcmFja2V0VGVhbSA9IGxhc3RDaGFtcE1hdGNoLnRlYW0xO1xuLy8gICAgIGNvbnN0IGxvc2Vyc0JyYWNrZXRUZWFtID0gbGFzdENoYW1wTWF0Y2gudGVhbTI7XG5cbi8vICAgICAvLyBJZiBsb3NlcidzIGJyYWNrZXQgdGVhbSB3b24gdGhlIGZpcnN0IGNoYW1waW9uc2hpcCBtYXRjaCwgd2lubmVyJ3MgYnJhY2tldCB0ZWFtIGdldHMgYW5vdGhlciBjaGFuY2Vcbi8vICAgICBpZiAoXG4vLyAgICAgICBsYXN0Q2hhbXBNYXRjaC53aW5uZXI/LmlkID09PSBsb3NlcnNCcmFja2V0VGVhbT8uaWQgJiZcbi8vICAgICAgIHRvdXJuYW1lbnQuY2hhbXBpb25zaGlwTWF0Y2hlc1BsYXllZCA9PT0gMVxuLy8gICAgICkge1xuLy8gICAgICAgaXNDaGFtcGlvbnNoaXBSb3VuZCA9IHRydWU7XG4vLyAgICAgICAvLyBDcmVhdGUgdGhlIFwicmVzZXRcIiBtYXRjaFxuLy8gICAgICAgY2hhbXBpb25zaGlwTWF0Y2hlcy5wdXNoKFxuLy8gICAgICAgICBjcmVhdGVNYXRjaChcbi8vICAgICAgICAgICBgQyR7bmV4dFJvdW5kTnVtYmVyfS0xYCxcbi8vICAgICAgICAgICBuZXh0Um91bmROdW1iZXIsXG4vLyAgICAgICAgICAgd2lubmVyc0JyYWNrZXRUZWFtLFxuLy8gICAgICAgICAgIGxvc2Vyc0JyYWNrZXRUZWFtLFxuLy8gICAgICAgICAgIGZhbHNlLFxuLy8gICAgICAgICAgIFwiY2hhbXBpb25zaGlwXCJcbi8vICAgICAgICAgKVxuLy8gICAgICAgKTtcbi8vICAgICB9IGVsc2Uge1xuLy8gICAgICAgLy8gRWl0aGVyIHdpbm5lcidzIGJyYWNrZXQgdGVhbSB3b24gZmlyc3QgbWF0Y2gsIG9yIHRoaXMgd2FzIHRoZSByZXNldCBtYXRjaFxuLy8gICAgICAgaXNDaGFtcGlvbnNoaXBSb3VuZCA9IHRydWU7XG4vLyAgICAgICAvLyBObyBuZXcgbWF0Y2hlcywgd2lubmVyIHdpbGwgYmUgZGV0ZXJtaW5lZCBpbiB3aW5uZXIgZGV0ZWN0aW9uIGxvZ2ljXG4vLyAgICAgfVxuLy8gICB9XG4vLyAgIC8vIENoZWNrIGlmIHdlJ3JlIHJlYWR5IGZvciB0aGUgY2hhbXBpb25zaGlwIG1hdGNoIC0gb25lIHRlYW0gaW4gZWFjaCBicmFja2V0IGFuZCBsb3NlcidzIGZpbmFsIGlzIGNvbXBsZXRlXG4vLyAgIGVsc2UgaWYgKFxuLy8gICAgIHdpbm5lcnNCcmFja2V0VGVhbXMubGVuZ3RoID09PSAxICYmXG4vLyAgICAgbG9zZXJzQnJhY2tldFRlYW1zLmxlbmd0aCA9PT0gMSAmJlxuLy8gICAgIGN1cnJlbnRSb3VuZC5tYXRjaGVzLnNvbWUoXG4vLyAgICAgICAobSkgPT5cbi8vICAgICAgICAgKG0uYnJhY2tldCA9PT0gXCJsb3NlcnNcIiB8fCBtLmlkLmluY2x1ZGVzKFwiTG9zZXJzTGFzdFwiKSkgJiZcbi8vICAgICAgICAgbS5pc0NvbXBsZXRlZCAmJlxuLy8gICAgICAgICBtLndpbm5lciAmJlxuLy8gICAgICAgICBsb3NlcnNCcmFja2V0VGVhbXMuc29tZSgodCkgPT4gdC5pZCA9PT0gbS53aW5uZXIhLmlkKVxuLy8gICAgIClcbi8vICAgKSB7XG4vLyAgICAgLy8gQ2hhbXBpb25zaGlwIG1hdGNoOiBXaW5uZXIncyBicmFja2V0IGNoYW1waW9uIHZzIExvc2VyJ3MgYnJhY2tldCBjaGFtcGlvblxuLy8gICAgIGlzQ2hhbXBpb25zaGlwUm91bmQgPSB0cnVlO1xuLy8gICAgIGNoYW1waW9uc2hpcE1hdGNoZXMucHVzaChcbi8vICAgICAgIGNyZWF0ZU1hdGNoKFxuLy8gICAgICAgICBgQyR7bmV4dFJvdW5kTnVtYmVyfS0xYCxcbi8vICAgICAgICAgbmV4dFJvdW5kTnVtYmVyLFxuLy8gICAgICAgICB3aW5uZXJzQnJhY2tldFRlYW1zWzBdLCAvLyBXaW5uZXIncyBicmFja2V0IGNoYW1waW9uXG4vLyAgICAgICAgIGxvc2Vyc0JyYWNrZXRUZWFtc1swXSwgLy8gTG9zZXIncyBicmFja2V0IGNoYW1waW9uXG4vLyAgICAgICAgIGZhbHNlLFxuLy8gICAgICAgICBcImNoYW1waW9uc2hpcFwiXG4vLyAgICAgICApXG4vLyAgICAgKTtcbi8vICAgfVxuLy8gICAvLyBDaGVjayBpZiB3ZSBoYXZlIGEgbG9zZXIgZnJvbSB3aW5uZXIncyBicmFja2V0IGZpbmFsIHdhaXRpbmcgdG8gcGxheSBhZ2FpbnN0IGxvc2VyJ3MgYnJhY2tldCB3aW5uZXJcbi8vICAgZWxzZSBpZiAoXG4vLyAgICAgd2lubmVyc0JyYWNrZXRUZWFtcy5sZW5ndGggPT09IDEgJiYgLy8gV2UgaGF2ZSBhIHdpbm5lcidzIGJyYWNrZXQgY2hhbXBpb25cbi8vICAgICBsb3NlcnNCcmFja2V0VGVhbXMubGVuZ3RoID49IDEgJiYgLy8gV2UgaGF2ZSBhdCBsZWFzdCBvbmUgdGVhbSBpbiBsb3NlcidzIGJyYWNrZXRcbi8vICAgICB0b3VybmFtZW50Lndpbm5lcnNCcmFja2V0RmluYWxMb3NlciAvLyBXZSBoYXZlIHN0b3JlZCB0aGUgd2lubmVyJ3MgYnJhY2tldCBmaW5hbCBsb3NlclxuLy8gICApIHtcbi8vICAgICAvLyBGaW5kIHRoZSB3aW5uZXIgb2YgdGhlIGxvc2VyJ3MgYnJhY2tldFxuLy8gICAgIGNvbnN0IGxvc2Vyc0JyYWNrZXRXaW5uZXIgPSBjdXJyZW50Um91bmQubWF0Y2hlc1xuLy8gICAgICAgLmZpbHRlcigobSkgPT4gbS5icmFja2V0ID09PSBcImxvc2Vyc1wiICYmIG0uaXNDb21wbGV0ZWQgJiYgbS53aW5uZXIpXG4vLyAgICAgICAubWFwKChtKSA9PiBtLndpbm5lciEpXG4vLyAgICAgICAuZmluZCgod2lubmVyKSA9PiBsb3NlcnNCcmFja2V0VGVhbXMuc29tZSgodCkgPT4gdC5pZCA9PT0gd2lubmVyLmlkKSk7XG5cbi8vICAgICBpZiAoXG4vLyAgICAgICBsb3NlcnNCcmFja2V0V2lubmVyICYmXG4vLyAgICAgICBsb3NlcnNCcmFja2V0V2lubmVyLmlkICE9PSB0b3VybmFtZW50Lndpbm5lcnNCcmFja2V0RmluYWxMb3Nlci5pZFxuLy8gICAgICkge1xuLy8gICAgICAgLy8gT25seSBzY2hlZHVsZSBpZiB0aGV5J3JlIG5vdCB0aGUgc2FtZSB0ZWFtIVxuLy8gICAgICAgbmV4dFJvdW5kTWF0Y2hlcy5wdXNoKFxuLy8gICAgICAgICBjcmVhdGVNYXRjaChcbi8vICAgICAgICAgICBgTG9zZXJzTGFzdC0ke25leHRSb3VuZE51bWJlcn1gLFxuLy8gICAgICAgICAgIG5leHRSb3VuZE51bWJlcixcbi8vICAgICAgICAgICB0b3VybmFtZW50Lndpbm5lcnNCcmFja2V0RmluYWxMb3Nlcixcbi8vICAgICAgICAgICBsb3NlcnNCcmFja2V0V2lubmVyLFxuLy8gICAgICAgICAgIGZhbHNlLFxuLy8gICAgICAgICAgIFwibG9zZXJzXCJcbi8vICAgICAgICAgKVxuLy8gICAgICAgKTtcbi8vICAgICB9IGVsc2Uge1xuLy8gICAgICAgLy8gV2FpdCBmb3IgdGhlIGxvc2VycyBicmFja2V0IHRvIHJlc29sdmUgcHJvcGVybHlcbi8vICAgICAgIGNyZWF0ZVN0YW5kYXJkQnJhY2tldE1hdGNoZXMoKTtcbi8vICAgICB9XG4vLyAgIH1cbi8vICAgLy8gQ2hlY2sgaWYgdGhpcyBpcyB0aGUgd2lubmVyJ3MgYnJhY2tldCBmaW5hbCAoZXhhY3RseSAyIHRlYW1zIGluIHdpbm5lcidzIGJyYWNrZXQpXG4vLyAgIGVsc2UgaWYgKHdpbm5lcnNCcmFja2V0VGVhbXMubGVuZ3RoID09PSAyICYmIGxvc2Vyc0JyYWNrZXRUZWFtcy5sZW5ndGggPj0gMSkge1xuLy8gICAgIC8vIENyZWF0ZSB0aGUgd2lubmVyJ3MgYnJhY2tldCBmaW5hbCBtYXRjaFxuLy8gICAgIG5leHRSb3VuZE1hdGNoZXMucHVzaChcbi8vICAgICAgIGNyZWF0ZU1hdGNoKFxuLy8gICAgICAgICBgVyR7bmV4dFJvdW5kTnVtYmVyfS0xYCxcbi8vICAgICAgICAgbmV4dFJvdW5kTnVtYmVyLFxuLy8gICAgICAgICB3aW5uZXJzQnJhY2tldFRlYW1zWzBdLFxuLy8gICAgICAgICB3aW5uZXJzQnJhY2tldFRlYW1zWzFdLFxuLy8gICAgICAgICBmYWxzZSxcbi8vICAgICAgICAgXCJ3aW5uZXJzXCJcbi8vICAgICAgIClcbi8vICAgICApO1xuXG4vLyAgICAgLy8gQ29udGludWUgd2l0aCBsb3NlcnMgYnJhY2tldCBtYXRjaGVzIHNlcGFyYXRlbHlcbi8vICAgICBjcmVhdGVMb3NlcnNCcmFja2V0TWF0Y2hlcygpO1xuLy8gICB9XG4vLyAgIC8vIE90aGVyd2lzZSwgY29udGludWUgd2l0aCBub3JtYWwgYnJhY2tldCBwbGF5XG4vLyAgIGVsc2Uge1xuLy8gICAgIGNyZWF0ZVN0YW5kYXJkQnJhY2tldE1hdGNoZXMoKTtcbi8vICAgfVxuXG4vLyAgIC8vIEhlbHBlciBmdW5jdGlvbiB0byBjcmVhdGUgc3RhbmRhcmQgYnJhY2tldCBtYXRjaGVzXG4vLyAgIGZ1bmN0aW9uIGNyZWF0ZVN0YW5kYXJkQnJhY2tldE1hdGNoZXMoKSB7XG4vLyAgICAgLy8gLS0tIFdpbm5lcnMgQnJhY2tldCBNYXRjaGVzIC0tLVxuLy8gICAgIGxldCBtYXRjaENvdW50ZXIgPSAxO1xuLy8gICAgIGZvciAobGV0IGkgPSAwOyBpIDwgd2lubmVyc0JyYWNrZXRUZWFtcy5sZW5ndGg7IGkgKz0gMikge1xuLy8gICAgICAgY29uc3QgdGVhbTEgPSB3aW5uZXJzQnJhY2tldFRlYW1zW2ldO1xuLy8gICAgICAgY29uc3QgdGVhbTIgPSB3aW5uZXJzQnJhY2tldFRlYW1zW2kgKyAxXSA/PyBudWxsO1xuLy8gICAgICAgY29uc3QgaXNCeWUgPSAhdGVhbTI7XG4vLyAgICAgICBuZXh0Um91bmRNYXRjaGVzLnB1c2goXG4vLyAgICAgICAgIGNyZWF0ZU1hdGNoKFxuLy8gICAgICAgICAgIGBXJHtuZXh0Um91bmROdW1iZXJ9LSR7bWF0Y2hDb3VudGVyfWAsXG4vLyAgICAgICAgICAgbmV4dFJvdW5kTnVtYmVyLFxuLy8gICAgICAgICAgIHRlYW0xLFxuLy8gICAgICAgICAgIHRlYW0yLFxuLy8gICAgICAgICAgIGlzQnllLFxuLy8gICAgICAgICAgIFwid2lubmVyc1wiXG4vLyAgICAgICAgIClcbi8vICAgICAgICk7XG4vLyAgICAgICBtYXRjaENvdW50ZXIrKztcbi8vICAgICB9XG5cbi8vICAgICAvLyBDcmVhdGUgbG9zZXJzIGJyYWNrZXQgbWF0Y2hlcyBzZXBhcmF0ZWx5XG4vLyAgICAgY3JlYXRlTG9zZXJzQnJhY2tldE1hdGNoZXMoKTtcbi8vICAgfVxuXG4vLyAgIC8vIEhlbHBlciBmdW5jdGlvbiB0byBjcmVhdGUgbG9zZXJzIGJyYWNrZXQgbWF0Y2hlc1xuLy8gICBmdW5jdGlvbiBjcmVhdGVMb3NlcnNCcmFja2V0TWF0Y2hlcygpIHtcbi8vICAgICAvLyAtLS0gTG9zZXJzIEJyYWNrZXQgTWF0Y2hlcyAtLS1cbi8vICAgICBjb25zdCBlbGlnaWJsZUxvc2VycyA9IGFsbFRlYW1zLmZpbHRlcihcbi8vICAgICAgICh0ZWFtKSA9PlxuLy8gICAgICAgICAobG9zc0NvdW50c1t0ZWFtLmlkXSB8fCAwKSA9PT0gMSAmJlxuLy8gICAgICAgICAhdG91cm5hbWVudC5lbGltaW5hdGVkVGVhbXMuc29tZSgodCkgPT4gdC5pZCA9PT0gdGVhbS5pZCkgJiZcbi8vICAgICAgICAgIW5ld2x5RWxpbWluYXRlZC5zb21lKCh0KSA9PiB0LmlkID09PSB0ZWFtLmlkKSAmJlxuLy8gICAgICAgICAvLyBFeGNsdWRlIHdpbm5lcidzIGJyYWNrZXQgZmluYWwgbG9zZXIgaWYgaXQgZXhpc3RzIGJ1dCBoYXNuJ3QgcGxheWVkIHlldCBpbiBsb3NlcnNcbi8vICAgICAgICAgIShcbi8vICAgICAgICAgICB0b3VybmFtZW50Lndpbm5lcnNCcmFja2V0RmluYWxMb3NlciAmJlxuLy8gICAgICAgICAgIHRvdXJuYW1lbnQud2lubmVyc0JyYWNrZXRGaW5hbExvc2VyLmlkID09PSB0ZWFtLmlkXG4vLyAgICAgICAgIClcbi8vICAgICApO1xuXG4vLyAgICAgLy8gRmluZCB0ZWFtcyByZWNlbnRseSBkcm9wcGVkIGZyb20gd2lubmVycyBicmFja2V0XG4vLyAgICAgY29uc3QganVzdERyb3BwZWRGcm9tV2lubmVycyA9IGN1cnJlbnRSb3VuZC5tYXRjaGVzXG4vLyAgICAgICAuZmlsdGVyKChtKSA9PiBtLmJyYWNrZXQgPT09IFwid2lubmVyc1wiICYmIG0ubG9zZXIgJiYgbS5pc0NvbXBsZXRlZClcbi8vICAgICAgIC5tYXAoKG0pID0+IG0ubG9zZXIhKVxuLy8gICAgICAgLmZpbHRlcigobG9zZXIpID0+IGVsaWdpYmxlTG9zZXJzLnNvbWUoKHQpID0+IHQuaWQgPT09IGxvc2VyLmlkKSk7XG5cbi8vICAgICAvLyBJZiB0aGlzIGlzIHRoZSB3aW5uZXIncyBicmFja2V0IGZpbmFsLCBzdG9yZSB0aGUgbG9zZXIgZm9yIGxhdGVyIHVzZVxuLy8gICAgIGlmIChcbi8vICAgICAgIGN1cnJlbnRSb3VuZC5tYXRjaGVzLnNvbWUoXG4vLyAgICAgICAgIChtKSA9PlxuLy8gICAgICAgICAgIG0uYnJhY2tldCA9PT0gXCJ3aW5uZXJzXCIgJiZcbi8vICAgICAgICAgICB3aW5uZXJzQnJhY2tldFRlYW1zLmxlbmd0aCA9PT0gMSAmJlxuLy8gICAgICAgICAgIG0ubG9zZXIgJiZcbi8vICAgICAgICAgICBtLmlzQ29tcGxldGVkXG4vLyAgICAgICApXG4vLyAgICAgKSB7XG4vLyAgICAgICAvLyBUaGlzIGlzIGEgc3BlY2lhbCBjYXNlIC0gd2UgZm91bmQgdGhlIHdpbm5lcidzIGJyYWNrZXQgZmluYWwgbG9zZXJcbi8vICAgICAgIGNvbnN0IHdpbm5lcnNGaW5hbExvc2VyID0gY3VycmVudFJvdW5kLm1hdGNoZXNcbi8vICAgICAgICAgLmZpbHRlcigobSkgPT4gbS5icmFja2V0ID09PSBcIndpbm5lcnNcIiAmJiBtLmlzQ29tcGxldGVkICYmIG0ubG9zZXIpXG4vLyAgICAgICAgIC5tYXAoKG0pID0+IG0ubG9zZXIhKVxuLy8gICAgICAgICAucG9wKCk7XG5cbi8vICAgICAgIGlmICh3aW5uZXJzRmluYWxMb3Nlcikge1xuLy8gICAgICAgICB0b3VybmFtZW50Lndpbm5lcnNCcmFja2V0RmluYWxMb3NlciA9IHdpbm5lcnNGaW5hbExvc2VyO1xuLy8gICAgICAgfVxuLy8gICAgIH1cblxuLy8gICAgIC8vIEV4aXN0aW5nIGxvc2VycyBicmFja2V0IHRlYW1zXG4vLyAgICAgY29uc3QgZXhpc3RpbmdMb3NlcnMgPSBlbGlnaWJsZUxvc2Vycy5maWx0ZXIoXG4vLyAgICAgICAodCkgPT4gIWp1c3REcm9wcGVkRnJvbVdpbm5lcnMuc29tZSgoamQpID0+IGpkLmlkID09PSB0LmlkKVxuLy8gICAgICk7XG5cbi8vICAgICAvLyBPcmRlcjogbW9zdCByZWNlbnQgZHJvcChzKSBmaXJzdFxuLy8gICAgIGNvbnN0IG9yZGVyZWRMb3NlcnMgPSBbLi4uanVzdERyb3BwZWRGcm9tV2lubmVycywgLi4uZXhpc3RpbmdMb3NlcnNdO1xuXG4vLyAgICAgaWYgKG9yZGVyZWRMb3NlcnMubGVuZ3RoID4gMCkge1xuLy8gICAgICAgaWYgKG9yZGVyZWRMb3NlcnMubGVuZ3RoICUgMiA9PT0gMSkge1xuLy8gICAgICAgICAvLyBPZGQ6IGJ5ZSBnb2VzIHRvIHRoZSBtb3N0IHJlY2VudCB0ZWFtIGRyb3BwZWQgZnJvbSB3aW5uZXJzIGJyYWNrZXRcbi8vICAgICAgICAgbGV0IHRlYW1XaXRoQnllOiBUZWFtIHwgbnVsbCA9IG51bGw7XG4vLyAgICAgICAgIGlmIChqdXN0RHJvcHBlZEZyb21XaW5uZXJzLmxlbmd0aCA+IDApIHtcbi8vICAgICAgICAgICB0ZWFtV2l0aEJ5ZSA9XG4vLyAgICAgICAgICAgICBqdXN0RHJvcHBlZEZyb21XaW5uZXJzW2p1c3REcm9wcGVkRnJvbVdpbm5lcnMubGVuZ3RoIC0gMV07XG4vLyAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBieWUgdGVhbSBmcm9tIG9yZGVyZWRMb3NlcnNcbi8vICAgICAgICAgICBjb25zdCBieWVJbmRleCA9IG9yZGVyZWRMb3NlcnMuZmluZEluZGV4KFxuLy8gICAgICAgICAgICAgKHQpID0+IHQuaWQgPT09IHRlYW1XaXRoQnllIS5pZFxuLy8gICAgICAgICAgICk7XG4vLyAgICAgICAgICAgaWYgKGJ5ZUluZGV4ICE9PSAtMSkgb3JkZXJlZExvc2Vycy5zcGxpY2UoYnllSW5kZXgsIDEpO1xuLy8gICAgICAgICB9IGVsc2Uge1xuLy8gICAgICAgICAgIC8vIERlZmVuc2l2ZTogZmFsbGJhY2sgdG8gZmlyc3QgdGVhbSBpZiBubyByZWNlbnQgZHJvcFxuLy8gICAgICAgICAgIHRlYW1XaXRoQnllID0gb3JkZXJlZExvc2Vycy5zaGlmdCgpITtcbi8vICAgICAgICAgfVxuLy8gICAgICAgICBuZXh0Um91bmRNYXRjaGVzLnB1c2goXG4vLyAgICAgICAgICAgY3JlYXRlTWF0Y2goXG4vLyAgICAgICAgICAgICBgTCR7bmV4dFJvdW5kTnVtYmVyfS0xYCxcbi8vICAgICAgICAgICAgIG5leHRSb3VuZE51bWJlcixcbi8vICAgICAgICAgICAgIHRlYW1XaXRoQnllLFxuLy8gICAgICAgICAgICAgbnVsbCxcbi8vICAgICAgICAgICAgIHRydWUsXG4vLyAgICAgICAgICAgICBcImxvc2Vyc1wiXG4vLyAgICAgICAgICAgKVxuLy8gICAgICAgICApO1xuLy8gICAgICAgICAvLyBQYWlyIHRoZSByZXN0XG4vLyAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3JkZXJlZExvc2Vycy5sZW5ndGg7IGkgKz0gMikge1xuLy8gICAgICAgICAgIGNvbnN0IHRlYW0xID0gb3JkZXJlZExvc2Vyc1tpXTtcbi8vICAgICAgICAgICBjb25zdCB0ZWFtMiA9IG9yZGVyZWRMb3NlcnNbaSArIDFdID8/IG51bGw7XG4vLyAgICAgICAgICAgbmV4dFJvdW5kTWF0Y2hlcy5wdXNoKFxuLy8gICAgICAgICAgICAgY3JlYXRlTWF0Y2goXG4vLyAgICAgICAgICAgICAgIGBMJHtuZXh0Um91bmROdW1iZXJ9LSR7TWF0aC5mbG9vcihpIC8gMikgKyAyfWAsXG4vLyAgICAgICAgICAgICAgIG5leHRSb3VuZE51bWJlcixcbi8vICAgICAgICAgICAgICAgdGVhbTEsXG4vLyAgICAgICAgICAgICAgIHRlYW0yLFxuLy8gICAgICAgICAgICAgICAhdGVhbTIsXG4vLyAgICAgICAgICAgICAgIFwibG9zZXJzXCJcbi8vICAgICAgICAgICAgIClcbi8vICAgICAgICAgICApO1xuLy8gICAgICAgICB9XG4vLyAgICAgICB9IGVsc2Uge1xuLy8gICAgICAgICAvLyBFdmVuIG51bWJlcjogcGFpciBhbGxcbi8vICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvcmRlcmVkTG9zZXJzLmxlbmd0aDsgaSArPSAyKSB7XG4vLyAgICAgICAgICAgY29uc3QgdGVhbTEgPSBvcmRlcmVkTG9zZXJzW2ldO1xuLy8gICAgICAgICAgIGNvbnN0IHRlYW0yID0gb3JkZXJlZExvc2Vyc1tpICsgMV0gPz8gbnVsbDtcbi8vICAgICAgICAgICBuZXh0Um91bmRNYXRjaGVzLnB1c2goXG4vLyAgICAgICAgICAgICBjcmVhdGVNYXRjaChcbi8vICAgICAgICAgICAgICAgYEwke25leHRSb3VuZE51bWJlcn0tJHtNYXRoLmZsb29yKGkgLyAyKSArIDF9YCxcbi8vICAgICAgICAgICAgICAgbmV4dFJvdW5kTnVtYmVyLFxuLy8gICAgICAgICAgICAgICB0ZWFtMSxcbi8vICAgICAgICAgICAgICAgdGVhbTIsXG4vLyAgICAgICAgICAgICAgICF0ZWFtMixcbi8vICAgICAgICAgICAgICAgXCJsb3NlcnNcIlxuLy8gICAgICAgICAgICAgKVxuLy8gICAgICAgICAgICk7XG4vLyAgICAgICAgIH1cbi8vICAgICAgIH1cbi8vICAgICB9XG4vLyAgIH1cblxuLy8gICAvLyAtLS0gV2lubmVyIGRldGVjdGlvbiBsb2dpYyAtLS1cbi8vICAgbGV0IHdpbm5lcjogVGVhbSB8IHVuZGVmaW5lZCA9IHRvdXJuYW1lbnQud2lubmVyO1xuXG4vLyAgIGlmIChpc0NoYW1waW9uc2hpcFJvdW5kKSB7XG4vLyAgICAgLy8gRmluZCB0aGUgbGFzdCBjaGFtcGlvbnNoaXAgbWF0Y2ggcGxheWVkXG4vLyAgICAgY29uc3QgbGFzdENoYW1wTWF0Y2ggPVxuLy8gICAgICAgY2hhbXBpb25zaGlwTWF0Y2hlc1swXSB8fFxuLy8gICAgICAgcHJldkNoYW1waW9uc2hpcE1hdGNoZXNbcHJldkNoYW1waW9uc2hpcE1hdGNoZXMubGVuZ3RoIC0gMV07XG5cbi8vICAgICBpZiAoXG4vLyAgICAgICBsYXN0Q2hhbXBNYXRjaCAmJlxuLy8gICAgICAgbGFzdENoYW1wTWF0Y2guaXNDb21wbGV0ZWQgJiZcbi8vICAgICAgIGxhc3RDaGFtcE1hdGNoLndpbm5lciAmJlxuLy8gICAgICAgbGFzdENoYW1wTWF0Y2gubG9zZXJcbi8vICAgICApIHtcbi8vICAgICAgIGNvbnN0IHdpbm5lcnNCcmFja2V0VGVhbSA9IGxhc3RDaGFtcE1hdGNoLnRlYW0xO1xuLy8gICAgICAgY29uc3QgbG9zZXJzQnJhY2tldFRlYW0gPSBsYXN0Q2hhbXBNYXRjaC50ZWFtMjtcbi8vICAgICAgIGNvbnN0IGxvc2Vyc0JyYWNrZXRUZWFtV29uID1cbi8vICAgICAgICAgbGFzdENoYW1wTWF0Y2gud2lubmVyLmlkID09PSBsb3NlcnNCcmFja2V0VGVhbS5pZDtcblxuLy8gICAgICAgLy8gSWYgbG9zZXIncyBicmFja2V0IHRlYW0gd29uIGZpcnN0IGNoYW1waW9uc2hpcCBtYXRjaCwgd2lubmVyJ3MgYnJhY2tldCB0ZWFtIGdldHMgYW5vdGhlciBjaGFuY2Vcbi8vICAgICAgIGlmIChsb3NlcnNCcmFja2V0VGVhbVdvbiAmJiB0b3VybmFtZW50LmNoYW1waW9uc2hpcE1hdGNoZXNQbGF5ZWQgPT09IDEpIHtcbi8vICAgICAgICAgd2lubmVyID0gdW5kZWZpbmVkOyAvLyBObyB3aW5uZXIgeWV0LCBuZWVkIHJlc2V0IG1hdGNoXG4vLyAgICAgICB9IGVsc2Uge1xuLy8gICAgICAgICAvLyBFaXRoZXIgd2lubmVyJ3MgYnJhY2tldCB0ZWFtIHdvbiBmaXJzdCBtYXRjaCwgb3IgdGhpcyB3YXMgdGhlIHJlc2V0IG1hdGNoXG4vLyAgICAgICAgIHdpbm5lciA9IGxhc3RDaGFtcE1hdGNoLndpbm5lcjtcbi8vICAgICAgIH1cbi8vICAgICB9XG4vLyAgIH1cblxuLy8gICAvLyAtLS0gSU5GSU5JVEUgUkVDVVJTSU9OIEdVQVJEIC0tLVxuLy8gICBjb25zdCBub01vcmVNYXRjaGVzID1cbi8vICAgICAoaXNDaGFtcGlvbnNoaXBSb3VuZCAmJiBjaGFtcGlvbnNoaXBNYXRjaGVzLmxlbmd0aCA9PT0gMCkgfHxcbi8vICAgICAoIWlzQ2hhbXBpb25zaGlwUm91bmQgJiYgbmV4dFJvdW5kTWF0Y2hlcy5sZW5ndGggPT09IDApO1xuXG4vLyAgIGlmIChub01vcmVNYXRjaGVzKSB7XG4vLyAgICAgLy8gVG91cm5hbWVudCBpcyBvdmVyLCBkbyBub3QgYWR2YW5jZSBmdXJ0aGVyXG4vLyAgICAgcmV0dXJuIHtcbi8vICAgICAgIC4uLnRvdXJuYW1lbnQsXG4vLyAgICAgICB3aW5uZXIsXG4vLyAgICAgICBjdXJyZW50Um91bmQ6IHRvdXJuYW1lbnQuY3VycmVudFJvdW5kXG4vLyAgICAgfTtcbi8vICAgfVxuXG4vLyAgIC8vIENvbXBvc2UgdGhlIG5ldyB0b3VybmFtZW50IG9iamVjdFxuICBcbi8vICAgcmV0dXJuIHtcbi8vICAgICAuLi50b3VybmFtZW50LFxuLy8gICAgIHJvdW5kczogW1xuLy8gICAgICAgLi4udG91cm5hbWVudC5yb3VuZHMsXG4vLyAgICAgICB7XG4vLyAgICAgICAgIHJvdW5kTnVtYmVyOiBuZXh0Um91bmROdW1iZXIsXG4vLyAgICAgICAgIG1hdGNoZXM6IGlzQ2hhbXBpb25zaGlwUm91bmQgPyBjaGFtcGlvbnNoaXBNYXRjaGVzIDogbmV4dFJvdW5kTWF0Y2hlcyxcbi8vICAgICAgICAgaXNEb3VibGVFbGltaW5hdGlvbjogdHJ1ZSxcbi8vICAgICAgICAgaXNDaGFtcGlvbnNoaXBSb3VuZFxuLy8gICAgICAgfVxuLy8gICAgIF0sXG4vLyAgICAgY3VycmVudFJvdW5kOiBuZXh0Um91bmROdW1iZXIsXG4vLyAgICAgZWxpbWluYXRlZFRlYW1zOiBbXG4vLyAgICAgICAuLi50b3VybmFtZW50LmVsaW1pbmF0ZWRUZWFtcyxcbi8vICAgICAgIC4uLm5ld2x5RWxpbWluYXRlZC5maWx0ZXIoXG4vLyAgICAgICAgICh0KSA9PiAhdG91cm5hbWVudC5lbGltaW5hdGVkVGVhbXMuc29tZSgoZXQpID0+IGV0LmlkID09PSB0LmlkKVxuLy8gICAgICAgKVxuLy8gICAgIF0sXG4vLyAgICAgY2hhbXBpb25zaGlwTWF0Y2hlc1BsYXllZDogaXNDaGFtcGlvbnNoaXBSb3VuZFxuLy8gICAgICAgPyB0b3VybmFtZW50LmNoYW1waW9uc2hpcE1hdGNoZXNQbGF5ZWQgKyAxXG4vLyAgICAgICA6IHRvdXJuYW1lbnQuY2hhbXBpb25zaGlwTWF0Y2hlc1BsYXllZCxcbi8vICAgICB3aW5uZXJzQnJhY2tldEZpbmFsTG9zZXI6IHRvdXJuYW1lbnQud2lubmVyc0JyYWNrZXRGaW5hbExvc2VyLFxuLy8gICAgIHdpbm5lclxuLy8gICB9O1xuLy8gfTtcblxuXG5cbi8vIGltcG9ydCB0eXBlIHsgVGVhbSB9IGZyb20gXCIuL21sYi10ZWFtc1wiO1xuXG4vLyBleHBvcnQgaW50ZXJmYWNlIE1hdGNoIHtcbi8vICAgaWQ6IHN0cmluZztcbi8vICAgcm91bmROdW1iZXI6IG51bWJlcjtcbi8vICAgdGVhbTE6IFRlYW0gfCBudWxsO1xuLy8gICB0ZWFtMjogVGVhbSB8IG51bGw7XG4vLyAgIGlzQ29tcGxldGVkOiBib29sZWFuO1xuLy8gICBpc0J5ZT86IGJvb2xlYW47XG4vLyAgIHdpbm5lcj86IFRlYW07XG4vLyAgIGxvc2VyPzogVGVhbTtcbi8vICAgYnJhY2tldDogXCJ3aW5uZXJzXCIgfCBcImxvc2Vyc1wiIHwgXCJjaGFtcGlvbnNoaXBcIjtcbi8vICAgc2NvcmU6IHsgdGVhbTFTY29yZTogbnVtYmVyOyB0ZWFtMlNjb3JlOiBudW1iZXIgfTtcbi8vICAgbmV4dE1hdGNoSWQ/OiBzdHJpbmc7XG4vLyAgIG5leHRMb3Nlck1hdGNoSWQ/OiBzdHJpbmc7XG4vLyAgIGVsaW1pbmF0ZWRMYWJlbD86IHN0cmluZzsgLy8gbGFiZWwgZm9yIGVsaW1pbmF0ZWQgdGVhbXMgaW4gbG9zZXJzIGJyYWNrZXRcbi8vICAgcmVxdWlyZXNSZW1hdGNoPzogYm9vbGVhbjsgLy8gaW5kaWNhdGVzIGlmIGEgY2hhbXBpb25zaGlwIHJlbWF0Y2ggaXMgcmVxdWlyZWRcbi8vIH1cblxuLy8gZXhwb3J0IGludGVyZmFjZSBSb3VuZCB7XG4vLyAgIHJvdW5kTnVtYmVyOiBudW1iZXI7XG4vLyAgIG1hdGNoZXM6IE1hdGNoW107XG4vLyAgIGlzRG91YmxlRWxpbWluYXRpb246IGJvb2xlYW47XG4vLyAgIGlzQ2hhbXBpb25zaGlwUm91bmQ6IGJvb2xlYW47XG4vLyB9XG5cbi8vIGV4cG9ydCBpbnRlcmZhY2UgVG91cm5hbWVudCB7XG4vLyAgIHJvdW5kczogUm91bmRbXTtcbi8vICAgY3VycmVudFJvdW5kOiBudW1iZXI7XG4vLyAgIGVsaW1pbmF0ZWRUZWFtczogVGVhbVtdO1xuLy8gICBjaGFtcGlvbnNoaXBNYXRjaGVzUGxheWVkOiBudW1iZXI7XG4vLyAgIHdpbm5lcj86IFRlYW07XG4vLyAgIHdpbm5lcnNCcmFja2V0RmluYWxMb3Nlcj86IFRlYW07IC8vIHRyYWNrcyB0aGUgd2lubmVyJ3MgYnJhY2tldCBmaW5hbCBsb3NlciBmb3IgY2hhbXBpb25zaGlwIHJlbWF0Y2ggbG9naWNcbi8vIH1cblxuLy8gZXhwb3J0IGNvbnN0IGNyZWF0ZU1hdGNoID0gKFxuLy8gICBpZDogc3RyaW5nLFxuLy8gICByb3VuZE51bWJlcjogbnVtYmVyLFxuLy8gICB0ZWFtMTogVGVhbSB8IG51bGwsXG4vLyAgIHRlYW0yOiBUZWFtIHwgbnVsbCxcbi8vICAgaXNCeWU6IGJvb2xlYW4gPSBmYWxzZSxcbi8vICAgYnJhY2tldDogXCJ3aW5uZXJzXCIgfCBcImxvc2Vyc1wiIHwgXCJjaGFtcGlvbnNoaXBcIiA9IFwid2lubmVyc1wiLFxuLy8gICBuZXh0TWF0Y2hJZD86IHN0cmluZyxcbi8vICAgbmV4dExvc2VyTWF0Y2hJZD86IHN0cmluZ1xuLy8gKTogTWF0Y2ggPT4gKHtcbi8vICAgaWQsXG4vLyAgIHJvdW5kTnVtYmVyLFxuLy8gICB0ZWFtMSxcbi8vICAgdGVhbTIsXG4vLyAgIGlzQ29tcGxldGVkOiBpc0J5ZSxcbi8vICAgaXNCeWUsXG4vLyAgIGJyYWNrZXQsXG4vLyAgIHdpbm5lcjogaXNCeWUgPyAodGVhbTEgPz8gdGVhbTIgPz8gdW5kZWZpbmVkKSA6IHVuZGVmaW5lZCxcbi8vICAgbG9zZXI6IGlzQnllID8gdW5kZWZpbmVkIDogdW5kZWZpbmVkLFxuLy8gICBzY29yZTogeyB0ZWFtMVNjb3JlOiAwLCB0ZWFtMlNjb3JlOiAwIH0sXG4vLyAgIG5leHRNYXRjaElkLFxuLy8gICBuZXh0TG9zZXJNYXRjaElkLFxuLy8gICBlbGltaW5hdGVkTGFiZWw6IHVuZGVmaW5lZFxuLy8gfSk7XG5cbi8vIGV4cG9ydCBjb25zdCBjcmVhdGVJbml0aWFsUm91bmRzID0gKHRlYW1zOiBUZWFtW10pOiBUb3VybmFtZW50ID0+IHtcbi8vICAgY29uc3QgbnVtVGVhbXMgPSB0ZWFtcy5sZW5ndGg7XG4vLyAgIGNvbnN0IG1hdGNoZXM6IE1hdGNoW10gPSBbXTtcbi8vICAgY29uc3QgbnVtUm91bmRzID0gTWF0aC5jZWlsKE1hdGgubG9nMihudW1UZWFtcykpO1xuXG4vLyAgIGNvbnN0IGZpcnN0Um91bmRNYXRjaGVzID0gTWF0aC5wb3coMiwgbnVtUm91bmRzIC0gMSk7XG4vLyAgIGxldCBtYXRjaENvdW50ZXIgPSAxO1xuXG4vLyAgIGZvciAobGV0IGkgPSAwOyBpIDwgZmlyc3RSb3VuZE1hdGNoZXM7IGkrKykge1xuLy8gICAgIGNvbnN0IHRlYW0xID0gdGVhbXNbaSAqIDJdIHx8IG51bGw7XG4vLyAgICAgY29uc3QgdGVhbTIgPSB0ZWFtc1tpICogMiArIDFdIHx8IG51bGw7XG4vLyAgICAgY29uc3QgaXNCeWUgPSAhdGVhbTEgfHwgIXRlYW0yO1xuXG4vLyAgICAgY29uc3QgbWF0Y2hJZCA9IGBXMS0ke21hdGNoQ291bnRlcn1gO1xuLy8gICAgIGNvbnN0IG5leHRNYXRjaElkID0gYFcyLSR7TWF0aC5jZWlsKG1hdGNoQ291bnRlciAvIDIpfWA7XG4vLyAgICAgY29uc3QgbmV4dExvc2VyTWF0Y2hJZCA9IGBMMS0ke01hdGguY2VpbChtYXRjaENvdW50ZXIgLyAyKX1gO1xuXG4vLyAgICAgbWF0Y2hlcy5wdXNoKFxuLy8gICAgICAgY3JlYXRlTWF0Y2goXG4vLyAgICAgICAgIG1hdGNoSWQsXG4vLyAgICAgICAgIDEsXG4vLyAgICAgICAgIHRlYW0xLFxuLy8gICAgICAgICB0ZWFtMixcbi8vICAgICAgICAgaXNCeWUsXG4vLyAgICAgICAgIFwid2lubmVyc1wiLFxuLy8gICAgICAgICBuZXh0TWF0Y2hJZCxcbi8vICAgICAgICAgbmV4dExvc2VyTWF0Y2hJZFxuLy8gICAgICAgKVxuLy8gICAgICk7XG4vLyAgICAgbWF0Y2hDb3VudGVyKys7XG4vLyAgIH1cblxuLy8gICByZXR1cm4ge1xuLy8gICAgIHJvdW5kczogW1xuLy8gICAgICAge1xuLy8gICAgICAgICByb3VuZE51bWJlcjogMSxcbi8vICAgICAgICAgbWF0Y2hlcyxcbi8vICAgICAgICAgaXNEb3VibGVFbGltaW5hdGlvbjogdHJ1ZSxcbi8vICAgICAgICAgaXNDaGFtcGlvbnNoaXBSb3VuZDogZmFsc2Vcbi8vICAgICAgIH1cbi8vICAgICBdLFxuLy8gICAgIGN1cnJlbnRSb3VuZDogMSxcbi8vICAgICBlbGltaW5hdGVkVGVhbXM6IFtdLFxuLy8gICAgIGNoYW1waW9uc2hpcE1hdGNoZXNQbGF5ZWQ6IDBcbi8vICAgfTtcbi8vIH07XG5cbi8vIGV4cG9ydCBjb25zdCB1cGRhdGVNYXRjaFNjb3JlID0gKFxuLy8gICBtYXRjaDogTWF0Y2gsXG4vLyAgIG5ld1Njb3JlOiB7IHRlYW0xU2NvcmU6IG51bWJlcjsgdGVhbTJTY29yZTogbnVtYmVyIH1cbi8vICk6IE1hdGNoID0+IHtcbi8vICAgLy8gTWFyayBtYXRjaCBhcyBjb21wbGV0ZWQgaWYgYm90aCB0ZWFtcyBoYXZlIGEgc2NvcmUgZW50ZXJlZCAoZXZlbiBpZiBzY29yZXMgYXJlIGVxdWFsKVxuLy8gICBjb25zdCBpc0NvbXBsZXRlZCA9XG4vLyAgICAgdHlwZW9mIG5ld1Njb3JlLnRlYW0xU2NvcmUgPT09IFwibnVtYmVyXCIgJiZcbi8vICAgICB0eXBlb2YgbmV3U2NvcmUudGVhbTJTY29yZSA9PT0gXCJudW1iZXJcIiAmJlxuLy8gICAgICghaXNOYU4obmV3U2NvcmUudGVhbTFTY29yZSkgJiYgIWlzTmFOKG5ld1Njb3JlLnRlYW0yU2NvcmUpKTtcbi8vICAgbGV0IHdpbm5lcjogVGVhbSB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcbi8vICAgbGV0IGxvc2VyOiBUZWFtIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuLy8gICBpZiAoaXNDb21wbGV0ZWQpIHtcbi8vICAgICBpZiAobmV3U2NvcmUudGVhbTFTY29yZSA+IG5ld1Njb3JlLnRlYW0yU2NvcmUpIHtcbi8vICAgICAgIHdpbm5lciA9IG1hdGNoLnRlYW0xID8geyAuLi5tYXRjaC50ZWFtMSwgd2luczogKG1hdGNoLnRlYW0xLndpbnMgPz8gMCkgKyAxLCBsb3NzZXM6IG1hdGNoLnRlYW0xLmxvc3NlcyA/PyAwIH0gOiB1bmRlZmluZWQ7XG4vLyAgICAgICBsb3NlciA9IG1hdGNoLnRlYW0yID8geyAuLi5tYXRjaC50ZWFtMiwgd2luczogbWF0Y2gudGVhbTIud2lucyA/PyAwLCBsb3NzZXM6IChtYXRjaC50ZWFtMi5sb3NzZXMgPz8gMCkgKyAxIH0gOiB1bmRlZmluZWQ7XG4vLyAgICAgfSBlbHNlIHtcbi8vICAgICAgIHdpbm5lciA9IG1hdGNoLnRlYW0yID8geyAuLi5tYXRjaC50ZWFtMiwgd2luczogKG1hdGNoLnRlYW0yLndpbnMgPz8gMCkgKyAxLCBsb3NzZXM6IG1hdGNoLnRlYW0yLmxvc3NlcyA/PyAwIH0gOiB1bmRlZmluZWQ7XG4vLyAgICAgICBsb3NlciA9IG1hdGNoLnRlYW0xID8geyAuLi5tYXRjaC50ZWFtMSwgd2luczogbWF0Y2gudGVhbTEud2lucyA/PyAwLCBsb3NzZXM6IChtYXRjaC50ZWFtMS5sb3NzZXMgPz8gMCkgKyAxIH0gOiB1bmRlZmluZWQ7XG4vLyAgICAgfVxuLy8gICB9XG4vLyAgIHJldHVybiB7XG4vLyAgICAgLi4ubWF0Y2gsXG4vLyAgICAgc2NvcmU6IG5ld1Njb3JlLFxuLy8gICAgIGlzQ29tcGxldGVkLFxuLy8gICAgIHdpbm5lcixcbi8vICAgICBsb3NlclxuLy8gICB9O1xuLy8gfTtcblxuLy8gLy8gSGVscGVyIHRvIGRlZHVwbGljYXRlIHRlYW1zIGJ5IElEXG4vLyBmdW5jdGlvbiBkZWR1cGVUZWFtcyh0ZWFtczogVGVhbVtdKTogVGVhbVtdIHtcbi8vICAgY29uc3Qgc2VlbiA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuLy8gICByZXR1cm4gdGVhbXMuZmlsdGVyKHRlYW0gPT4ge1xuLy8gICAgIGlmICghdGVhbSkgcmV0dXJuIGZhbHNlO1xuLy8gICAgIGlmIChzZWVuLmhhcyh0ZWFtLmlkKSkgcmV0dXJuIGZhbHNlO1xuLy8gICAgIHNlZW4uYWRkKHRlYW0uaWQpO1xuLy8gICAgIHJldHVybiB0cnVlO1xuLy8gICB9KTtcbi8vIH1cblxuLy8gLy8gSGVscGVyOiBnZXQgYWxsIHRlYW1zIHdpdGggZXhhY3RseSBOIGxvc3Nlc1xuLy8gZnVuY3Rpb24gdGVhbXNXaXRoTG9zc2VzKGxvc3NDb3VudHM6IFJlY29yZDxzdHJpbmcsIG51bWJlcj4sIG46IG51bWJlcik6IHN0cmluZ1tdIHtcbi8vICAgcmV0dXJuIE9iamVjdC5rZXlzKGxvc3NDb3VudHMpLmZpbHRlcih0ZWFtSWQgPT4gbG9zc0NvdW50c1t0ZWFtSWRdID09PSBuKTtcbi8vIH1cblxuLy8gZXhwb3J0IGNvbnN0IGFkdmFuY2VUb05leHRSb3VuZCA9ICh0b3VybmFtZW50OiBUb3VybmFtZW50KTogVG91cm5hbWVudCA9PiB7XG4vLyAgIGNvbnN0IGN1cnJlbnRSb3VuZCA9IHRvdXJuYW1lbnQucm91bmRzW3RvdXJuYW1lbnQucm91bmRzLmxlbmd0aCAtIDFdO1xuLy8gICBjb25zdCBuZXh0Um91bmROdW1iZXIgPSB0b3VybmFtZW50LmN1cnJlbnRSb3VuZCArIDE7XG5cbi8vICAgLy8gVHJhY2sgYWxsIGxvc3NlcyBhbmQgd2lucyBhY3Jvc3MgdGhlIHRvdXJuYW1lbnRcbi8vICAgY29uc3QgbG9zc0NvdW50czogUmVjb3JkPHN0cmluZywgbnVtYmVyPiA9IHt9O1xuLy8gICBjb25zdCB3aW5zQ291bnRzOiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+ID0ge307XG4vLyAgIHRvdXJuYW1lbnQucm91bmRzLmZvckVhY2goKHJvdW5kKSA9PiB7XG4vLyAgICAgcm91bmQubWF0Y2hlcy5mb3JFYWNoKChtYXRjaCkgPT4ge1xuLy8gICAgICAgaWYgKG1hdGNoLmlzQ29tcGxldGVkICYmIG1hdGNoLmxvc2VyKSB7XG4vLyAgICAgICAgIGxvc3NDb3VudHNbbWF0Y2gubG9zZXIuaWRdID0gKGxvc3NDb3VudHNbbWF0Y2gubG9zZXIuaWRdIHx8IDApICsgMTtcbi8vICAgICAgIH1cbi8vICAgICAgIGlmIChtYXRjaC5pc0NvbXBsZXRlZCAmJiBtYXRjaC53aW5uZXIpIHtcbi8vICAgICAgICAgd2luc0NvdW50c1ttYXRjaC53aW5uZXIuaWRdID0gKHdpbnNDb3VudHNbbWF0Y2gud2lubmVyLmlkXSB8fCAwKSArIDE7XG4vLyAgICAgICB9XG4vLyAgICAgfSk7XG4vLyAgIH0pO1xuXG4vLyAgIC8vIEdhdGhlciBhbGwgdGVhbXMgZXZlciBpbiB0aGUgdG91cm5hbWVudCwgYXR0YWNoaW5nIHdpbnNcbi8vICAgY29uc3QgYWxsVGVhbXM6IFRlYW1bXSA9IFtdO1xuLy8gICBjb25zdCB0ZWFtSWRzID0gbmV3IFNldDxzdHJpbmc+KCk7XG4vLyAgIGZvciAoY29uc3Qgcm91bmQgb2YgdG91cm5hbWVudC5yb3VuZHMpIHtcbi8vICAgICBmb3IgKGNvbnN0IG1hdGNoIG9mIHJvdW5kLm1hdGNoZXMpIHtcbi8vICAgICAgIGlmIChtYXRjaC50ZWFtMSAmJiAhdGVhbUlkcy5oYXMobWF0Y2gudGVhbTEuaWQpKSB7XG4vLyAgICAgICAgIGFsbFRlYW1zLnB1c2goe1xuLy8gICAgICAgICAgIC4uLm1hdGNoLnRlYW0xLFxuLy8gICAgICAgICAgIHdpbnM6IHdpbnNDb3VudHNbbWF0Y2gudGVhbTEuaWRdIHx8IDAsXG4vLyAgICAgICAgICAgbG9zc2VzOiBsb3NzQ291bnRzW21hdGNoLnRlYW0xLmlkXSB8fCAwXG4vLyAgICAgICAgIH0pO1xuLy8gICAgICAgICB0ZWFtSWRzLmFkZChtYXRjaC50ZWFtMS5pZCk7XG4vLyAgICAgICB9XG4vLyAgICAgICBpZiAobWF0Y2gudGVhbTIgJiYgIXRlYW1JZHMuaGFzKG1hdGNoLnRlYW0yLmlkKSkge1xuLy8gICAgICAgICBhbGxUZWFtcy5wdXNoKHtcbi8vICAgICAgICAgICAuLi5tYXRjaC50ZWFtMixcbi8vICAgICAgICAgICB3aW5zOiB3aW5zQ291bnRzW21hdGNoLnRlYW0yLmlkXSB8fCAwLFxuLy8gICAgICAgICAgIGxvc3NlczogbG9zc0NvdW50c1ttYXRjaC50ZWFtMi5pZF0gfHwgMFxuLy8gICAgICAgICB9KTtcbi8vICAgICAgICAgdGVhbUlkcy5hZGQobWF0Y2gudGVhbTIuaWQpO1xuLy8gICAgICAgfVxuLy8gICAgIH1cbi8vICAgfVxuXG4vLyAgIC8vIElkZW50aWZ5IG5ld2x5IGVsaW1pbmF0ZWQgdGVhbXMgKDIgbG9zc2VzKVxuLy8gICBjb25zdCBuZXdseUVsaW1pbmF0ZWQ6IFRlYW1bXSA9IFtdO1xuLy8gICBmb3IgKGNvbnN0IHRlYW0gb2YgYWxsVGVhbXMpIHtcbi8vICAgICBpZiAoXG4vLyAgICAgICAobG9zc0NvdW50c1t0ZWFtLmlkXSB8fCAwKSA+PSAyICYmXG4vLyAgICAgICAhdG91cm5hbWVudC5lbGltaW5hdGVkVGVhbXMuc29tZSgodCkgPT4gdC5pZCA9PT0gdGVhbS5pZClcbi8vICAgICApIHtcbi8vICAgICAgIG5ld2x5RWxpbWluYXRlZC5wdXNoKHRlYW0pO1xuLy8gICAgIH1cbi8vICAgfVxuXG4vLyAgIC8vIFdpbm5lcnM6IHRlYW1zIHdpdGggMCBsb3NzZXMgYW5kIG5vdCBlbGltaW5hdGVkXG4vLyAgIGNvbnN0IHdpbm5lcnNCcmFja2V0VGVhbXMgPSBhbGxUZWFtc1xuLy8gICAgIC5maWx0ZXIoXG4vLyAgICAgICAodGVhbSkgPT5cbi8vICAgICAgICAgKGxvc3NDb3VudHNbdGVhbS5pZF0gfHwgMCkgPT09IDAgJiZcbi8vICAgICAgICAgIXRvdXJuYW1lbnQuZWxpbWluYXRlZFRlYW1zLnNvbWUoKHQpID0+IHQuaWQgPT09IHRlYW0uaWQpICYmXG4vLyAgICAgICAgICFuZXdseUVsaW1pbmF0ZWQuc29tZSgodCkgPT4gdC5pZCA9PT0gdGVhbS5pZCkgJiZcbi8vICAgICAgICAgIXRlYW0uaWQuc3RhcnRzV2l0aCgndGJkLScpIC8vIEV4Y2x1ZGUgYW55IHBoYW50b20gVEJEIHRlYW1zXG4vLyAgICAgKVxuLy8gICAgIC5tYXAoKHRlYW0pID0+ICh7IC4uLnRlYW0sIGxvc3NlczogbG9zc0NvdW50c1t0ZWFtLmlkXSB8fCAwLCB3aW5zOiB3aW5zQ291bnRzW3RlYW0uaWRdIHx8IDAgfSkpO1xuLy8gICAvLyBMb3NlcnM6IHRlYW1zIHdpdGggMSBsb3NzIGFuZCBub3QgZWxpbWluYXRlZFxuLy8gICBjb25zdCBsb3NlcnNCcmFja2V0VGVhbXMgPSBhbGxUZWFtc1xuLy8gICAgIC5maWx0ZXIoXG4vLyAgICAgICAodGVhbSkgPT5cbi8vICAgICAgICAgKGxvc3NDb3VudHNbdGVhbS5pZF0gfHwgMCkgPT09IDEgJiZcbi8vICAgICAgICAgIXRvdXJuYW1lbnQuZWxpbWluYXRlZFRlYW1zLnNvbWUoKHQpID0+IHQuaWQgPT09IHRlYW0uaWQpICYmXG4vLyAgICAgICAgICFuZXdseUVsaW1pbmF0ZWQuc29tZSgodCkgPT4gdC5pZCA9PT0gdGVhbS5pZClcbi8vICAgICApXG4vLyAgICAgLm1hcCgodGVhbSkgPT4gKHtcbi8vICAgICAgIC4uLnRlYW0sXG4vLyAgICAgICBsb3NzZXM6IGxvc3NDb3VudHNbdGVhbS5pZF0gfHwgMCxcbi8vICAgICAgIHdpbnM6IHdpbnNDb3VudHNbdGVhbS5pZF0gfHwgMFxuLy8gICAgIH0pKTtcblxuLy8gICBsZXQgaXNDaGFtcGlvbnNoaXBSb3VuZCA9IGZhbHNlO1xuLy8gICBsZXQgY2hhbXBpb25zaGlwTWF0Y2hlczogTWF0Y2hbXSA9IFtdO1xuLy8gICBsZXQgbmV4dFJvdW5kTWF0Y2hlczogTWF0Y2hbXSA9IFtdO1xuXG4vLyAgIGNvbnN0IHByZXZDaGFtcGlvbnNoaXBNYXRjaGVzID0gdG91cm5hbWVudC5yb3VuZHNcbi8vICAgICAuZmlsdGVyKChyKSA9PiByLmlzQ2hhbXBpb25zaGlwUm91bmQpXG4vLyAgICAgLmZsYXRNYXAoKHIpID0+IHIubWF0Y2hlcylcbi8vICAgICAuZmlsdGVyKChtKSA9PiBtLmJyYWNrZXQgPT09IFwiY2hhbXBpb25zaGlwXCIpO1xuXG4vLyAgIC8vIC0tLSBDSEFNUElPTlNISVAgTE9HSUMgLS0tXG5cbi8vICAgLy8gQ2hlY2sgaWYgYSBjaGFtcGlvbnNoaXAgbWF0Y2ggYWxyZWFkeSBoYXBwZW5lZCBhbmQgd2FzIGNvbXBsZXRlZFxuLy8gICBpZiAoXG4vLyAgICAgcHJldkNoYW1waW9uc2hpcE1hdGNoZXMubGVuZ3RoID49IDEgJiZcbi8vICAgICBwcmV2Q2hhbXBpb25zaGlwTWF0Y2hlc1twcmV2Q2hhbXBpb25zaGlwTWF0Y2hlcy5sZW5ndGggLSAxXS5pc0NvbXBsZXRlZFxuLy8gICApIHtcbi8vICAgICBjb25zdCBsYXN0Q2hhbXBNYXRjaCA9XG4vLyAgICAgICBwcmV2Q2hhbXBpb25zaGlwTWF0Y2hlc1twcmV2Q2hhbXBpb25zaGlwTWF0Y2hlcy5sZW5ndGggLSAxXTtcbi8vICAgICBjb25zdCB3aW5uZXJzQnJhY2tldFRlYW0gPSBsYXN0Q2hhbXBNYXRjaC50ZWFtMTtcbi8vICAgICBjb25zdCBsb3NlcnNCcmFja2V0VGVhbSA9IGxhc3RDaGFtcE1hdGNoLnRlYW0yO1xuXG4vLyAgICAgLy8gSWYgbG9zZXIncyBicmFja2V0IHRlYW0gd29uIHRoZSBmaXJzdCBjaGFtcGlvbnNoaXAgbWF0Y2gsIHdpbm5lcidzIGJyYWNrZXQgdGVhbSBnZXRzIGFub3RoZXIgY2hhbmNlXG4vLyAgICAgaWYgKFxuLy8gICAgICAgbGFzdENoYW1wTWF0Y2gud2lubmVyPy5pZCA9PT0gbG9zZXJzQnJhY2tldFRlYW0/LmlkICYmXG4vLyAgICAgICB0b3VybmFtZW50LmNoYW1waW9uc2hpcE1hdGNoZXNQbGF5ZWQgPT09IDFcbi8vICAgICApIHtcbi8vICAgICAgIGlzQ2hhbXBpb25zaGlwUm91bmQgPSB0cnVlO1xuLy8gICAgICAgLy8gQ3JlYXRlIHRoZSBcInJlc2V0XCIgbWF0Y2ggd2l0aCByZXF1aXJlc1JlbWF0Y2g6IHRydWVcbi8vICAgICAgIGNoYW1waW9uc2hpcE1hdGNoZXMucHVzaCh7XG4vLyAgICAgICAgIC4uLmNyZWF0ZU1hdGNoKFxuLy8gICAgICAgICAgIGBDJHtuZXh0Um91bmROdW1iZXJ9LTFgLFxuLy8gICAgICAgICAgIG5leHRSb3VuZE51bWJlcixcbi8vICAgICAgICAgICB3aW5uZXJzQnJhY2tldFRlYW0sXG4vLyAgICAgICAgICAgbG9zZXJzQnJhY2tldFRlYW0sXG4vLyAgICAgICAgICAgZmFsc2UsXG4vLyAgICAgICAgICAgXCJjaGFtcGlvbnNoaXBcIlxuLy8gICAgICAgICApLFxuLy8gICAgICAgICByZXF1aXJlc1JlbWF0Y2g6IHRydWVcbi8vICAgICAgIH0pO1xuXG4vLyAgICAgICAvLyBJbmNyZW1lbnQgdGhlIHdpbm5lcidzIGJyYWNrZXQgdGVhbSdzIGxvc3MgY291bnQgZm9yIHRoZSByZWNvcmRcbi8vICAgICAgIGlmICh3aW5uZXJzQnJhY2tldFRlYW0gJiYgdHlwZW9mIHdpbm5lcnNCcmFja2V0VGVhbS5sb3NzZXMgPT09IFwibnVtYmVyXCIpIHtcbi8vICAgICAgICAgd2lubmVyc0JyYWNrZXRUZWFtLmxvc3NlcyArPSAxO1xuLy8gICAgICAgfVxuLy8gICAgIH0gZWxzZSB7XG4vLyAgICAgICAvLyBFaXRoZXIgd2lubmVyJ3MgYnJhY2tldCB0ZWFtIHdvbiBmaXJzdCBtYXRjaCwgb3IgdGhpcyB3YXMgdGhlIHJlc2V0IG1hdGNoXG4vLyAgICAgICBpc0NoYW1waW9uc2hpcFJvdW5kID0gdHJ1ZTtcbi8vICAgICAgIC8vIE5vIG5ldyBtYXRjaGVzLCB3aW5uZXIgd2lsbCBiZSBkZXRlcm1pbmVkIGluIHdpbm5lciBkZXRlY3Rpb24gbG9naWNcbi8vICAgICB9XG4vLyAgIH1cbi8vICAgLy8gQ2hlY2sgaWYgd2UncmUgcmVhZHkgZm9yIHRoZSBjaGFtcGlvbnNoaXAgbWF0Y2ggLSBvbmUgdGVhbSBpbiBlYWNoIGJyYWNrZXQgYW5kIGxvc2VyJ3MgZmluYWwgaXMgY29tcGxldGVcbi8vICAgZWxzZSBpZiAoXG4vLyAgICAgd2lubmVyc0JyYWNrZXRUZWFtcy5sZW5ndGggPT09IDEgJiZcbi8vICAgICAvLyBJZiBBTlkgbG9zZXJzIGJyYWNrZXQgbWF0Y2ggaW4gdGhlIGN1cnJlbnQgcm91bmQgaXMgaW5jb21wbGV0ZSwgc2hvdyB3YWl0aW5nIGNhcmRzXG4vLyAgICAgY3VycmVudFJvdW5kLm1hdGNoZXMuc29tZShcbi8vICAgICAgIChtKSA9PlxuLy8gICAgICAgICAobS5icmFja2V0ID09PSBcImxvc2Vyc1wiIHx8IG0uaWQuaW5jbHVkZXMoXCJMb3NlcnNMYXN0XCIpKSAmJlxuLy8gICAgICAgICAhbS5pc0NvbXBsZXRlZFxuLy8gICAgIClcbi8vICAgKSB7XG4vLyAgICAgLy8gTm90IHJlYWR5IGZvciBjaGFtcGlvbnNoaXA6IHNob3cgd2FpdGluZyBjYXJkcyBmb3IgYm90aFxuLy8gICAgIG5leHRSb3VuZE1hdGNoZXMucHVzaChcbi8vICAgICAgIGNyZWF0ZU1hdGNoKFxuLy8gICAgICAgICBgVyR7bmV4dFJvdW5kTnVtYmVyfS13YWl0aW5nYCxcbi8vICAgICAgICAgbmV4dFJvdW5kTnVtYmVyLFxuLy8gICAgICAgICB3aW5uZXJzQnJhY2tldFRlYW1zWzBdLFxuLy8gICAgICAgICB7XG4vLyAgICAgICAgICAgaWQ6IGB0YmQtJHtuZXh0Um91bmROdW1iZXJ9LXdhaXRpbmdgLFxuLy8gICAgICAgICAgIG5hbWU6IFwiVEJEXCIsXG4vLyAgICAgICAgICAgY2l0eTogXCJcIixcbi8vICAgICAgICAgICBsb3NzZXM6IDBcbi8vICAgICAgICAgfSxcbi8vICAgICAgICAgdHJ1ZSxcbi8vICAgICAgICAgXCJ3aW5uZXJzXCJcbi8vICAgICAgIClcbi8vICAgICApO1xuLy8gICAgIGlmICh0b3VybmFtZW50Lndpbm5lcnNCcmFja2V0RmluYWxMb3Nlcikge1xuLy8gICAgICAgbmV4dFJvdW5kTWF0Y2hlcy5wdXNoKFxuLy8gICAgICAgICBjcmVhdGVNYXRjaChcbi8vICAgICAgICAgICBgTG9zZXJzTGFzdC0ke25leHRSb3VuZE51bWJlcn1gLFxuLy8gICAgICAgICAgIG5leHRSb3VuZE51bWJlcixcbi8vICAgICAgICAgICB0b3VybmFtZW50Lndpbm5lcnNCcmFja2V0RmluYWxMb3Nlcixcbi8vICAgICAgICAgICB7XG4vLyAgICAgICAgICAgICBpZDogYHRiZC1sb3NlcnMtJHtuZXh0Um91bmROdW1iZXJ9YCxcbi8vICAgICAgICAgICAgIG5hbWU6IFwiVEJEXCIsXG4vLyAgICAgICAgICAgICBjaXR5OiBcIlwiLFxuLy8gICAgICAgICAgICAgbG9zc2VzOiAwXG4vLyAgICAgICAgICAgfSxcbi8vICAgICAgICAgICB0cnVlLFxuLy8gICAgICAgICAgIFwibG9zZXJzXCJcbi8vICAgICAgICAgKVxuLy8gICAgICAgKTtcbi8vICAgICB9XG4vLyAgICAgbG9nVG91cm5hbWVudFN0YXRlKHtcbi8vICAgICAgIHJvdW5kTnVtYmVyOiBuZXh0Um91bmROdW1iZXIsXG4vLyAgICAgICB3aW5uZXJzQnJhY2tldFRlYW1zLFxuLy8gICAgICAgbG9zZXJzQnJhY2tldFRlYW1zLFxuLy8gICAgICAgbWF0Y2hlczogbmV4dFJvdW5kTWF0Y2hlcyxcbi8vICAgICAgIHdpbm5lcnNCcmFja2V0RmluYWxMb3NlcjogdG91cm5hbWVudC53aW5uZXJzQnJhY2tldEZpbmFsTG9zZXJcbi8vICAgICB9KTtcbi8vICAgICBjcmVhdGVMb3NlcnNCcmFja2V0TWF0Y2hlcygpO1xuLy8gICB9XG4vLyAgIC8vIENoZWNrIGlmIHdlIGhhdmUgYSBsb3NlciBmcm9tIHdpbm5lcidzIGJyYWNrZXQgZmluYWwgd2FpdGluZyB0byBwbGF5IGFnYWluc3QgbG9zZXIncyBicmFja2V0IHdpbm5lclxuLy8gICBlbHNlIGlmIChcbi8vICAgICB3aW5uZXJzQnJhY2tldFRlYW1zLmxlbmd0aCA9PT0gMSAmJlxuLy8gICAgIHRvdXJuYW1lbnQud2lubmVyc0JyYWNrZXRGaW5hbExvc2VyXG4vLyAgICkge1xuLy8gICAgIC8vIEFsd2F5cyBzaG93IHRoZSB3YWl0aW5nIGNhcmQgZm9yIHRoZSBsb3NlcnMgYnJhY2tldCBmaW5hbCBsb3NlciwgZXZlbiBpZiB0aGUgb3Bwb25lbnQgaXMgVEJEXG4vLyAgICAgbGV0IGxvc2Vyc0JyYWNrZXRXaW5uZXIgPSBudWxsO1xuLy8gICAgIGlmIChsb3NlcnNCcmFja2V0VGVhbXMubGVuZ3RoID49IDEpIHtcbi8vICAgICAgIGxvc2Vyc0JyYWNrZXRXaW5uZXIgPSBjdXJyZW50Um91bmQubWF0Y2hlc1xuLy8gICAgICAgICAuZmlsdGVyKChtKSA9PiBtLmJyYWNrZXQgPT09IFwibG9zZXJzXCIgJiYgbS5pc0NvbXBsZXRlZCAmJiBtLndpbm5lcilcbi8vICAgICAgICAgLm1hcCgobSkgPT4gbS53aW5uZXIhKVxuLy8gICAgICAgICAuZmluZCgod2lubmVyKSA9PiBsb3NlcnNCcmFja2V0VGVhbXMuc29tZSgodCkgPT4gdC5pZCA9PT0gd2lubmVyLmlkKSk7XG4vLyAgICAgfVxuLy8gICAgIGNvbnN0IG9wcG9uZW50ID1cbi8vICAgICAgIGxvc2Vyc0JyYWNrZXRXaW5uZXIgJiZcbi8vICAgICAgIGxvc2Vyc0JyYWNrZXRXaW5uZXIuaWQgIT09IHRvdXJuYW1lbnQud2lubmVyc0JyYWNrZXRGaW5hbExvc2VyLmlkXG4vLyAgICAgICAgID8gbG9zZXJzQnJhY2tldFdpbm5lclxuLy8gICAgICAgICA6IHtcbi8vICAgICAgICAgICAgIGlkOiBgdGJkLWxvc2Vycy0ke25leHRSb3VuZE51bWJlcn1gLFxuLy8gICAgICAgICAgICAgbmFtZTogXCJUQkRcIixcbi8vICAgICAgICAgICAgIGNpdHk6IFwiXCIsXG4vLyAgICAgICAgICAgICBsb3NzZXM6IDBcbi8vICAgICAgICAgICB9O1xuLy8gICAgIGNvbnN0IGlzQnllID1cbi8vICAgICAgICFsb3NlcnNCcmFja2V0V2lubmVyIHx8XG4vLyAgICAgICBsb3NlcnNCcmFja2V0V2lubmVyLmlkID09PSB0b3VybmFtZW50Lndpbm5lcnNCcmFja2V0RmluYWxMb3Nlci5pZDtcbi8vICAgICBuZXh0Um91bmRNYXRjaGVzLnB1c2goXG4vLyAgICAgICBjcmVhdGVNYXRjaChcbi8vICAgICAgICAgYExvc2Vyc0xhc3QtJHtuZXh0Um91bmROdW1iZXJ9YCxcbi8vICAgICAgICAgbmV4dFJvdW5kTnVtYmVyLFxuLy8gICAgICAgICB0b3VybmFtZW50Lndpbm5lcnNCcmFja2V0RmluYWxMb3Nlcixcbi8vICAgICAgICAgb3Bwb25lbnQsXG4vLyAgICAgICAgIGlzQnllLFxuLy8gICAgICAgICBcImxvc2Vyc1wiXG4vLyAgICAgICApXG4vLyAgICAgKTtcbi8vICAgICAvLyBBbHdheXMgcmVuZGVyIHRoZSB3aW5uZXJzIGJyYWNrZXQgY2hhbXBpb24gYXMgYSBub24tc2NvcmVhYmxlIHdhaXRpbmcgY2FyZCBpZiB0aGUgbG9zZXJzIGJyYWNrZXQgaXMgbm90IHJlc29sdmVkXG4vLyAgICAgbmV4dFJvdW5kTWF0Y2hlcy5wdXNoKFxuLy8gICAgICAgY3JlYXRlTWF0Y2goXG4vLyAgICAgICAgIGBXJHtuZXh0Um91bmROdW1iZXJ9LXdhaXRpbmdgLFxuLy8gICAgICAgICBuZXh0Um91bmROdW1iZXIsXG4vLyAgICAgICAgIHdpbm5lcnNCcmFja2V0VGVhbXNbMF0sXG4vLyAgICAgICAgIHtcbi8vICAgICAgICAgICBpZDogYHRiZC0ke25leHRSb3VuZE51bWJlcn0td2FpdGluZ2AsXG4vLyAgICAgICAgICAgbmFtZTogXCJUQkRcIixcbi8vICAgICAgICAgICBjaXR5OiBcIlwiLFxuLy8gICAgICAgICAgIGxvc3NlczogMFxuLy8gICAgICAgICB9LFxuLy8gICAgICAgICB0cnVlLCAvLyBpc0J5ZTogdHJ1ZSB0byBlbnN1cmUgaXQncyBub3Qgc2NvcmVhYmxlXG4vLyAgICAgICAgIFwid2lubmVyc1wiXG4vLyAgICAgICApXG4vLyAgICAgKTtcbi8vICAgICBjcmVhdGVMb3NlcnNCcmFja2V0TWF0Y2hlcygpO1xuLy8gICB9XG4vLyAgIC8vIE90aGVyd2lzZSwgY29udGludWUgd2l0aCBub3JtYWwgYnJhY2tldCBwbGF5XG4vLyAgIGVsc2Uge1xuLy8gICAgIC8vIElmIG9ubHkgb25lIHRlYW0gaW4gd2lubmVycyBhbmQgbG9zZXJzIGJyYWNrZXQgaXMgbm90IHJlc29sdmVkLCBhbHdheXMgc2hvdyB3YWl0aW5nIGNhcmRzXG4vLyAgICAgaWYgKHdpbm5lcnNCcmFja2V0VGVhbXMubGVuZ3RoID09PSAxICYmIGxvc2Vyc0JyYWNrZXRUZWFtcy5sZW5ndGggPj0gMSkge1xuLy8gICAgICAgbmV4dFJvdW5kTWF0Y2hlcy5wdXNoKFxuLy8gICAgICAgICBjcmVhdGVNYXRjaChcbi8vICAgICAgICAgICBgVyR7bmV4dFJvdW5kTnVtYmVyfS13YWl0aW5nYCxcbi8vICAgICAgICAgICBuZXh0Um91bmROdW1iZXIsXG4vLyAgICAgICAgICAgd2lubmVyc0JyYWNrZXRUZWFtc1swXSxcbi8vICAgICAgICAgICB7XG4vLyAgICAgICAgICAgICBpZDogYHRiZC0ke25leHRSb3VuZE51bWJlcn0td2FpdGluZ2AsXG4vLyAgICAgICAgICAgICBuYW1lOiBcIlRCRFwiLFxuLy8gICAgICAgICAgICAgY2l0eTogXCJcIixcbi8vICAgICAgICAgICAgIGxvc3NlczogMFxuLy8gICAgICAgICAgIH0sXG4vLyAgICAgICAgICAgdHJ1ZSxcbi8vICAgICAgICAgICBcIndpbm5lcnNcIlxuLy8gICAgICAgICApXG4vLyAgICAgICApO1xuLy8gICAgICAgaWYgKHRvdXJuYW1lbnQud2lubmVyc0JyYWNrZXRGaW5hbExvc2VyKSB7XG4vLyAgICAgICAgIG5leHRSb3VuZE1hdGNoZXMucHVzaChcbi8vICAgICAgICAgICBjcmVhdGVNYXRjaChcbi8vICAgICAgICAgICAgIGBMb3NlcnNMYXN0LSR7bmV4dFJvdW5kTnVtYmVyfWAsXG4vLyAgICAgICAgICAgICBuZXh0Um91bmROdW1iZXIsXG4vLyAgICAgICAgICAgICB0b3VybmFtZW50Lndpbm5lcnNCcmFja2V0RmluYWxMb3Nlcixcbi8vICAgICAgICAgICAgIHtcbi8vICAgICAgICAgICAgICAgaWQ6IGB0YmQtbG9zZXJzLSR7bmV4dFJvdW5kTnVtYmVyfWAsXG4vLyAgICAgICAgICAgICAgIG5hbWU6IFwiVEJEXCIsXG4vLyAgICAgICAgICAgICAgIGNpdHk6IFwiXCIsXG4vLyAgICAgICAgICAgICAgIGxvc3NlczogMFxuLy8gICAgICAgICAgICAgfSxcbi8vICAgICAgICAgICAgIHRydWUsXG4vLyAgICAgICAgICAgICBcImxvc2Vyc1wiXG4vLyAgICAgICAgICAgKVxuLy8gICAgICAgICApO1xuLy8gICAgICAgfVxuLy8gICAgIH1cbi8vICAgfVxuXG4vLyAgIC8vIEhlbHBlciBmdW5jdGlvbiB0byBjcmVhdGUgc3RhbmRhcmQgYnJhY2tldCBtYXRjaGVzXG4vLyAgIGZ1bmN0aW9uIGNyZWF0ZVN0YW5kYXJkQnJhY2tldE1hdGNoZXMoKSB7XG4vLyAgICAgLy8gLS0tIFdpbm5lcnMgQnJhY2tldCBNYXRjaGVzIC0tLVxuLy8gICAgIGxldCBtYXRjaENvdW50ZXIgPSAxO1xuLy8gICAgIGZvciAobGV0IGkgPSAwOyBpIDwgd2lubmVyc0JyYWNrZXRUZWFtcy5sZW5ndGg7IGkgKz0gMikge1xuLy8gICAgICAgY29uc3QgdGVhbTEgPSB3aW5uZXJzQnJhY2tldFRlYW1zW2ldO1xuLy8gICAgICAgY29uc3QgdGVhbTIgPSB3aW5uZXJzQnJhY2tldFRlYW1zW2kgKyAxXSA/PyBudWxsO1xuLy8gICAgICAgY29uc3QgaXNCeWUgPSAhdGVhbTI7XG4vLyAgICAgICBuZXh0Um91bmRNYXRjaGVzLnB1c2goXG4vLyAgICAgICAgIGNyZWF0ZU1hdGNoKFxuLy8gICAgICAgICAgIGBXJHtuZXh0Um91bmROdW1iZXJ9LSR7bWF0Y2hDb3VudGVyfWAsXG4vLyAgICAgICAgICAgbmV4dFJvdW5kTnVtYmVyLFxuLy8gICAgICAgICAgIHRlYW0xLFxuLy8gICAgICAgICAgIHRlYW0yLFxuLy8gICAgICAgICAgIGlzQnllLFxuLy8gICAgICAgICAgIFwid2lubmVyc1wiXG4vLyAgICAgICAgIClcbi8vICAgICAgICk7XG4vLyAgICAgICBtYXRjaENvdW50ZXIrKztcbi8vICAgICB9XG5cbi8vICAgICAvLyBDcmVhdGUgbG9zZXJzIGJyYWNrZXQgbWF0Y2hlcyBzZXBhcmF0ZWx5XG4vLyAgICAgY3JlYXRlTG9zZXJzQnJhY2tldE1hdGNoZXMoKTtcbi8vICAgfVxuXG4vLyAgIC8vIEhlbHBlciBmdW5jdGlvbiB0byBjcmVhdGUgbG9zZXJzIGJyYWNrZXQgbWF0Y2hlc1xuLy8gICBmdW5jdGlvbiBjcmVhdGVMb3NlcnNCcmFja2V0TWF0Y2hlcygpIHtcbi8vICAgICAvLyAtLS0gTG9zZXJzIEJyYWNrZXQgTWF0Y2hlcyAtLS1cbi8vICAgICBjb25zdCBlbGlnaWJsZUxvc2VycyA9IGFsbFRlYW1zLmZpbHRlcihcbi8vICAgICAgICh0ZWFtKSA9PlxuLy8gICAgICAgICAobG9zc0NvdW50c1t0ZWFtLmlkXSB8fCAwKSA9PT0gMSAmJlxuLy8gICAgICAgICAhdG91cm5hbWVudC5lbGltaW5hdGVkVGVhbXMuc29tZSgodCkgPT4gdC5pZCA9PT0gdGVhbS5pZCkgJiZcbi8vICAgICAgICAgIW5ld2x5RWxpbWluYXRlZC5zb21lKCh0KSA9PiB0LmlkID09PSB0ZWFtLmlkKSAmJlxuLy8gICAgICAgICAvLyBFeGNsdWRlIHdpbm5lcidzIGJyYWNrZXQgZmluYWwgbG9zZXIgaWYgaXQgZXhpc3RzIGJ1dCBoYXNuJ3QgcGxheWVkIHlldCBpbiBsb3NlcnNcbi8vICAgICAgICAgIShcbi8vICAgICAgICAgICB0b3VybmFtZW50Lndpbm5lcnNCcmFja2V0RmluYWxMb3NlciAmJlxuLy8gICAgICAgICAgIHRvdXJuYW1lbnQud2lubmVyc0JyYWNrZXRGaW5hbExvc2VyLmlkID09PSB0ZWFtLmlkXG4vLyAgICAgICAgIClcbi8vICAgICApO1xuXG4vLyAgICAgLy8gRmluZCB0ZWFtcyByZWNlbnRseSBkcm9wcGVkIGZyb20gd2lubmVycyBicmFja2V0XG4vLyAgICAgY29uc3QganVzdERyb3BwZWRGcm9tV2lubmVycyA9IGN1cnJlbnRSb3VuZC5tYXRjaGVzXG4vLyAgICAgICAuZmlsdGVyKChtKSA9PiBtLmJyYWNrZXQgPT09IFwid2lubmVyc1wiICYmIG0ubG9zZXIgJiYgbS5pc0NvbXBsZXRlZClcbi8vICAgICAgIC5tYXAoKG0pID0+IG0ubG9zZXIhKVxuLy8gICAgICAgLmZpbHRlcigobG9zZXIpID0+IGVsaWdpYmxlTG9zZXJzLnNvbWUoKHQpID0+IHQuaWQgPT09IGxvc2VyLmlkKSk7XG5cbi8vICAgICAvLyBJZiB0aGlzIGlzIHRoZSB3aW5uZXIncyBicmFja2V0IGZpbmFsLCBzdG9yZSB0aGUgbG9zZXIgZm9yIGxhdGVyIHVzZVxuLy8gICAgIGlmIChcbi8vICAgICAgIGN1cnJlbnRSb3VuZC5tYXRjaGVzLnNvbWUoXG4vLyAgICAgICAgIChtKSA9PlxuLy8gICAgICAgICAgIG0uYnJhY2tldCA9PT0gXCJ3aW5uZXJzXCIgJiZcbi8vICAgICAgICAgICB3aW5uZXJzQnJhY2tldFRlYW1zLmxlbmd0aCA9PT0gMSAmJlxuLy8gICAgICAgICAgIG0ubG9zZXIgJiZcbi8vICAgICAgICAgICBtLmlzQ29tcGxldGVkXG4vLyAgICAgICApXG4vLyAgICAgKSB7XG4vLyAgICAgICAvLyBUaGlzIGlzIGEgc3BlY2lhbCBjYXNlIC0gd2UgZm91bmQgdGhlIHdpbm5lcidzIGJyYWNrZXQgZmluYWwgbG9zZXJcbi8vICAgICAgIGNvbnN0IHdpbm5lcnNGaW5hbExvc2VyID0gY3VycmVudFJvdW5kLm1hdGNoZXNcbi8vICAgICAgICAgLmZpbHRlcigobSkgPT4gbS5icmFja2V0ID09PSBcIndpbm5lcnNcIiAmJiBtLmlzQ29tcGxldGVkICYmIG0ubG9zZXIpXG4vLyAgICAgICAgIC5tYXAoKG0pID0+IG0ubG9zZXIhKVxuLy8gICAgICAgICAucG9wKCk7XG5cbi8vICAgICAgIGlmICh3aW5uZXJzRmluYWxMb3Nlcikge1xuLy8gICAgICAgICB0b3VybmFtZW50Lndpbm5lcnNCcmFja2V0RmluYWxMb3NlciA9IHdpbm5lcnNGaW5hbExvc2VyO1xuLy8gICAgICAgfVxuLy8gICAgIH1cblxuLy8gICAgIC8vIEV4aXN0aW5nIGxvc2VycyBicmFja2V0IHRlYW1zXG4vLyAgICAgY29uc3QgZXhpc3RpbmdMb3NlcnMgPSBlbGlnaWJsZUxvc2Vycy5maWx0ZXIoXG4vLyAgICAgICAodCkgPT4gIWp1c3REcm9wcGVkRnJvbVdpbm5lcnMuc29tZSgoamQpID0+IGpkLmlkID09PSB0LmlkKVxuLy8gICAgICk7XG5cbi8vICAgICAvLyBPcmRlcjogbW9zdCByZWNlbnQgZHJvcChzKSBmaXJzdFxuLy8gICAgIGNvbnN0IG9yZGVyZWRMb3NlcnMgPSBbLi4uanVzdERyb3BwZWRGcm9tV2lubmVycywgLi4uZXhpc3RpbmdMb3NlcnNdO1xuXG4vLyAgICAgaWYgKG9yZGVyZWRMb3NlcnMubGVuZ3RoID4gMCkge1xuLy8gICAgICAgaWYgKG9yZGVyZWRMb3NlcnMubGVuZ3RoICUgMiA9PT0gMSkge1xuLy8gICAgICAgICAvLyBPZGQ6IGJ5ZSBnb2VzIHRvIHRoZSBtb3N0IHJlY2VudCB0ZWFtIGRyb3BwZWQgZnJvbSB3aW5uZXJzIGJyYWNrZXRcbi8vICAgICAgICAgbGV0IHRlYW1XaXRoQnllOiBUZWFtIHwgbnVsbCA9IG51bGw7XG4vLyAgICAgICAgIGlmIChqdXN0RHJvcHBlZEZyb21XaW5uZXJzLmxlbmd0aCA+IDApIHtcbi8vICAgICAgICAgICB0ZWFtV2l0aEJ5ZSA9XG4vLyAgICAgICAgICAgICBqdXN0RHJvcHBlZEZyb21XaW5uZXJzW2p1c3REcm9wcGVkRnJvbVdpbm5lcnMubGVuZ3RoIC0gMV07XG4vLyAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBieWUgdGVhbSBmcm9tIG9yZGVyZWRMb3NlcnNcbi8vICAgICAgICAgICBjb25zdCBieWVJbmRleCA9IG9yZGVyZWRMb3NlcnMuZmluZEluZGV4KFxuLy8gICAgICAgICAgICAgKHQpID0+IHQuaWQgPT09IHRlYW1XaXRoQnllIS5pZFxuLy8gICAgICAgICAgICk7XG4vLyAgICAgICAgICAgaWYgKGJ5ZUluZGV4ICE9PSAtMSkgb3JkZXJlZExvc2Vycy5zcGxpY2UoYnllSW5kZXgsIDEpO1xuLy8gICAgICAgICB9IGVsc2Uge1xuLy8gICAgICAgICAgIC8vIERlZmVuc2l2ZTogZmFsbGJhY2sgdG8gZmlyc3QgdGVhbSBpZiBubyByZWNlbnQgZHJvcFxuLy8gICAgICAgICAgIHRlYW1XaXRoQnllID0gb3JkZXJlZExvc2Vycy5zaGlmdCgpITtcbi8vICAgICAgICAgfVxuLy8gICAgICAgICBuZXh0Um91bmRNYXRjaGVzLnB1c2goXG4vLyAgICAgICAgICAgY3JlYXRlTWF0Y2goXG4vLyAgICAgICAgICAgICBgTCR7bmV4dFJvdW5kTnVtYmVyfS0xYCxcbi8vICAgICAgICAgICAgIG5leHRSb3VuZE51bWJlcixcbi8vICAgICAgICAgICAgIHRlYW1XaXRoQnllLFxuLy8gICAgICAgICAgICAgbnVsbCxcbi8vICAgICAgICAgICAgIHRydWUsXG4vLyAgICAgICAgICAgICBcImxvc2Vyc1wiXG4vLyAgICAgICAgICAgKVxuLy8gICAgICAgICApO1xuLy8gICAgICAgICAvLyBQYWlyIHRoZSByZXN0XG4vLyAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3JkZXJlZExvc2Vycy5sZW5ndGg7IGkgKz0gMikge1xuLy8gICAgICAgICAgIGNvbnN0IHRlYW0xID0gb3JkZXJlZExvc2Vyc1tpXTtcbi8vICAgICAgICAgICBjb25zdCB0ZWFtMiA9IG9yZGVyZWRMb3NlcnNbaSArIDFdID8/IG51bGw7XG4vLyAgICAgICAgICAgbmV4dFJvdW5kTWF0Y2hlcy5wdXNoKFxuLy8gICAgICAgICAgICAgY3JlYXRlTWF0Y2goXG4vLyAgICAgICAgICAgICAgIGBMJHtuZXh0Um91bmROdW1iZXJ9LSR7TWF0aC5mbG9vcihpIC8gMikgKyAyfWAsXG4vLyAgICAgICAgICAgICAgIG5leHRSb3VuZE51bWJlcixcbi8vICAgICAgICAgICAgICAgdGVhbTEsXG4vLyAgICAgICAgICAgICAgIHRlYW0yLFxuLy8gICAgICAgICAgICAgICAhdGVhbTIsXG4vLyAgICAgICAgICAgICAgIFwibG9zZXJzXCJcbi8vICAgICAgICAgICAgIClcbi8vICAgICAgICAgICApO1xuLy8gICAgICAgICB9XG4vLyAgICAgICB9IGVsc2Uge1xuLy8gICAgICAgICAvLyBFdmVuIG51bWJlcjogcGFpciBhbGxcbi8vICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvcmRlcmVkTG9zZXJzLmxlbmd0aDsgaSArPSAyKSB7XG4vLyAgICAgICAgICAgY29uc3QgdGVhbTEgPSBvcmRlcmVkTG9zZXJzW2ldO1xuLy8gICAgICAgICAgIGNvbnN0IHRlYW0yID0gb3JkZXJlZExvc2Vyc1tpICsgMV0gPz8gbnVsbDtcbi8vICAgICAgICAgICBuZXh0Um91bmRNYXRjaGVzLnB1c2goXG4vLyAgICAgICAgICAgICBjcmVhdGVNYXRjaChcbi8vICAgICAgICAgICAgICAgYEwke25leHRSb3VuZE51bWJlcn0tJHtNYXRoLmZsb29yKGkgLyAyKSArIDF9YCxcbi8vICAgICAgICAgICAgICAgbmV4dFJvdW5kTnVtYmVyLFxuLy8gICAgICAgICAgICAgICB0ZWFtMSxcbi8vICAgICAgICAgICAgICAgdGVhbTIsXG4vLyAgICAgICAgICAgICAgICF0ZWFtMixcbi8vICAgICAgICAgICAgICAgXCJsb3NlcnNcIlxuLy8gICAgICAgICAgICAgKVxuLy8gICAgICAgICAgICk7XG4vLyAgICAgICAgIH1cbi8vICAgICAgIH1cbi8vICAgICB9XG4vLyAgIH1cblxuLy8gICAvLyAtLS0gV2lubmVyIGRldGVjdGlvbiBsb2dpYyAtLS1cbi8vICAgbGV0IHdpbm5lcjogVGVhbSB8IHVuZGVmaW5lZCA9IHRvdXJuYW1lbnQud2lubmVyO1xuXG4vLyAgIGlmIChpc0NoYW1waW9uc2hpcFJvdW5kKSB7XG4vLyAgICAgLy8gRmluZCB0aGUgbGFzdCBjaGFtcGlvbnNoaXAgbWF0Y2ggcGxheWVkXG4vLyAgICAgY29uc3QgbGFzdENoYW1wTWF0Y2ggPVxuLy8gICAgICAgY2hhbXBpb25zaGlwTWF0Y2hlc1swXSB8fFxuLy8gICAgICAgcHJldkNoYW1waW9uc2hpcE1hdGNoZXNbcHJldkNoYW1waW9uc2hpcE1hdGNoZXMubGVuZ3RoIC0gMV07XG5cbi8vICAgICBpZiAoXG4vLyAgICAgICBsYXN0Q2hhbXBNYXRjaCAmJlxuLy8gICAgICAgbGFzdENoYW1wTWF0Y2guaXNDb21wbGV0ZWQgJiZcbi8vICAgICAgIGxhc3RDaGFtcE1hdGNoLndpbm5lciAmJlxuLy8gICAgICAgbGFzdENoYW1wTWF0Y2gubG9zZXJcbi8vICAgICApIHtcbi8vICAgICAgIGNvbnN0IHdpbm5lcnNCcmFja2V0VGVhbSA9IGxhc3RDaGFtcE1hdGNoLnRlYW0xO1xuLy8gICAgICAgY29uc3QgbG9zZXJzQnJhY2tldFRlYW0gPSBsYXN0Q2hhbXBNYXRjaC50ZWFtMjtcbi8vICAgICAgIGNvbnN0IGxvc2Vyc0JyYWNrZXRUZWFtV29uID1cbi8vICAgICAgICAgbG9zZXJzQnJhY2tldFRlYW0gJiYgbGFzdENoYW1wTWF0Y2gud2lubmVyLmlkID09PSBsb3NlcnNCcmFja2V0VGVhbS5pZDtcblxuLy8gICAgICAgLy8gSWYgbG9zZXIncyBicmFja2V0IHRlYW0gd29uIGZpcnN0IGNoYW1waW9uc2hpcCBtYXRjaCwgd2lubmVyJ3MgYnJhY2tldCB0ZWFtIGdldHMgYW5vdGhlciBjaGFuY2Vcbi8vICAgICAgIGlmIChsb3NlcnNCcmFja2V0VGVhbVdvbiAmJiB0b3VybmFtZW50LmNoYW1waW9uc2hpcE1hdGNoZXNQbGF5ZWQgPT09IDEpIHtcbi8vICAgICAgICAgLy8gRG8gTk9UIGluY3JlbWVudCB0aGUgd2lubmVyJ3MgYnJhY2tldCB0ZWFtJ3MgbG9zcyBjb3VudCBvciBzZXQgd2lubmVyIHlldFxuLy8gICAgICAgICAvLyBXYWl0IGZvciB0aGUgcmVtYXRjaCB0byBiZSBwbGF5ZWRcbi8vICAgICAgICAgd2lubmVyID0gdW5kZWZpbmVkOyAvLyBObyB3aW5uZXIgeWV0LCBuZWVkIHJlc2V0IG1hdGNoXG4vLyAgICAgICB9IGVsc2UgaWYgKFxuLy8gICAgICAgICBsYXN0Q2hhbXBNYXRjaC5yZXF1aXJlc1JlbWF0Y2ggJiZcbi8vICAgICAgICAgIWxhc3RDaGFtcE1hdGNoLmlzQ29tcGxldGVkXG4vLyAgICAgICApIHtcbi8vICAgICAgICAgLy8gSWYgdGhlIHJlbWF0Y2ggaXMgcmVxdWlyZWQgYnV0IG5vdCBjb21wbGV0ZWQsIGRvIG5vdCBzZXQgd2lubmVyIG9yIGluY3JlbWVudCBsb3NzZXNcbi8vICAgICAgICAgd2lubmVyID0gdW5kZWZpbmVkO1xuLy8gICAgICAgfSBlbHNlIHtcbi8vICAgICAgICAgLy8gSWYgdGhpcyBpcyB0aGUgcmVtYXRjaCBhbmQgaXQncyBjb21wbGV0ZWQsIGluY3JlbWVudCBsb3NzIGZvciB3aW5uZXIncyBicmFja2V0IHRlYW0gT05MWSBJRiB0aGV5IGxvc2UgYWdhaW5cbi8vICAgICAgICAgaWYgKFxuLy8gICAgICAgICAgIGxhc3RDaGFtcE1hdGNoLnJlcXVpcmVzUmVtYXRjaCAmJlxuLy8gICAgICAgICAgIGxhc3RDaGFtcE1hdGNoLmlzQ29tcGxldGVkICYmXG4vLyAgICAgICAgICAgd2lubmVyc0JyYWNrZXRUZWFtICYmXG4vLyAgICAgICAgICAgbGFzdENoYW1wTWF0Y2gud2lubmVyLmlkICE9PSB3aW5uZXJzQnJhY2tldFRlYW0uaWQgJiZcbi8vICAgICAgICAgICB0eXBlb2Ygd2lubmVyc0JyYWNrZXRUZWFtLmxvc3NlcyA9PT0gXCJudW1iZXJcIlxuLy8gICAgICAgICApIHtcbi8vICAgICAgICAgICB3aW5uZXJzQnJhY2tldFRlYW0ubG9zc2VzICs9IDE7XG4vLyAgICAgICAgIH1cbi8vICAgICAgICAgd2lubmVyID0gbGFzdENoYW1wTWF0Y2gud2lubmVyO1xuLy8gICAgICAgfVxuLy8gICAgIH1cbi8vICAgfVxuXG4vLyAgIC8vIC0tLSBJTkZJTklURSBSRUNVUlNJT04gR1VBUkQgLS0tXG4vLyAgIGNvbnN0IG5vTW9yZU1hdGNoZXMgPVxuLy8gICAgIChpc0NoYW1waW9uc2hpcFJvdW5kICYmIGNoYW1waW9uc2hpcE1hdGNoZXMubGVuZ3RoID09PSAwKSB8fFxuLy8gICAgICghaXNDaGFtcGlvbnNoaXBSb3VuZCAmJiBuZXh0Um91bmRNYXRjaGVzLmxlbmd0aCA9PT0gMCk7XG5cbi8vICAgaWYgKG5vTW9yZU1hdGNoZXMpIHtcbi8vICAgICAvLyBUb3VybmFtZW50IGlzIG92ZXIsIGRvIG5vdCBhZHZhbmNlIGZ1cnRoZXJcbi8vICAgICByZXR1cm4ge1xuLy8gICAgICAgLi4udG91cm5hbWVudCxcbi8vICAgICAgIHdpbm5lcixcbi8vICAgICAgIGN1cnJlbnRSb3VuZDogdG91cm5hbWVudC5jdXJyZW50Um91bmRcbi8vICAgICB9O1xuLy8gICB9XG4vLyAgIC8vIDwtLS0gUExBQ0UgVEhFIERFQlVHIENBTEwgSEVSRSwganVzdCBiZWZvcmUgcmV0dXJuaW5nIHRoZSBuZXcgdG91cm5hbWVudCBvYmplY3QhXG4vLyAgIGxvZ1RvdXJuYW1lbnRTdGF0ZSh7XG4vLyAgICAgcm91bmROdW1iZXI6IG5leHRSb3VuZE51bWJlcixcbi8vICAgICB3aW5uZXJzQnJhY2tldFRlYW1zLFxuLy8gICAgIGxvc2Vyc0JyYWNrZXRUZWFtcyxcbi8vICAgICBtYXRjaGVzOiBpc0NoYW1waW9uc2hpcFJvdW5kID8gY2hhbXBpb25zaGlwTWF0Y2hlcyA6IG5leHRSb3VuZE1hdGNoZXMsXG4vLyAgICAgd2lubmVyc0JyYWNrZXRGaW5hbExvc2VyOiB0b3VybmFtZW50Lndpbm5lcnNCcmFja2V0RmluYWxMb3NlclxuLy8gICB9KTtcblxuLy8gICAvLyBDb21wb3NlIHRoZSBuZXcgdG91cm5hbWVudCBvYmplY3Rcbi8vICAgcmV0dXJuIHtcbi8vICAgICAuLi50b3VybmFtZW50LFxuLy8gICAgIHJvdW5kczogW1xuLy8gICAgICAgLi4udG91cm5hbWVudC5yb3VuZHMsXG4vLyAgICAgICB7XG4vLyAgICAgICAgIHJvdW5kTnVtYmVyOiBuZXh0Um91bmROdW1iZXIsXG4vLyAgICAgICAgIG1hdGNoZXM6IGlzQ2hhbXBpb25zaGlwUm91bmQgPyBjaGFtcGlvbnNoaXBNYXRjaGVzIDogbmV4dFJvdW5kTWF0Y2hlcyxcbi8vICAgICAgICAgaXNEb3VibGVFbGltaW5hdGlvbjogdHJ1ZSxcbi8vICAgICAgICAgaXNDaGFtcGlvbnNoaXBSb3VuZFxuLy8gICAgICAgfVxuLy8gICAgIF0sXG4vLyAgICAgY3VycmVudFJvdW5kOiBuZXh0Um91bmROdW1iZXIsXG4vLyAgICAgZWxpbWluYXRlZFRlYW1zOiBbXG4vLyAgICAgICAuLi50b3VybmFtZW50LmVsaW1pbmF0ZWRUZWFtcyxcbi8vICAgICAgIC4uLm5ld2x5RWxpbWluYXRlZC5maWx0ZXIoXG4vLyAgICAgICAgICh0KSA9PiAhdG91cm5hbWVudC5lbGltaW5hdGVkVGVhbXMuc29tZSgoZXQpID0+IGV0LmlkID09PSB0LmlkKVxuLy8gICAgICAgKVxuLy8gICAgIF0sXG4vLyAgICAgY2hhbXBpb25zaGlwTWF0Y2hlc1BsYXllZDogaXNDaGFtcGlvbnNoaXBSb3VuZFxuLy8gICAgICAgPyB0b3VybmFtZW50LmNoYW1waW9uc2hpcE1hdGNoZXNQbGF5ZWQgKyAxXG4vLyAgICAgICA6IHRvdXJuYW1lbnQuY2hhbXBpb25zaGlwTWF0Y2hlc1BsYXllZCxcbi8vICAgICB3aW5uZXJzQnJhY2tldEZpbmFsTG9zZXI6IHRvdXJuYW1lbnQud2lubmVyc0JyYWNrZXRGaW5hbExvc2VyLFxuLy8gICAgIHdpbm5lclxuLy8gICB9O1xuLy8gfTtcblxuLy8gZnVuY3Rpb24gbG9nVG91cm5hbWVudFN0YXRlKHtcbi8vICAgcm91bmROdW1iZXIsXG4vLyAgIHdpbm5lcnNCcmFja2V0VGVhbXMsXG4vLyAgIGxvc2Vyc0JyYWNrZXRUZWFtcyxcbi8vICAgbWF0Y2hlcyxcbi8vICAgd2lubmVyc0JyYWNrZXRGaW5hbExvc2VyXG4vLyB9OiB7XG4vLyAgIHJvdW5kTnVtYmVyOiBudW1iZXIsXG4vLyAgIHdpbm5lcnNCcmFja2V0VGVhbXM6IGFueVtdLFxuLy8gICBsb3NlcnNCcmFja2V0VGVhbXM6IGFueVtdLFxuLy8gICBtYXRjaGVzOiBhbnlbXSxcbi8vICAgd2lubmVyc0JyYWNrZXRGaW5hbExvc2VyOiBhbnlcbi8vIH0pIHtcbi8vICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbi8vICAgY29uc29sZS5sb2coJy0tLSBUT1VSTkFNRU5UIERFQlVHIC0tLScpO1xuLy8gICBjb25zb2xlLmxvZygnUm91bmQ6Jywgcm91bmROdW1iZXIpO1xuLy8gICBjb25zb2xlLmxvZygnV2lubmVycyBCcmFja2V0IFRlYW1zOicsIHdpbm5lcnNCcmFja2V0VGVhbXMubWFwKHQgPT4gYCR7dC5uYW1lfSAoJHt0LmlkfSlgKS5qb2luKCcsICcpKTtcbi8vICAgY29uc29sZS5sb2coJ0xvc2VycyBCcmFja2V0IFRlYW1zOicsIGxvc2Vyc0JyYWNrZXRUZWFtcy5tYXAodCA9PiBgJHt0Lm5hbWV9ICgke3QuaWR9KWApLmpvaW4oJywgJykpO1xuLy8gICBjb25zb2xlLmxvZygnTWF0Y2hlczonKTtcbi8vICAgbWF0Y2hlcy5mb3JFYWNoKG0gPT5cbi8vICAgICBjb25zb2xlLmxvZyhgICBbJHttLmJyYWNrZXR9XSAke20udGVhbTE/Lm5hbWUgPz8gJ1RCRCd9IHZzICR7bS50ZWFtMj8ubmFtZSA/PyAnVEJEJ30gfCBpc0NvbXBsZXRlZDogJHttLmlzQ29tcGxldGVkfSB8IGlzQnllOiAke20uaXNCeWV9YClcbi8vICAgKTtcbi8vICAgaWYgKHdpbm5lcnNCcmFja2V0RmluYWxMb3Nlcikge1xuLy8gICAgIGNvbnNvbGUubG9nKCdXaW5uZXJzIEJyYWNrZXQgRmluYWwgTG9zZXI6Jywgd2lubmVyc0JyYWNrZXRGaW5hbExvc2VyLm5hbWUsIHdpbm5lcnNCcmFja2V0RmluYWxMb3Nlci5pZCk7XG4vLyAgIH1cbi8vICAgY29uc29sZS5sb2coJy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLScpO1xuLy8gfVxuXG4iXSwibmFtZXMiOlsibG9nVG91cm5hbWVudFN0YXRlIiwiY3JlYXRlTWF0Y2giLCJpZCIsInJvdW5kTnVtYmVyIiwidGVhbTEiLCJ0ZWFtMiIsImlzQnllIiwiYnJhY2tldCIsIm5leHRNYXRjaElkIiwibmV4dExvc2VyTWF0Y2hJZCIsImlzQ29tcGxldGVkIiwid2lubmVyIiwidW5kZWZpbmVkIiwibG9zZXIiLCJzY29yZSIsInRlYW0xU2NvcmUiLCJ0ZWFtMlNjb3JlIiwiZWxpbWluYXRlZExhYmVsIiwiY3JlYXRlSW5pdGlhbFJvdW5kcyIsInRlYW1zIiwibnVtVGVhbXMiLCJsZW5ndGgiLCJtYXRjaGVzIiwibnVtUm91bmRzIiwiTWF0aCIsImNlaWwiLCJsb2cyIiwiZmlyc3RSb3VuZE1hdGNoZXMiLCJwb3ciLCJtYXRjaENvdW50ZXIiLCJpIiwibWF0Y2hJZCIsInB1c2giLCJyb3VuZHMiLCJpc0RvdWJsZUVsaW1pbmF0aW9uIiwiaXNDaGFtcGlvbnNoaXBSb3VuZCIsImN1cnJlbnRSb3VuZCIsImVsaW1pbmF0ZWRUZWFtcyIsImNoYW1waW9uc2hpcE1hdGNoZXNQbGF5ZWQiLCJ1cGRhdGVNYXRjaFNjb3JlIiwibWF0Y2giLCJuZXdTY29yZSIsIndpbnMiLCJsb3NzZXMiLCJkZWR1cGVUZWFtcyIsInNlZW4iLCJTZXQiLCJmaWx0ZXIiLCJ0ZWFtIiwiaGFzIiwiYWRkIiwidGVhbXNXaXRoTG9zc2VzIiwibG9zc0NvdW50cyIsIm4iLCJPYmplY3QiLCJrZXlzIiwidGVhbUlkIiwiYWR2YW5jZVRvTmV4dFJvdW5kIiwidG91cm5hbWVudCIsIm5leHRSb3VuZE51bWJlciIsIndpbnNDb3VudHMiLCJmb3JFYWNoIiwicm91bmQiLCJhbGxUZWFtcyIsInRlYW1JZHMiLCJuZXdseUVsaW1pbmF0ZWQiLCJzb21lIiwidCIsIndpbm5lcnNCcmFja2V0VGVhbXMiLCJzdGFydHNXaXRoIiwibWFwIiwibG9zZXJzQnJhY2tldFRlYW1zIiwid2lubmVyc0JyYWNrZXRGaW5hbExvc2VyIiwiY2hhbXBpb25zaGlwTWF0Y2hlcyIsIm5leHRSb3VuZE1hdGNoZXMiLCJwcmV2Q2hhbXBpb25zaGlwTWF0Y2hlcyIsInIiLCJmbGF0TWFwIiwibSIsImxhc3RDaGFtcE1hdGNoIiwid2lubmVyc0JyYWNrZXRUZWFtIiwibG9zZXJzQnJhY2tldFRlYW0iLCJpbmNsdWRlcyIsImxvc2Vyc0JyYWNrZXRXaW5uZXIiLCJwb3AiLCJhbHJlYWR5UGxheWVkIiwiaWRzIiwiQm9vbGVhbiIsInNvcnQiLCJjdXJySWRzIiwiZmxvb3IiLCJjcmVhdGVMb3NlcnNCcmFja2V0TWF0Y2hlcyIsImNyZWF0ZVN0YW5kYXJkQnJhY2tldE1hdGNoZXMiLCJlbGlnaWJsZUxvc2VycyIsImp1c3REcm9wcGVkRnJvbVdpbm5lcnMiLCJ3aW5uZXJzRmluYWxMb3NlciIsImV4aXN0aW5nTG9zZXJzIiwiamQiLCJvcmRlcmVkTG9zZXJzIiwidGVhbVdpdGhCeWUiLCJieWVJbmRleCIsImZpbmRJbmRleCIsInNwbGljZSIsInNoaWZ0IiwibG9zZXJzQnJhY2tldFRlYW1Xb24iLCJub01vcmVNYXRjaGVzIiwiZXQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./types/tournament/matches.ts\n"));

/***/ })

});
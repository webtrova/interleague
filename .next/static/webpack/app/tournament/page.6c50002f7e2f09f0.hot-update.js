"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/tournament/page",{

/***/ "(app-pages-browser)/./types/tournament/matches.ts":
/*!*************************************!*\
  !*** ./types/tournament/matches.ts ***!
  \*************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   advanceToNextRound: function() { return /* binding */ advanceToNextRound; },\n/* harmony export */   createInitialRounds: function() { return /* binding */ createInitialRounds; },\n/* harmony export */   createMatch: function() { return /* binding */ createMatch; },\n/* harmony export */   updateMatchScore: function() { return /* binding */ updateMatchScore; }\n/* harmony export */ });\n/* harmony import */ var _logTournamentState__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./logTournamentState */ \"(app-pages-browser)/./types/tournament/logTournamentState.ts\");\n\nconst createMatch = function(id, roundNumber, team1, team2) {\n    let isBye = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : false, bracket = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : \"winners\", nextMatchId = arguments.length > 6 ? arguments[6] : void 0, nextLoserMatchId = arguments.length > 7 ? arguments[7] : void 0;\n    var _ref;\n    return {\n        id,\n        roundNumber,\n        team1,\n        team2,\n        isCompleted: isBye,\n        isBye,\n        bracket,\n        winner: isBye ? (_ref = team1 !== null && team1 !== void 0 ? team1 : team2) !== null && _ref !== void 0 ? _ref : undefined : undefined,\n        loser: isBye ? undefined : undefined,\n        score: {\n            team1Score: 0,\n            team2Score: 0\n        },\n        nextMatchId,\n        nextLoserMatchId,\n        eliminatedLabel: undefined\n    };\n};\nconst createInitialRounds = (teams)=>{\n    const numTeams = teams.length;\n    const matches = [];\n    const numRounds = Math.ceil(Math.log2(numTeams));\n    const firstRoundMatches = Math.pow(2, numRounds - 1);\n    let matchCounter = 1;\n    for(let i = 0; i < firstRoundMatches; i++){\n        const team1 = teams[i * 2] || null;\n        const team2 = teams[i * 2 + 1] || null;\n        const isBye = !team1 || !team2;\n        const matchId = \"W1-\".concat(matchCounter);\n        const nextMatchId = \"W2-\".concat(Math.ceil(matchCounter / 2));\n        const nextLoserMatchId = \"L1-\".concat(Math.ceil(matchCounter / 2));\n        matches.push(createMatch(matchId, 1, team1, team2, isBye, \"winners\", nextMatchId, nextLoserMatchId));\n        matchCounter++;\n    }\n    return {\n        rounds: [\n            {\n                roundNumber: 1,\n                matches,\n                isDoubleElimination: true,\n                isChampionshipRound: false\n            }\n        ],\n        currentRound: 1,\n        eliminatedTeams: [],\n        championshipMatchesPlayed: 0\n    };\n};\nconst updateMatchScore = (match, newScore)=>{\n    const isCompleted = newScore.team1Score !== newScore.team2Score;\n    let winner = undefined;\n    let loser = undefined;\n    if (isCompleted) {\n        if (newScore.team1Score > newScore.team2Score) {\n            var _match_team1_wins, _match_team1_losses;\n            winner = match.team1 ? {\n                ...match.team1,\n                wins: ((_match_team1_wins = match.team1.wins) !== null && _match_team1_wins !== void 0 ? _match_team1_wins : 0) + 1,\n                losses: (_match_team1_losses = match.team1.losses) !== null && _match_team1_losses !== void 0 ? _match_team1_losses : 0\n            } : undefined;\n            var _match_team2_wins, _match_team2_losses;\n            loser = match.team2 ? {\n                ...match.team2,\n                wins: (_match_team2_wins = match.team2.wins) !== null && _match_team2_wins !== void 0 ? _match_team2_wins : 0,\n                losses: ((_match_team2_losses = match.team2.losses) !== null && _match_team2_losses !== void 0 ? _match_team2_losses : 0) + 1\n            } : undefined;\n        } else {\n            var _match_team2_wins1, _match_team2_losses1;\n            winner = match.team2 ? {\n                ...match.team2,\n                wins: ((_match_team2_wins1 = match.team2.wins) !== null && _match_team2_wins1 !== void 0 ? _match_team2_wins1 : 0) + 1,\n                losses: (_match_team2_losses1 = match.team2.losses) !== null && _match_team2_losses1 !== void 0 ? _match_team2_losses1 : 0\n            } : undefined;\n            var _match_team1_wins1, _match_team1_losses1;\n            loser = match.team1 ? {\n                ...match.team1,\n                wins: (_match_team1_wins1 = match.team1.wins) !== null && _match_team1_wins1 !== void 0 ? _match_team1_wins1 : 0,\n                losses: ((_match_team1_losses1 = match.team1.losses) !== null && _match_team1_losses1 !== void 0 ? _match_team1_losses1 : 0) + 1\n            } : undefined;\n        }\n    }\n    return {\n        ...match,\n        score: newScore,\n        isCompleted,\n        winner,\n        loser\n    };\n};\n// Helper to deduplicate teams by ID\nfunction dedupeTeams(teams) {\n    const seen = new Set();\n    return teams.filter((team)=>{\n        if (!team) return false;\n        if (seen.has(team.id)) return false;\n        seen.add(team.id);\n        return true;\n    });\n}\n// Helper: get all teams with exactly N losses\nfunction teamsWithLosses(lossCounts, n) {\n    return Object.keys(lossCounts).filter((teamId)=>lossCounts[teamId] === n);\n}\nconst advanceToNextRound = (tournament)=>{\n    const currentRound = tournament.rounds[tournament.rounds.length - 1];\n    const nextRoundNumber = tournament.currentRound + 1;\n    // Track all losses and wins across the tournament\n    const lossCounts = {};\n    const winsCounts = {};\n    tournament.rounds.forEach((round)=>{\n        round.matches.forEach((match)=>{\n            if (match.isCompleted && match.loser) {\n                lossCounts[match.loser.id] = (lossCounts[match.loser.id] || 0) + 1;\n            }\n            if (match.isCompleted && match.winner) {\n                winsCounts[match.winner.id] = (winsCounts[match.winner.id] || 0) + 1;\n            }\n        });\n    });\n    // Gather all teams ever in the tournament, attaching wins\n    const allTeams = [];\n    const teamIds = new Set();\n    for (const round of tournament.rounds){\n        for (const match of round.matches){\n            if (match.team1 && !teamIds.has(match.team1.id)) {\n                allTeams.push({\n                    ...match.team1,\n                    wins: winsCounts[match.team1.id] || 0,\n                    losses: lossCounts[match.team1.id] || 0\n                });\n                teamIds.add(match.team1.id);\n            }\n            if (match.team2 && !teamIds.has(match.team2.id)) {\n                allTeams.push({\n                    ...match.team2,\n                    wins: winsCounts[match.team2.id] || 0,\n                    losses: lossCounts[match.team2.id] || 0\n                });\n                teamIds.add(match.team2.id);\n            }\n        }\n    }\n    // Identify newly eliminated teams (2 losses)\n    const newlyEliminated = [];\n    for (const team of allTeams){\n        if ((lossCounts[team.id] || 0) >= 2 && !tournament.eliminatedTeams.some((t)=>t.id === team.id)) {\n            newlyEliminated.push(team);\n        }\n    }\n    // Winners: teams with 0 losses and not eliminated\n    const winnersBracketTeams = allTeams.filter((team)=>(lossCounts[team.id] || 0) === 0 && !tournament.eliminatedTeams.some((t)=>t.id === team.id) && !newlyEliminated.some((t)=>t.id === team.id) && !team.id.startsWith(\"tbd-\") // Exclude phantom TBD teams\n    ).map((team)=>({\n            ...team,\n            losses: lossCounts[team.id] || 0,\n            wins: winsCounts[team.id] || 0\n        }));\n    // Losers: teams with 1 loss and not eliminated\n    const losersBracketTeams = allTeams.filter((team)=>(lossCounts[team.id] || 0) === 1 && !tournament.eliminatedTeams.some((t)=>t.id === team.id) && !newlyEliminated.some((t)=>t.id === team.id) && // Don't include the winners bracket final loser in regular losers bracket teams\n        !(tournament.winnersBracketFinalLoser && tournament.winnersBracketFinalLoser.id === team.id)).map((team)=>({\n            ...team,\n            losses: lossCounts[team.id] || 0,\n            wins: winsCounts[team.id] || 0\n        }));\n    let isChampionshipRound = false;\n    let championshipMatches = [];\n    let nextRoundMatches = [];\n    const prevChampionshipMatches = tournament.rounds.filter((r)=>r.isChampionshipRound).flatMap((r)=>r.matches).filter((m)=>m.bracket === \"championship\");\n    // --- CHAMPIONSHIP LOGIC ---\n    // Check if a championship match already happened and was completed\n    if (prevChampionshipMatches.length >= 1 && prevChampionshipMatches[prevChampionshipMatches.length - 1].isCompleted) {\n        var _lastChampMatch_winner;\n        const lastChampMatch = prevChampionshipMatches[prevChampionshipMatches.length - 1];\n        const winnersBracketTeam = lastChampMatch.team1;\n        const losersBracketTeam = lastChampMatch.team2;\n        // If loser's bracket team won the first championship match, winner's bracket team gets another chance\n        if (((_lastChampMatch_winner = lastChampMatch.winner) === null || _lastChampMatch_winner === void 0 ? void 0 : _lastChampMatch_winner.id) === (losersBracketTeam === null || losersBracketTeam === void 0 ? void 0 : losersBracketTeam.id) && tournament.championshipMatchesPlayed === 1) {\n            isChampionshipRound = true;\n            // Create the \"reset\" match\n            championshipMatches.push(createMatch(\"C\".concat(nextRoundNumber, \"-1\"), nextRoundNumber, winnersBracketTeam, losersBracketTeam, false, \"championship\"));\n        } else {\n            // Either winner's bracket team won first match, or this was the reset match\n            isChampionshipRound = true;\n        // No new matches, winner will be determined in winner detection logic\n        }\n    } else if (winnersBracketTeams.length === 1 && losersBracketTeams.length === 1 && currentRound.matches.some((m)=>(m.bracket === \"losers\" || m.id.includes(\"LosersLast\")) && m.isCompleted && m.winner && (losersBracketTeams.some((t)=>t.id === m.winner.id) || tournament.winnersBracketFinalLoser && m.winner.id === tournament.winnersBracketFinalLoser.id))) {\n        // Find the winner of the losers bracket final\n        const losersBracketWinner = currentRound.matches.filter((m)=>(m.bracket === \"losers\" || m.id.includes(\"LosersLast\")) && m.isCompleted && m.winner).map((m)=>m.winner).pop();\n        if (losersBracketWinner) {\n            // Only schedule the championship if there is no winnersBracketFinalLoser waiting to play\n            if (!tournament.winnersBracketFinalLoser) {\n                // Schedule championship match immediately (no extra round)\n                nextRoundMatches.push(createMatch(\"C\".concat(nextRoundNumber, \"-1\"), nextRoundNumber, winnersBracketTeams[0], losersBracketWinner, false, \"championship\"));\n                isChampionshipRound = true;\n            // Do NOT schedule any waiting cards\n            } else {\n                // Instead, schedule the losers bracket final (LLWB vs LWLB), and show the winners bracket champion as waiting\n                nextRoundMatches.push(createMatch(\"LosersLast-\".concat(nextRoundNumber), nextRoundNumber, tournament.winnersBracketFinalLoser, losersBracketTeams[0], false, \"losers\"));\n                nextRoundMatches.push(createMatch(\"WinnersBracketChampion-waiting-\".concat(nextRoundNumber), nextRoundNumber, winnersBracketTeams[0], null, true, \"winners\"));\n            }\n        }\n    } else if (winnersBracketTeams.length === 1 && tournament.winnersBracketFinalLoser) {\n        if (losersBracketTeams.length === 1) {\n            // Prevent duplicate losers bracket final: check all previous rounds for this match\n            let alreadyPlayed = false;\n            for (let round of tournament.rounds){\n                if (!round.matches) continue;\n                for (let m of round.matches){\n                    var _m_team1, _m_team2;\n                    const ids = [\n                        (_m_team1 = m.team1) === null || _m_team1 === void 0 ? void 0 : _m_team1.id,\n                        (_m_team2 = m.team2) === null || _m_team2 === void 0 ? void 0 : _m_team2.id\n                    ].filter(Boolean).sort();\n                    const currIds = [\n                        tournament.winnersBracketFinalLoser.id,\n                        losersBracketTeams[0].id\n                    ].sort();\n                    if (ids.length === 2 && ids[0] === currIds[0] && ids[1] === currIds[1]) {\n                        alreadyPlayed = true;\n                        break;\n                    }\n                }\n                if (alreadyPlayed) break;\n            }\n            if (!alreadyPlayed) {\n                // Only now schedule WBFL vs LBL\n                nextRoundMatches.push(createMatch(\"LosersLast-\".concat(nextRoundNumber), nextRoundNumber, tournament.winnersBracketFinalLoser, losersBracketTeams[0], false, \"losers\"));\n            }\n        // If match already played, do not schedule again; championship logic will handle next step\n        } else if (losersBracketTeams.length === 2) {\n            // Schedule the match between the last two losers bracket teams\n            nextRoundMatches.push(createMatch(\"L\".concat(nextRoundNumber, \"-1\"), nextRoundNumber, losersBracketTeams[0], losersBracketTeams[1], false, \"losers\"));\n            // WBFL is waiting for the winner\n            nextRoundMatches.push(createMatch(\"WinnersFinalLoser-waiting-\".concat(nextRoundNumber), nextRoundNumber, tournament.winnersBracketFinalLoser, null, true, \"losers\"));\n        } else if (losersBracketTeams.length > 2) {\n            // More than 2 teams: pair off as usual, WBFL waits\n            for(let i = 0; i < losersBracketTeams.length; i += 2){\n                const team1 = losersBracketTeams[i];\n                var _losersBracketTeams_;\n                const team2 = (_losersBracketTeams_ = losersBracketTeams[i + 1]) !== null && _losersBracketTeams_ !== void 0 ? _losersBracketTeams_ : null;\n                nextRoundMatches.push(createMatch(\"L\".concat(nextRoundNumber, \"-\").concat(Math.floor(i / 2) + 1), nextRoundNumber, team1, team2, !team2, \"losers\"));\n            }\n            nextRoundMatches.push(createMatch(\"WinnersFinalLoser-waiting-\".concat(nextRoundNumber), nextRoundNumber, tournament.winnersBracketFinalLoser, null, true, \"losers\"));\n        } else {\n            // WBFL is waiting for the losers bracket to resolve\n            nextRoundMatches.push(createMatch(\"WinnersFinalLoser-waiting-\".concat(nextRoundNumber), nextRoundNumber, tournament.winnersBracketFinalLoser, null, true, \"losers\"));\n        }\n        // Always show a waiting card for the winners bracket champion if not in championship\n        nextRoundMatches.push(createMatch(\"WinnersBracketChampion-waiting-\".concat(nextRoundNumber), nextRoundNumber, winnersBracketTeams[0], null, true, \"winners\"));\n    } else if (winnersBracketTeams.length === 2) {\n        // Create the winner's bracket final match\n        nextRoundMatches.push(createMatch(\"W\".concat(nextRoundNumber, \"-1\"), nextRoundNumber, winnersBracketTeams[0], winnersBracketTeams[1], false, \"winners\"));\n        // Continue with losers bracket matches separately\n        createLosersBracketMatches();\n    } else {\n        createStandardBracketMatches();\n    }\n    // Helper function to create standard bracket matches\n    function createStandardBracketMatches() {\n        // --- Winners Bracket Matches ---\n        let matchCounter = 1;\n        for(let i = 0; i < winnersBracketTeams.length; i += 2){\n            const team1 = winnersBracketTeams[i];\n            var _winnersBracketTeams_;\n            const team2 = (_winnersBracketTeams_ = winnersBracketTeams[i + 1]) !== null && _winnersBracketTeams_ !== void 0 ? _winnersBracketTeams_ : null;\n            const isBye = !team2;\n            nextRoundMatches.push(createMatch(\"W\".concat(nextRoundNumber, \"-\").concat(matchCounter), nextRoundNumber, team1, team2, isBye, \"winners\"));\n            matchCounter++;\n        }\n        // Create losers bracket matches separately\n        createLosersBracketMatches();\n    }\n    // Helper function to create losers bracket matches\n    function createLosersBracketMatches() {\n        // --- Losers Bracket Matches ---\n        const eligibleLosers = allTeams.filter((team)=>(lossCounts[team.id] || 0) === 1 && !tournament.eliminatedTeams.some((t)=>t.id === team.id) && !newlyEliminated.some((t)=>t.id === team.id) && // Exclude winner's bracket final loser if it exists\n            !(tournament.winnersBracketFinalLoser && tournament.winnersBracketFinalLoser.id === team.id));\n        // Find teams recently dropped from winners bracket\n        const justDroppedFromWinners = currentRound.matches.filter((m)=>m.bracket === \"winners\" && m.loser && m.isCompleted).map((m)=>m.loser).filter((loser)=>eligibleLosers.some((t)=>t.id === loser.id));\n        // If this is the winner's bracket final, store the loser for later use\n        if (currentRound.matches.some((m)=>m.bracket === \"winners\" && winnersBracketTeams.length === 1 && m.loser && m.isCompleted)) {\n            // This is a special case - we found the winner's bracket final loser\n            const winnersFinalLoser = currentRound.matches.filter((m)=>m.bracket === \"winners\" && m.isCompleted && m.loser).map((m)=>m.loser).pop();\n            if (winnersFinalLoser && !tournament.eliminatedTeams.some((t)=>t.id === winnersFinalLoser.id)) {\n                tournament.winnersBracketFinalLoser = winnersFinalLoser;\n            }\n        }\n        // Existing losers bracket teams\n        const existingLosers = eligibleLosers.filter((t)=>!justDroppedFromWinners.some((jd)=>jd.id === t.id));\n        // Order: most recent drop(s) first\n        const orderedLosers = [\n            ...justDroppedFromWinners,\n            ...existingLosers\n        ];\n        if (orderedLosers.length > 0) {\n            if (orderedLosers.length % 2 === 1) {\n                // Odd: bye goes to the most recent team dropped from winners bracket\n                let teamWithBye = null;\n                if (justDroppedFromWinners.length > 0) {\n                    teamWithBye = justDroppedFromWinners[justDroppedFromWinners.length - 1];\n                    // Remove the bye team from orderedLosers\n                    const byeIndex = orderedLosers.findIndex((t)=>t.id === teamWithBye.id);\n                    if (byeIndex !== -1) orderedLosers.splice(byeIndex, 1);\n                } else {\n                    // Defensive: fallback to first team if no recent drop\n                    teamWithBye = orderedLosers.shift();\n                }\n                nextRoundMatches.push(createMatch(\"L\".concat(nextRoundNumber, \"-1\"), nextRoundNumber, teamWithBye, null, true, \"losers\"));\n                // Pair the rest\n                for(let i = 0; i < orderedLosers.length; i += 2){\n                    const team1 = orderedLosers[i];\n                    var _orderedLosers_;\n                    const team2 = (_orderedLosers_ = orderedLosers[i + 1]) !== null && _orderedLosers_ !== void 0 ? _orderedLosers_ : null;\n                    nextRoundMatches.push(createMatch(\"L\".concat(nextRoundNumber, \"-\").concat(Math.floor(i / 2) + 2), nextRoundNumber, team1, team2, !team2, \"losers\"));\n                }\n            } else {\n                // Even number: pair all\n                for(let i = 0; i < orderedLosers.length; i += 2){\n                    const team1 = orderedLosers[i];\n                    var _orderedLosers_1;\n                    const team2 = (_orderedLosers_1 = orderedLosers[i + 1]) !== null && _orderedLosers_1 !== void 0 ? _orderedLosers_1 : null;\n                    nextRoundMatches.push(createMatch(\"L\".concat(nextRoundNumber, \"-\").concat(Math.floor(i / 2) + 1), nextRoundNumber, team1, team2, !team2, \"losers\"));\n                }\n            }\n        }\n    }\n    // --- Winner detection logic ---\n    let winner = tournament.winner;\n    if (isChampionshipRound) {\n        // Find the last championship match played\n        const lastChampMatch = championshipMatches[0] || prevChampionshipMatches[prevChampionshipMatches.length - 1];\n        if (lastChampMatch && lastChampMatch.isCompleted && lastChampMatch.winner && lastChampMatch.loser) {\n            const winnersBracketTeam = lastChampMatch.team1;\n            const losersBracketTeam = lastChampMatch.team2;\n            const losersBracketTeamWon = losersBracketTeam && lastChampMatch.winner.id === losersBracketTeam.id;\n            // If loser's bracket team won first championship match, winner's bracket team gets another chance\n            if (losersBracketTeamWon && tournament.championshipMatchesPlayed === 1) {\n                winner = undefined; // No winner yet, need reset match\n            } else {\n                // Either winner's bracket team won first match, or this was the reset match\n                winner = lastChampMatch.winner;\n            }\n        }\n    }\n    // --- INFINITE RECURSION GUARD ---\n    const noMoreMatches = isChampionshipRound && championshipMatches.length === 0 || !isChampionshipRound && nextRoundMatches.length === 0;\n    if (noMoreMatches) {\n        // Tournament is over, do not advance further\n        return {\n            ...tournament,\n            winner,\n            currentRound: tournament.currentRound\n        };\n    }\n    // Debug log before returning the new tournament object\n    (0,_logTournamentState__WEBPACK_IMPORTED_MODULE_0__.logTournamentState)({\n        roundNumber: nextRoundNumber,\n        winnersBracketTeams,\n        losersBracketTeams,\n        matches: isChampionshipRound ? championshipMatches : nextRoundMatches,\n        winnersBracketFinalLoser: tournament.winnersBracketFinalLoser\n    });\n    // Compose the new tournament object\n    return {\n        ...tournament,\n        rounds: [\n            ...tournament.rounds,\n            {\n                roundNumber: nextRoundNumber,\n                matches: isChampionshipRound ? championshipMatches : nextRoundMatches,\n                isDoubleElimination: true,\n                isChampionshipRound\n            }\n        ],\n        currentRound: nextRoundNumber,\n        eliminatedTeams: [\n            ...tournament.eliminatedTeams,\n            ...newlyEliminated.filter((t)=>!tournament.eliminatedTeams.some((et)=>et.id === t.id))\n        ],\n        championshipMatchesPlayed: isChampionshipRound ? tournament.championshipMatchesPlayed + 1 : tournament.championshipMatchesPlayed,\n        winnersBracketFinalLoser: tournament.winnersBracketFinalLoser,\n        winner\n    };\n}; // export const advanceToNextRound = (tournament: Tournament): Tournament => {\n //   const currentRound = tournament.rounds[tournament.rounds.length - 1];\n //   const nextRoundNumber = tournament.currentRound + 1;\n //   // Track all losses across the tournament\n //   const lossCounts: Record<string, number> = {};\n //   tournament.rounds.forEach((round) => {\n //     round.matches.forEach((match) => {\n //       if (match.isCompleted && match.loser) {\n //         lossCounts[match.loser.id] = (lossCounts[match.loser.id] || 0) + 1;\n //       }\n //     });\n //   });\n //   // Gather all teams ever in the tournament\n //   const allTeams: Team[] = [];\n //   const teamIds = new Set<string>();\n //   for (const round of tournament.rounds) {\n //     for (const match of round.matches) {\n //       if (match.team1 && !teamIds.has(match.team1.id)) {\n //         allTeams.push(match.team1);\n //         teamIds.add(match.team1.id);\n //       }\n //       if (match.team2 && !teamIds.has(match.team2.id)) {\n //         allTeams.push(match.team2);\n //         teamIds.add(match.team2.id);\n //       }\n //     }\n //   }\n //   // Identify newly eliminated teams (2 losses)\n //   const newlyEliminated: Team[] = [];\n //   for (const team of allTeams) {\n //     if (\n //       (lossCounts[team.id] || 0) >= 2 &&\n //       !tournament.eliminatedTeams.some((t) => t.id === team.id)\n //     ) {\n //       newlyEliminated.push(team);\n //     }\n //   }\n //   // Winners: teams with 0 losses and not eliminated\n //   const winnersBracketTeams = allTeams.filter(\n //     (team) =>\n //       (lossCounts[team.id] || 0) === 0 &&\n //       !tournament.eliminatedTeams.some((t) => t.id === team.id) &&\n //       !newlyEliminated.some((t) => t.id === team.id)\n //   );\n //   // Losers: teams with 1 loss and not eliminated\n //   const losersBracketTeams = allTeams.filter(\n //     (team) =>\n //       (lossCounts[team.id] || 0) === 1 &&\n //       !tournament.eliminatedTeams.some((t) => t.id === team.id) &&\n //       !newlyEliminated.some((t) => t.id === team.id)\n //   );\n //   let isChampionshipRound = false;\n //   let championshipMatches: Match[] = [];\n //   let nextRoundMatches: Match[] = [];\n //   const prevChampionshipMatches = tournament.rounds\n //     .filter((r) => r.isChampionshipRound)\n //     .flatMap((r) => r.matches)\n //     .filter((m) => m.bracket === \"championship\");\n //   // --- CHAMPIONSHIP LOGIC ---\n //   // Check if a championship match already happened and was completed\n //   if (\n //     prevChampionshipMatches.length >= 1 &&\n //     prevChampionshipMatches[prevChampionshipMatches.length - 1].isCompleted\n //   ) {\n //     const lastChampMatch =\n //       prevChampionshipMatches[prevChampionshipMatches.length - 1];\n //     const winnersBracketTeam = lastChampMatch.team1;\n //     const losersBracketTeam = lastChampMatch.team2;\n //     // If loser's bracket team won the first championship match, winner's bracket team gets another chance\n //     if (\n //       lastChampMatch.winner?.id === losersBracketTeam?.id &&\n //       tournament.championshipMatchesPlayed === 1\n //     ) {\n //       isChampionshipRound = true;\n //       // Create the \"reset\" match\n //       championshipMatches.push(\n //         createMatch(\n //           `C${nextRoundNumber}-1`,\n //           nextRoundNumber,\n //           winnersBracketTeam,\n //           losersBracketTeam,\n //           false,\n //           \"championship\"\n //         )\n //       );\n //     } else {\n //       // Either winner's bracket team won first match, or this was the reset match\n //       isChampionshipRound = true;\n //       // No new matches, winner will be determined in winner detection logic\n //     }\n //   }\n //   // Check if we're ready for the championship match - one team in each bracket and loser's final is complete\n //   else if (\n //     winnersBracketTeams.length === 1 &&\n //     losersBracketTeams.length === 1 &&\n //     currentRound.matches.some(\n //       (m) =>\n //         (m.bracket === \"losers\" || m.id.includes(\"LosersLast\")) &&\n //         m.isCompleted &&\n //         m.winner &&\n //         losersBracketTeams.some((t) => t.id === m.winner!.id)\n //     )\n //   ) {\n //     // Championship match: Winner's bracket champion vs Loser's bracket champion\n //     isChampionshipRound = true;\n //     championshipMatches.push(\n //       createMatch(\n //         `C${nextRoundNumber}-1`,\n //         nextRoundNumber,\n //         winnersBracketTeams[0], // Winner's bracket champion\n //         losersBracketTeams[0], // Loser's bracket champion\n //         false,\n //         \"championship\"\n //       )\n //     );\n //   }\n //   // Check if we have a loser from winner's bracket final waiting to play against loser's bracket winner\n //   else if (\n //     winnersBracketTeams.length === 1 && // We have a winner's bracket champion\n //     losersBracketTeams.length >= 1 && // We have at least one team in loser's bracket\n //     tournament.winnersBracketFinalLoser // We have stored the winner's bracket final loser\n //   ) {\n //     // Find the winner of the loser's bracket\n //     const losersBracketWinner = currentRound.matches\n //       .filter((m) => m.bracket === \"losers\" && m.isCompleted && m.winner)\n //       .map((m) => m.winner!)\n //       .find((winner) => losersBracketTeams.some((t) => t.id === winner.id));\n //     if (\n //       losersBracketWinner &&\n //       losersBracketWinner.id !== tournament.winnersBracketFinalLoser.id\n //     ) {\n //       // Only schedule if they're not the same team!\n //       nextRoundMatches.push(\n //         createMatch(\n //           `LosersLast-${nextRoundNumber}`,\n //           nextRoundNumber,\n //           tournament.winnersBracketFinalLoser,\n //           losersBracketWinner,\n //           false,\n //           \"losers\"\n //         )\n //       );\n //     } else {\n //       // Wait for the losers bracket to resolve properly\n //       createStandardBracketMatches();\n //     }\n //   }\n //   // Check if this is the winner's bracket final (exactly 2 teams in winner's bracket)\n //   else if (winnersBracketTeams.length === 2 && losersBracketTeams.length >= 1) {\n //     // Create the winner's bracket final match\n //     nextRoundMatches.push(\n //       createMatch(\n //         `W${nextRoundNumber}-1`,\n //         nextRoundNumber,\n //         winnersBracketTeams[0],\n //         winnersBracketTeams[1],\n //         false,\n //         \"winners\"\n //       )\n //     );\n //     // Continue with losers bracket matches separately\n //     createLosersBracketMatches();\n //   }\n //   // Otherwise, continue with normal bracket play\n //   else {\n //     createStandardBracketMatches();\n //   }\n //   // Helper function to create standard bracket matches\n //   function createStandardBracketMatches() {\n //     // --- Winners Bracket Matches ---\n //     let matchCounter = 1;\n //     for (let i = 0; i < winnersBracketTeams.length; i += 2) {\n //       const team1 = winnersBracketTeams[i];\n //       const team2 = winnersBracketTeams[i + 1] ?? null;\n //       const isBye = !team2;\n //       nextRoundMatches.push(\n //         createMatch(\n //           `W${nextRoundNumber}-${matchCounter}`,\n //           nextRoundNumber,\n //           team1,\n //           team2,\n //           isBye,\n //           \"winners\"\n //         )\n //       );\n //       matchCounter++;\n //     }\n //     // Create losers bracket matches separately\n //     createLosersBracketMatches();\n //   }\n //   // Helper function to create losers bracket matches\n //   function createLosersBracketMatches() {\n //     // --- Losers Bracket Matches ---\n //     const eligibleLosers = allTeams.filter(\n //       (team) =>\n //         (lossCounts[team.id] || 0) === 1 &&\n //         !tournament.eliminatedTeams.some((t) => t.id === team.id) &&\n //         !newlyEliminated.some((t) => t.id === team.id) &&\n //         // Exclude winner's bracket final loser if it exists but hasn't played yet in losers\n //         !(\n //           tournament.winnersBracketFinalLoser &&\n //           tournament.winnersBracketFinalLoser.id === team.id\n //         )\n //     );\n //     // Find teams recently dropped from winners bracket\n //     const justDroppedFromWinners = currentRound.matches\n //       .filter((m) => m.bracket === \"winners\" && m.loser && m.isCompleted)\n //       .map((m) => m.loser!)\n //       .filter((loser) => eligibleLosers.some((t) => t.id === loser.id));\n //     // If this is the winner's bracket final, store the loser for later use\n //     if (\n //       currentRound.matches.some(\n //         (m) =>\n //           m.bracket === \"winners\" &&\n //           winnersBracketTeams.length === 1 &&\n //           m.loser &&\n //           m.isCompleted\n //       )\n //     ) {\n //       // This is a special case - we found the winner's bracket final loser\n //       const winnersFinalLoser = currentRound.matches\n //         .filter((m) => m.bracket === \"winners\" && m.isCompleted && m.loser)\n //         .map((m) => m.loser!)\n //         .pop();\n //       if (winnersFinalLoser) {\n //         tournament.winnersBracketFinalLoser = winnersFinalLoser;\n //       }\n //     }\n //     // Existing losers bracket teams\n //     const existingLosers = eligibleLosers.filter(\n //       (t) => !justDroppedFromWinners.some((jd) => jd.id === t.id)\n //     );\n //     // Order: most recent drop(s) first\n //     const orderedLosers = [...justDroppedFromWinners, ...existingLosers];\n //     if (orderedLosers.length > 0) {\n //       if (orderedLosers.length % 2 === 1) {\n //         // Odd: bye goes to the most recent team dropped from winners bracket\n //         let teamWithBye: Team | null = null;\n //         if (justDroppedFromWinners.length > 0) {\n //           teamWithBye =\n //             justDroppedFromWinners[justDroppedFromWinners.length - 1];\n //           // Remove the bye team from orderedLosers\n //           const byeIndex = orderedLosers.findIndex(\n //             (t) => t.id === teamWithBye!.id\n //           );\n //           if (byeIndex !== -1) orderedLosers.splice(byeIndex, 1);\n //         } else {\n //           // Defensive: fallback to first team if no recent drop\n //           teamWithBye = orderedLosers.shift()!;\n //         }\n //         nextRoundMatches.push(\n //           createMatch(\n //             `L${nextRoundNumber}-1`,\n //             nextRoundNumber,\n //             teamWithBye,\n //             null,\n //             true,\n //             \"losers\"\n //           )\n //         );\n //         // Pair the rest\n //         for (let i = 0; i < orderedLosers.length; i += 2) {\n //           const team1 = orderedLosers[i];\n //           const team2 = orderedLosers[i + 1] ?? null;\n //           nextRoundMatches.push(\n //             createMatch(\n //               `L${nextRoundNumber}-${Math.floor(i / 2) + 2}`,\n //               nextRoundNumber,\n //               team1,\n //               team2,\n //               !team2,\n //               \"losers\"\n //             )\n //           );\n //         }\n //       } else {\n //         // Even number: pair all\n //         for (let i = 0; i < orderedLosers.length; i += 2) {\n //           const team1 = orderedLosers[i];\n //           const team2 = orderedLosers[i + 1] ?? null;\n //           nextRoundMatches.push(\n //             createMatch(\n //               `L${nextRoundNumber}-${Math.floor(i / 2) + 1}`,\n //               nextRoundNumber,\n //               team1,\n //               team2,\n //               !team2,\n //               \"losers\"\n //             )\n //           );\n //         }\n //       }\n //     }\n //   }\n //   // --- Winner detection logic ---\n //   let winner: Team | undefined = tournament.winner;\n //   if (isChampionshipRound) {\n //     // Find the last championship match played\n //     const lastChampMatch =\n //       championshipMatches[0] ||\n //       prevChampionshipMatches[prevChampionshipMatches.length - 1];\n //     if (\n //       lastChampMatch &&\n //       lastChampMatch.isCompleted &&\n //       lastChampMatch.winner &&\n //       lastChampMatch.loser\n //     ) {\n //       const winnersBracketTeam = lastChampMatch.team1;\n //       const losersBracketTeam = lastChampMatch.team2;\n //       const losersBracketTeamWon =\n //         lastChampMatch.winner.id === losersBracketTeam.id;\n //       // If loser's bracket team won first championship match, winner's bracket team gets another chance\n //       if (losersBracketTeamWon && tournament.championshipMatchesPlayed === 1) {\n //         winner = undefined; // No winner yet, need reset match\n //       } else {\n //         // Either winner's bracket team won first match, or this was the reset match\n //         winner = lastChampMatch.winner;\n //       }\n //     }\n //   }\n //   // --- INFINITE RECURSION GUARD ---\n //   const noMoreMatches =\n //     (isChampionshipRound && championshipMatches.length === 0) ||\n //     (!isChampionshipRound && nextRoundMatches.length === 0);\n //   if (noMoreMatches) {\n //     // Tournament is over, do not advance further\n //     return {\n //       ...tournament,\n //       winner,\n //       currentRound: tournament.currentRound\n //     };\n //   }\n //   // Compose the new tournament object\n //   return {\n //     ...tournament,\n //     rounds: [\n //       ...tournament.rounds,\n //       {\n //         roundNumber: nextRoundNumber,\n //         matches: isChampionshipRound ? championshipMatches : nextRoundMatches,\n //         isDoubleElimination: true,\n //         isChampionshipRound\n //       }\n //     ],\n //     currentRound: nextRoundNumber,\n //     eliminatedTeams: [\n //       ...tournament.eliminatedTeams,\n //       ...newlyEliminated.filter(\n //         (t) => !tournament.eliminatedTeams.some((et) => et.id === t.id)\n //       )\n //     ],\n //     championshipMatchesPlayed: isChampionshipRound\n //       ? tournament.championshipMatchesPlayed + 1\n //       : tournament.championshipMatchesPlayed,\n //     winnersBracketFinalLoser: tournament.winnersBracketFinalLoser,\n //     winner\n //   };\n // };\n // import type { Team } from \"./mlb-teams\";\n // export interface Match {\n //   id: string;\n //   roundNumber: number;\n //   team1: Team | null;\n //   team2: Team | null;\n //   isCompleted: boolean;\n //   isBye?: boolean;\n //   winner?: Team;\n //   loser?: Team;\n //   bracket: \"winners\" | \"losers\" | \"championship\";\n //   score: { team1Score: number; team2Score: number };\n //   nextMatchId?: string;\n //   nextLoserMatchId?: string;\n //   eliminatedLabel?: string; // label for eliminated teams in losers bracket\n //   requiresRematch?: boolean; // indicates if a championship rematch is required\n // }\n // export interface Round {\n //   roundNumber: number;\n //   matches: Match[];\n //   isDoubleElimination: boolean;\n //   isChampionshipRound: boolean;\n // }\n // export interface Tournament {\n //   rounds: Round[];\n //   currentRound: number;\n //   eliminatedTeams: Team[];\n //   championshipMatchesPlayed: number;\n //   winner?: Team;\n //   winnersBracketFinalLoser?: Team; // tracks the winner's bracket final loser for championship rematch logic\n // }\n // export const createMatch = (\n //   id: string,\n //   roundNumber: number,\n //   team1: Team | null,\n //   team2: Team | null,\n //   isBye: boolean = false,\n //   bracket: \"winners\" | \"losers\" | \"championship\" = \"winners\",\n //   nextMatchId?: string,\n //   nextLoserMatchId?: string\n // ): Match => ({\n //   id,\n //   roundNumber,\n //   team1,\n //   team2,\n //   isCompleted: isBye,\n //   isBye,\n //   bracket,\n //   winner: isBye ? (team1 ?? team2 ?? undefined) : undefined,\n //   loser: isBye ? undefined : undefined,\n //   score: { team1Score: 0, team2Score: 0 },\n //   nextMatchId,\n //   nextLoserMatchId,\n //   eliminatedLabel: undefined\n // });\n // export const createInitialRounds = (teams: Team[]): Tournament => {\n //   const numTeams = teams.length;\n //   const matches: Match[] = [];\n //   const numRounds = Math.ceil(Math.log2(numTeams));\n //   const firstRoundMatches = Math.pow(2, numRounds - 1);\n //   let matchCounter = 1;\n //   for (let i = 0; i < firstRoundMatches; i++) {\n //     const team1 = teams[i * 2] || null;\n //     const team2 = teams[i * 2 + 1] || null;\n //     const isBye = !team1 || !team2;\n //     const matchId = `W1-${matchCounter}`;\n //     const nextMatchId = `W2-${Math.ceil(matchCounter / 2)}`;\n //     const nextLoserMatchId = `L1-${Math.ceil(matchCounter / 2)}`;\n //     matches.push(\n //       createMatch(\n //         matchId,\n //         1,\n //         team1,\n //         team2,\n //         isBye,\n //         \"winners\",\n //         nextMatchId,\n //         nextLoserMatchId\n //       )\n //     );\n //     matchCounter++;\n //   }\n //   return {\n //     rounds: [\n //       {\n //         roundNumber: 1,\n //         matches,\n //         isDoubleElimination: true,\n //         isChampionshipRound: false\n //       }\n //     ],\n //     currentRound: 1,\n //     eliminatedTeams: [],\n //     championshipMatchesPlayed: 0\n //   };\n // };\n // export const updateMatchScore = (\n //   match: Match,\n //   newScore: { team1Score: number; team2Score: number }\n // ): Match => {\n //   // Mark match as completed if both teams have a score entered (even if scores are equal)\n //   const isCompleted =\n //     typeof newScore.team1Score === \"number\" &&\n //     typeof newScore.team2Score === \"number\" &&\n //     (!isNaN(newScore.team1Score) && !isNaN(newScore.team2Score));\n //   let winner: Team | undefined = undefined;\n //   let loser: Team | undefined = undefined;\n //   if (isCompleted) {\n //     if (newScore.team1Score > newScore.team2Score) {\n //       winner = match.team1 ? { ...match.team1, wins: (match.team1.wins ?? 0) + 1, losses: match.team1.losses ?? 0 } : undefined;\n //       loser = match.team2 ? { ...match.team2, wins: match.team2.wins ?? 0, losses: (match.team2.losses ?? 0) + 1 } : undefined;\n //     } else {\n //       winner = match.team2 ? { ...match.team2, wins: (match.team2.wins ?? 0) + 1, losses: match.team2.losses ?? 0 } : undefined;\n //       loser = match.team1 ? { ...match.team1, wins: match.team1.wins ?? 0, losses: (match.team1.losses ?? 0) + 1 } : undefined;\n //     }\n //   }\n //   return {\n //     ...match,\n //     score: newScore,\n //     isCompleted,\n //     winner,\n //     loser\n //   };\n // };\n // // Helper to deduplicate teams by ID\n // function dedupeTeams(teams: Team[]): Team[] {\n //   const seen = new Set<string>();\n //   return teams.filter(team => {\n //     if (!team) return false;\n //     if (seen.has(team.id)) return false;\n //     seen.add(team.id);\n //     return true;\n //   });\n // }\n // // Helper: get all teams with exactly N losses\n // function teamsWithLosses(lossCounts: Record<string, number>, n: number): string[] {\n //   return Object.keys(lossCounts).filter(teamId => lossCounts[teamId] === n);\n // }\n // export const advanceToNextRound = (tournament: Tournament): Tournament => {\n //   const currentRound = tournament.rounds[tournament.rounds.length - 1];\n //   const nextRoundNumber = tournament.currentRound + 1;\n //   // Track all losses and wins across the tournament\n //   const lossCounts: Record<string, number> = {};\n //   const winsCounts: Record<string, number> = {};\n //   tournament.rounds.forEach((round) => {\n //     round.matches.forEach((match) => {\n //       if (match.isCompleted && match.loser) {\n //         lossCounts[match.loser.id] = (lossCounts[match.loser.id] || 0) + 1;\n //       }\n //       if (match.isCompleted && match.winner) {\n //         winsCounts[match.winner.id] = (winsCounts[match.winner.id] || 0) + 1;\n //       }\n //     });\n //   });\n //   // Gather all teams ever in the tournament, attaching wins\n //   const allTeams: Team[] = [];\n //   const teamIds = new Set<string>();\n //   for (const round of tournament.rounds) {\n //     for (const match of round.matches) {\n //       if (match.team1 && !teamIds.has(match.team1.id)) {\n //         allTeams.push({\n //           ...match.team1,\n //           wins: winsCounts[match.team1.id] || 0,\n //           losses: lossCounts[match.team1.id] || 0\n //         });\n //         teamIds.add(match.team1.id);\n //       }\n //       if (match.team2 && !teamIds.has(match.team2.id)) {\n //         allTeams.push({\n //           ...match.team2,\n //           wins: winsCounts[match.team2.id] || 0,\n //           losses: lossCounts[match.team2.id] || 0\n //         });\n //         teamIds.add(match.team2.id);\n //       }\n //     }\n //   }\n //   // Identify newly eliminated teams (2 losses)\n //   const newlyEliminated: Team[] = [];\n //   for (const team of allTeams) {\n //     if (\n //       (lossCounts[team.id] || 0) >= 2 &&\n //       !tournament.eliminatedTeams.some((t) => t.id === team.id)\n //     ) {\n //       newlyEliminated.push(team);\n //     }\n //   }\n //   // Winners: teams with 0 losses and not eliminated\n //   const winnersBracketTeams = allTeams\n //     .filter(\n //       (team) =>\n //         (lossCounts[team.id] || 0) === 0 &&\n //         !tournament.eliminatedTeams.some((t) => t.id === team.id) &&\n //         !newlyEliminated.some((t) => t.id === team.id) &&\n //         !team.id.startsWith('tbd-') // Exclude any phantom TBD teams\n //     )\n //     .map((team) => ({ ...team, losses: lossCounts[team.id] || 0, wins: winsCounts[team.id] || 0 }));\n //   // Losers: teams with 1 loss and not eliminated\n //   const losersBracketTeams = allTeams\n //     .filter(\n //       (team) =>\n //         (lossCounts[team.id] || 0) === 1 &&\n //         !tournament.eliminatedTeams.some((t) => t.id === team.id) &&\n //         !newlyEliminated.some((t) => t.id === team.id)\n //     )\n //     .map((team) => ({\n //       ...team,\n //       losses: lossCounts[team.id] || 0,\n //       wins: winsCounts[team.id] || 0\n //     }));\n //   let isChampionshipRound = false;\n //   let championshipMatches: Match[] = [];\n //   let nextRoundMatches: Match[] = [];\n //   const prevChampionshipMatches = tournament.rounds\n //     .filter((r) => r.isChampionshipRound)\n //     .flatMap((r) => r.matches)\n //     .filter((m) => m.bracket === \"championship\");\n //   // --- CHAMPIONSHIP LOGIC ---\n //   // Check if a championship match already happened and was completed\n //   if (\n //     prevChampionshipMatches.length >= 1 &&\n //     prevChampionshipMatches[prevChampionshipMatches.length - 1].isCompleted\n //   ) {\n //     const lastChampMatch =\n //       prevChampionshipMatches[prevChampionshipMatches.length - 1];\n //     const winnersBracketTeam = lastChampMatch.team1;\n //     const losersBracketTeam = lastChampMatch.team2;\n //     // If loser's bracket team won the first championship match, winner's bracket team gets another chance\n //     if (\n //       lastChampMatch.winner?.id === losersBracketTeam?.id &&\n //       tournament.championshipMatchesPlayed === 1\n //     ) {\n //       isChampionshipRound = true;\n //       // Create the \"reset\" match with requiresRematch: true\n //       championshipMatches.push({\n //         ...createMatch(\n //           `C${nextRoundNumber}-1`,\n //           nextRoundNumber,\n //           winnersBracketTeam,\n //           losersBracketTeam,\n //           false,\n //           \"championship\"\n //         ),\n //         requiresRematch: true\n //       });\n //       // Increment the winner's bracket team's loss count for the record\n //       if (winnersBracketTeam && typeof winnersBracketTeam.losses === \"number\") {\n //         winnersBracketTeam.losses += 1;\n //       }\n //     } else {\n //       // Either winner's bracket team won first match, or this was the reset match\n //       isChampionshipRound = true;\n //       // No new matches, winner will be determined in winner detection logic\n //     }\n //   }\n //   // Check if we're ready for the championship match - one team in each bracket and loser's final is complete\n //   else if (\n //     winnersBracketTeams.length === 1 &&\n //     // If ANY losers bracket match in the current round is incomplete, show waiting cards\n //     currentRound.matches.some(\n //       (m) =>\n //         (m.bracket === \"losers\" || m.id.includes(\"LosersLast\")) &&\n //         !m.isCompleted\n //     )\n //   ) {\n //     // Not ready for championship: show waiting cards for both\n //     nextRoundMatches.push(\n //       createMatch(\n //         `W${nextRoundNumber}-waiting`,\n //         nextRoundNumber,\n //         winnersBracketTeams[0],\n //         {\n //           id: `tbd-${nextRoundNumber}-waiting`,\n //           name: \"TBD\",\n //           city: \"\",\n //           losses: 0\n //         },\n //         true,\n //         \"winners\"\n //       )\n //     );\n //     if (tournament.winnersBracketFinalLoser) {\n //       nextRoundMatches.push(\n //         createMatch(\n //           `LosersLast-${nextRoundNumber}`,\n //           nextRoundNumber,\n //           tournament.winnersBracketFinalLoser,\n //           {\n //             id: `tbd-losers-${nextRoundNumber}`,\n //             name: \"TBD\",\n //             city: \"\",\n //             losses: 0\n //           },\n //           true,\n //           \"losers\"\n //         )\n //       );\n //     }\n //     logTournamentState({\n //       roundNumber: nextRoundNumber,\n //       winnersBracketTeams,\n //       losersBracketTeams,\n //       matches: nextRoundMatches,\n //       winnersBracketFinalLoser: tournament.winnersBracketFinalLoser\n //     });\n //     createLosersBracketMatches();\n //   }\n //   // Check if we have a loser from winner's bracket final waiting to play against loser's bracket winner\n //   else if (\n //     winnersBracketTeams.length === 1 &&\n //     tournament.winnersBracketFinalLoser\n //   ) {\n //     // Always show the waiting card for the losers bracket final loser, even if the opponent is TBD\n //     let losersBracketWinner = null;\n //     if (losersBracketTeams.length >= 1) {\n //       losersBracketWinner = currentRound.matches\n //         .filter((m) => m.bracket === \"losers\" && m.isCompleted && m.winner)\n //         .map((m) => m.winner!)\n //         .find((winner) => losersBracketTeams.some((t) => t.id === winner.id));\n //     }\n //     const opponent =\n //       losersBracketWinner &&\n //       losersBracketWinner.id !== tournament.winnersBracketFinalLoser.id\n //         ? losersBracketWinner\n //         : {\n //             id: `tbd-losers-${nextRoundNumber}`,\n //             name: \"TBD\",\n //             city: \"\",\n //             losses: 0\n //           };\n //     const isBye =\n //       !losersBracketWinner ||\n //       losersBracketWinner.id === tournament.winnersBracketFinalLoser.id;\n //     nextRoundMatches.push(\n //       createMatch(\n //         `LosersLast-${nextRoundNumber}`,\n //         nextRoundNumber,\n //         tournament.winnersBracketFinalLoser,\n //         opponent,\n //         isBye,\n //         \"losers\"\n //       )\n //     );\n //     // Always render the winners bracket champion as a non-scoreable waiting card if the losers bracket is not resolved\n //     nextRoundMatches.push(\n //       createMatch(\n //         `W${nextRoundNumber}-waiting`,\n //         nextRoundNumber,\n //         winnersBracketTeams[0],\n //         {\n //           id: `tbd-${nextRoundNumber}-waiting`,\n //           name: \"TBD\",\n //           city: \"\",\n //           losses: 0\n //         },\n //         true, // isBye: true to ensure it's not scoreable\n //         \"winners\"\n //       )\n //     );\n //     createLosersBracketMatches();\n //   }\n //   // Otherwise, continue with normal bracket play\n //   else {\n //     // If only one team in winners and losers bracket is not resolved, always show waiting cards\n //     if (winnersBracketTeams.length === 1 && losersBracketTeams.length >= 1) {\n //       nextRoundMatches.push(\n //         createMatch(\n //           `W${nextRoundNumber}-waiting`,\n //           nextRoundNumber,\n //           winnersBracketTeams[0],\n //           {\n //             id: `tbd-${nextRoundNumber}-waiting`,\n //             name: \"TBD\",\n //             city: \"\",\n //             losses: 0\n //           },\n //           true,\n //           \"winners\"\n //         )\n //       );\n //       if (tournament.winnersBracketFinalLoser) {\n //         nextRoundMatches.push(\n //           createMatch(\n //             `LosersLast-${nextRoundNumber}`,\n //             nextRoundNumber,\n //             tournament.winnersBracketFinalLoser,\n //             {\n //               id: `tbd-losers-${nextRoundNumber}`,\n //               name: \"TBD\",\n //               city: \"\",\n //               losses: 0\n //             },\n //             true,\n //             \"losers\"\n //           )\n //         );\n //       }\n //     }\n //   }\n //   // Helper function to create standard bracket matches\n //   function createStandardBracketMatches() {\n //     // --- Winners Bracket Matches ---\n //     let matchCounter = 1;\n //     for (let i = 0; i < winnersBracketTeams.length; i += 2) {\n //       const team1 = winnersBracketTeams[i];\n //       const team2 = winnersBracketTeams[i + 1] ?? null;\n //       const isBye = !team2;\n //       nextRoundMatches.push(\n //         createMatch(\n //           `W${nextRoundNumber}-${matchCounter}`,\n //           nextRoundNumber,\n //           team1,\n //           team2,\n //           isBye,\n //           \"winners\"\n //         )\n //       );\n //       matchCounter++;\n //     }\n //     // Create losers bracket matches separately\n //     createLosersBracketMatches();\n //   }\n //   // Helper function to create losers bracket matches\n //   function createLosersBracketMatches() {\n //     // --- Losers Bracket Matches ---\n //     const eligibleLosers = allTeams.filter(\n //       (team) =>\n //         (lossCounts[team.id] || 0) === 1 &&\n //         !tournament.eliminatedTeams.some((t) => t.id === team.id) &&\n //         !newlyEliminated.some((t) => t.id === team.id) &&\n //         // Exclude winner's bracket final loser if it exists but hasn't played yet in losers\n //         !(\n //           tournament.winnersBracketFinalLoser &&\n //           tournament.winnersBracketFinalLoser.id === team.id\n //         )\n //     );\n //     // Find teams recently dropped from winners bracket\n //     const justDroppedFromWinners = currentRound.matches\n //       .filter((m) => m.bracket === \"winners\" && m.loser && m.isCompleted)\n //       .map((m) => m.loser!)\n //       .filter((loser) => eligibleLosers.some((t) => t.id === loser.id));\n //     // If this is the winner's bracket final, store the loser for later use\n //     if (\n //       currentRound.matches.some(\n //         (m) =>\n //           m.bracket === \"winners\" &&\n //           winnersBracketTeams.length === 1 &&\n //           m.loser &&\n //           m.isCompleted\n //       )\n //     ) {\n //       // This is a special case - we found the winner's bracket final loser\n //       const winnersFinalLoser = currentRound.matches\n //         .filter((m) => m.bracket === \"winners\" && m.isCompleted && m.loser)\n //         .map((m) => m.loser!)\n //         .pop();\n //       if (winnersFinalLoser) {\n //         tournament.winnersBracketFinalLoser = winnersFinalLoser;\n //       }\n //     }\n //     // Existing losers bracket teams\n //     const existingLosers = eligibleLosers.filter(\n //       (t) => !justDroppedFromWinners.some((jd) => jd.id === t.id)\n //     );\n //     // Order: most recent drop(s) first\n //     const orderedLosers = [...justDroppedFromWinners, ...existingLosers];\n //     if (orderedLosers.length > 0) {\n //       if (orderedLosers.length % 2 === 1) {\n //         // Odd: bye goes to the most recent team dropped from winners bracket\n //         let teamWithBye: Team | null = null;\n //         if (justDroppedFromWinners.length > 0) {\n //           teamWithBye =\n //             justDroppedFromWinners[justDroppedFromWinners.length - 1];\n //           // Remove the bye team from orderedLosers\n //           const byeIndex = orderedLosers.findIndex(\n //             (t) => t.id === teamWithBye!.id\n //           );\n //           if (byeIndex !== -1) orderedLosers.splice(byeIndex, 1);\n //         } else {\n //           // Defensive: fallback to first team if no recent drop\n //           teamWithBye = orderedLosers.shift()!;\n //         }\n //         nextRoundMatches.push(\n //           createMatch(\n //             `L${nextRoundNumber}-1`,\n //             nextRoundNumber,\n //             teamWithBye,\n //             null,\n //             true,\n //             \"losers\"\n //           )\n //         );\n //         // Pair the rest\n //         for (let i = 0; i < orderedLosers.length; i += 2) {\n //           const team1 = orderedLosers[i];\n //           const team2 = orderedLosers[i + 1] ?? null;\n //           nextRoundMatches.push(\n //             createMatch(\n //               `L${nextRoundNumber}-${Math.floor(i / 2) + 2}`,\n //               nextRoundNumber,\n //               team1,\n //               team2,\n //               !team2,\n //               \"losers\"\n //             )\n //           );\n //         }\n //       } else {\n //         // Even number: pair all\n //         for (let i = 0; i < orderedLosers.length; i += 2) {\n //           const team1 = orderedLosers[i];\n //           const team2 = orderedLosers[i + 1] ?? null;\n //           nextRoundMatches.push(\n //             createMatch(\n //               `L${nextRoundNumber}-${Math.floor(i / 2) + 1}`,\n //               nextRoundNumber,\n //               team1,\n //               team2,\n //               !team2,\n //               \"losers\"\n //             )\n //           );\n //         }\n //       }\n //     }\n //   }\n //   // --- Winner detection logic ---\n //   let winner: Team | undefined = tournament.winner;\n //   if (isChampionshipRound) {\n //     // Find the last championship match played\n //     const lastChampMatch =\n //       championshipMatches[0] ||\n //       prevChampionshipMatches[prevChampionshipMatches.length - 1];\n //     if (\n //       lastChampMatch &&\n //       lastChampMatch.isCompleted &&\n //       lastChampMatch.winner &&\n //       lastChampMatch.loser\n //     ) {\n //       const winnersBracketTeam = lastChampMatch.team1;\n //       const losersBracketTeam = lastChampMatch.team2;\n //       const losersBracketTeamWon =\n //         losersBracketTeam && lastChampMatch.winner.id === losersBracketTeam.id;\n //       // If loser's bracket team won first championship match, winner's bracket team gets another chance\n //       if (losersBracketTeamWon && tournament.championshipMatchesPlayed === 1) {\n //         // Do NOT increment the winner's bracket team's loss count or set winner yet\n //         // Wait for the rematch to be played\n //         winner = undefined; // No winner yet, need reset match\n //       } else if (\n //         lastChampMatch.requiresRematch &&\n //         !lastChampMatch.isCompleted\n //       ) {\n //         // If the rematch is required but not completed, do not set winner or increment losses\n //         winner = undefined;\n //       } else {\n //         // If this is the rematch and it's completed, increment loss for winner's bracket team ONLY IF they lose again\n //         if (\n //           lastChampMatch.requiresRematch &&\n //           lastChampMatch.isCompleted &&\n //           winnersBracketTeam &&\n //           lastChampMatch.winner.id !== winnersBracketTeam.id &&\n //           typeof winnersBracketTeam.losses === \"number\"\n //         ) {\n //           winnersBracketTeam.losses += 1;\n //         }\n //         winner = lastChampMatch.winner;\n //       }\n //     }\n //   }\n //   // --- INFINITE RECURSION GUARD ---\n //   const noMoreMatches =\n //     (isChampionshipRound && championshipMatches.length === 0) ||\n //     (!isChampionshipRound && nextRoundMatches.length === 0);\n //   if (noMoreMatches) {\n //     // Tournament is over, do not advance further\n //     return {\n //       ...tournament,\n //       winner,\n //       currentRound: tournament.currentRound\n //     };\n //   }\n //   // <--- PLACE THE DEBUG CALL HERE, just before returning the new tournament object!\n //   logTournamentState({\n //     roundNumber: nextRoundNumber,\n //     winnersBracketTeams,\n //     losersBracketTeams,\n //     matches: isChampionshipRound ? championshipMatches : nextRoundMatches,\n //     winnersBracketFinalLoser: tournament.winnersBracketFinalLoser\n //   });\n //   // Compose the new tournament object\n //   return {\n //     ...tournament,\n //     rounds: [\n //       ...tournament.rounds,\n //       {\n //         roundNumber: nextRoundNumber,\n //         matches: isChampionshipRound ? championshipMatches : nextRoundMatches,\n //         isDoubleElimination: true,\n //         isChampionshipRound\n //       }\n //     ],\n //     currentRound: nextRoundNumber,\n //     eliminatedTeams: [\n //       ...tournament.eliminatedTeams,\n //       ...newlyEliminated.filter(\n //         (t) => !tournament.eliminatedTeams.some((et) => et.id === t.id)\n //       )\n //     ],\n //     championshipMatchesPlayed: isChampionshipRound\n //       ? tournament.championshipMatchesPlayed + 1\n //       : tournament.championshipMatchesPlayed,\n //     winnersBracketFinalLoser: tournament.winnersBracketFinalLoser,\n //     winner\n //   };\n // };\n // function logTournamentState({\n //   roundNumber,\n //   winnersBracketTeams,\n //   losersBracketTeams,\n //   matches,\n //   winnersBracketFinalLoser\n // }: {\n //   roundNumber: number,\n //   winnersBracketTeams: any[],\n //   losersBracketTeams: any[],\n //   matches: any[],\n //   winnersBracketFinalLoser: any\n // }) {\n //   // eslint-disable-next-line no-console\n //   console.log('--- TOURNAMENT DEBUG ---');\n //   console.log('Round:', roundNumber);\n //   console.log('Winners Bracket Teams:', winnersBracketTeams.map(t => `${t.name} (${t.id})`).join(', '));\n //   console.log('Losers Bracket Teams:', losersBracketTeams.map(t => `${t.name} (${t.id})`).join(', '));\n //   console.log('Matches:');\n //   matches.forEach(m =>\n //     console.log(`  [${m.bracket}] ${m.team1?.name ?? 'TBD'} vs ${m.team2?.name ?? 'TBD'} | isCompleted: ${m.isCompleted} | isBye: ${m.isBye}`)\n //   );\n //   if (winnersBracketFinalLoser) {\n //     console.log('Winners Bracket Final Loser:', winnersBracketFinalLoser.name, winnersBracketFinalLoser.id);\n //   }\n //   console.log('------------------------');\n // }\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3R5cGVzL3RvdXJuYW1lbnQvbWF0Y2hlcy50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUMwRDtBQW1DbkQsTUFBTUMsY0FBYyxTQUN6QkMsSUFDQUMsYUFDQUMsT0FDQUM7UUFDQUMseUVBQWlCLE9BQ2pCQywyRUFBaUQsV0FDakRDLDREQUNBQztRQVNpQkw7V0FSTjtRQUNYRjtRQUNBQztRQUNBQztRQUNBQztRQUNBSyxhQUFhSjtRQUNiQTtRQUNBQztRQUNBSSxRQUFRTCxRQUFTRixDQUFBQSxPQUFBQSxrQkFBQUEsbUJBQUFBLFFBQVNDLG1CQUFURCxrQkFBQUEsT0FBa0JRLFlBQWFBO1FBQ2hEQyxPQUFPUCxRQUFRTSxZQUFZQTtRQUMzQkUsT0FBTztZQUFFQyxZQUFZO1lBQUdDLFlBQVk7UUFBRTtRQUN0Q1I7UUFDQUM7UUFDQVEsaUJBQWlCTDtJQUNuQjtBQUFBLEVBQUc7QUFFSSxNQUFNTSxzQkFBc0IsQ0FBQ0M7SUFDbEMsTUFBTUMsV0FBV0QsTUFBTUUsTUFBTTtJQUM3QixNQUFNQyxVQUFtQixFQUFFO0lBQzNCLE1BQU1DLFlBQVlDLEtBQUtDLElBQUksQ0FBQ0QsS0FBS0UsSUFBSSxDQUFDTjtJQUV0QyxNQUFNTyxvQkFBb0JILEtBQUtJLEdBQUcsQ0FBQyxHQUFHTCxZQUFZO0lBQ2xELElBQUlNLGVBQWU7SUFFbkIsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlILG1CQUFtQkcsSUFBSztRQUMxQyxNQUFNMUIsUUFBUWUsS0FBSyxDQUFDVyxJQUFJLEVBQUUsSUFBSTtRQUM5QixNQUFNekIsUUFBUWMsS0FBSyxDQUFDVyxJQUFJLElBQUksRUFBRSxJQUFJO1FBQ2xDLE1BQU14QixRQUFRLENBQUNGLFNBQVMsQ0FBQ0M7UUFFekIsTUFBTTBCLFVBQVUsTUFBbUIsT0FBYkY7UUFDdEIsTUFBTXJCLGNBQWMsTUFBa0MsT0FBNUJnQixLQUFLQyxJQUFJLENBQUNJLGVBQWU7UUFDbkQsTUFBTXBCLG1CQUFtQixN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Q0FDN0Usb0VBQW9FO0NBQ3BFLFFBQVE7Q0FFUix5Q0FBeUM7Q0FDekMsYUFBYTtDQUNiLHFCQUFxQjtDQUNyQixnQkFBZ0I7Q0FDaEIsOEJBQThCO0NBQzlCLFVBQVU7Q0FDVix3Q0FBd0M7Q0FDeEMsaUZBQWlGO0NBQ2pGLHFDQUFxQztDQUNyQyw4QkFBOEI7Q0FDOUIsVUFBVTtDQUNWLFNBQVM7Q0FDVCxxQ0FBcUM7Q0FDckMseUJBQXlCO0NBQ3pCLHVDQUF1QztDQUN2QyxtQ0FBbUM7Q0FDbkMsMEVBQTBFO0NBQzFFLFVBQVU7Q0FDVixTQUFTO0NBQ1QscURBQXFEO0NBQ3JELG1EQUFtRDtDQUNuRCxnREFBZ0Q7Q0FDaEQscUVBQXFFO0NBQ3JFLGFBQWE7Q0FDYixPQUFPO0NBQ1AsS0FBSztDQUVMLGdDQUFnQztDQUNoQyxpQkFBaUI7Q0FDakIseUJBQXlCO0NBQ3pCLHdCQUF3QjtDQUN4QixhQUFhO0NBQ2IsNkJBQTZCO0NBQzdCLE9BQU87Q0FDUCx5QkFBeUI7Q0FDekIsZ0NBQWdDO0NBQ2hDLCtCQUErQjtDQUMvQixvQkFBb0I7Q0FDcEIsa0NBQWtDO0NBQ2xDLE9BQU87Q0FDUCwyQ0FBMkM7Q0FDM0MsNkNBQTZDO0NBQzdDLHdDQUF3QztDQUN4QywyR0FBMkc7Q0FDM0cseUdBQXlHO0NBQ3pHLDZCQUE2QjtDQUM3Qix5QkFBeUI7Q0FDekIsaUpBQWlKO0NBQ2pKLE9BQU87Q0FDUCxvQ0FBb0M7Q0FDcEMsK0dBQStHO0NBQy9HLE1BQU07Q0FDTiw2Q0FBNkM7Q0FDN0MsSUFBSSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi90eXBlcy90b3VybmFtZW50L21hdGNoZXMudHM/ZGEyMiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7IFRlYW0gfSBmcm9tIFwiLi9tbGItdGVhbXNcIjtcbmltcG9ydCB7IGxvZ1RvdXJuYW1lbnRTdGF0ZSB9IGZyb20gXCIuL2xvZ1RvdXJuYW1lbnRTdGF0ZVwiO1xuXG5leHBvcnQgaW50ZXJmYWNlIE1hdGNoIHtcbiAgaWQ6IHN0cmluZztcbiAgcm91bmROdW1iZXI6IG51bWJlcjtcbiAgdGVhbTE6IFRlYW0gfCBudWxsO1xuICB0ZWFtMjogVGVhbSB8IG51bGw7XG4gIGlzQ29tcGxldGVkOiBib29sZWFuO1xuICBpc0J5ZT86IGJvb2xlYW47XG4gIHdpbm5lcj86IFRlYW07XG4gIGxvc2VyPzogVGVhbTtcbiAgYnJhY2tldDogXCJ3aW5uZXJzXCIgfCBcImxvc2Vyc1wiIHwgXCJjaGFtcGlvbnNoaXBcIjtcbiAgc2NvcmU6IHsgdGVhbTFTY29yZTogbnVtYmVyOyB0ZWFtMlNjb3JlOiBudW1iZXIgfTtcbiAgbmV4dE1hdGNoSWQ/OiBzdHJpbmc7XG4gIG5leHRMb3Nlck1hdGNoSWQ/OiBzdHJpbmc7XG4gIGVsaW1pbmF0ZWRMYWJlbD86IHN0cmluZzsgLy8gbGFiZWwgZm9yIGVsaW1pbmF0ZWQgdGVhbXMgaW4gbG9zZXJzIGJyYWNrZXRcbiAgcmVxdWlyZXNSZW1hdGNoPzogYm9vbGVhbjsgLy8gaW5kaWNhdGVzIGlmIGEgY2hhbXBpb25zaGlwIHJlbWF0Y2ggaXMgcmVxdWlyZWRcbn1cblxuZXhwb3J0IGludGVyZmFjZSBSb3VuZCB7XG4gIHJvdW5kTnVtYmVyOiBudW1iZXI7XG4gIG1hdGNoZXM6IE1hdGNoW107XG4gIGlzRG91YmxlRWxpbWluYXRpb246IGJvb2xlYW47XG4gIGlzQ2hhbXBpb25zaGlwUm91bmQ6IGJvb2xlYW47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVG91cm5hbWVudCB7XG4gIHJvdW5kczogUm91bmRbXTtcbiAgY3VycmVudFJvdW5kOiBudW1iZXI7XG4gIGVsaW1pbmF0ZWRUZWFtczogVGVhbVtdO1xuICBjaGFtcGlvbnNoaXBNYXRjaGVzUGxheWVkOiBudW1iZXI7XG4gIHdpbm5lcj86IFRlYW07XG4gIHdpbm5lcnNCcmFja2V0RmluYWxMb3Nlcj86IFRlYW07IC8vIHRyYWNrcyB0aGUgd2lubmVyJ3MgYnJhY2tldCBmaW5hbCBsb3NlciBmb3IgY2hhbXBpb25zaGlwIHJlbWF0Y2ggbG9naWNcbn1cblxuZXhwb3J0IGNvbnN0IGNyZWF0ZU1hdGNoID0gKFxuICBpZDogc3RyaW5nLFxuICByb3VuZE51bWJlcjogbnVtYmVyLFxuICB0ZWFtMTogVGVhbSB8IG51bGwsXG4gIHRlYW0yOiBUZWFtIHwgbnVsbCxcbiAgaXNCeWU6IGJvb2xlYW4gPSBmYWxzZSxcbiAgYnJhY2tldDogXCJ3aW5uZXJzXCIgfCBcImxvc2Vyc1wiIHwgXCJjaGFtcGlvbnNoaXBcIiA9IFwid2lubmVyc1wiLFxuICBuZXh0TWF0Y2hJZD86IHN0cmluZyxcbiAgbmV4dExvc2VyTWF0Y2hJZD86IHN0cmluZ1xuKTogTWF0Y2ggPT4gKHtcbiAgaWQsXG4gIHJvdW5kTnVtYmVyLFxuICB0ZWFtMSxcbiAgdGVhbTIsXG4gIGlzQ29tcGxldGVkOiBpc0J5ZSxcbiAgaXNCeWUsXG4gIGJyYWNrZXQsXG4gIHdpbm5lcjogaXNCeWUgPyAodGVhbTEgPz8gdGVhbTIgPz8gdW5kZWZpbmVkKSA6IHVuZGVmaW5lZCxcbiAgbG9zZXI6IGlzQnllID8gdW5kZWZpbmVkIDogdW5kZWZpbmVkLFxuICBzY29yZTogeyB0ZWFtMVNjb3JlOiAwLCB0ZWFtMlNjb3JlOiAwIH0sXG4gIG5leHRNYXRjaElkLFxuICBuZXh0TG9zZXJNYXRjaElkLFxuICBlbGltaW5hdGVkTGFiZWw6IHVuZGVmaW5lZFxufSk7XG5cbmV4cG9ydCBjb25zdCBjcmVhdGVJbml0aWFsUm91bmRzID0gKHRlYW1zOiBUZWFtW10pOiBUb3VybmFtZW50ID0+IHtcbiAgY29uc3QgbnVtVGVhbXMgPSB0ZWFtcy5sZW5ndGg7XG4gIGNvbnN0IG1hdGNoZXM6IE1hdGNoW10gPSBbXTtcbiAgY29uc3QgbnVtUm91bmRzID0gTWF0aC5jZWlsKE1hdGgubG9nMihudW1UZWFtcykpO1xuXG4gIGNvbnN0IGZpcnN0Um91bmRNYXRjaGVzID0gTWF0aC5wb3coMiwgbnVtUm91bmRzIC0gMSk7XG4gIGxldCBtYXRjaENvdW50ZXIgPSAxO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZmlyc3RSb3VuZE1hdGNoZXM7IGkrKykge1xuICAgIGNvbnN0IHRlYW0xID0gdGVhbXNbaSAqIDJdIHx8IG51bGw7XG4gICAgY29uc3QgdGVhbTIgPSB0ZWFtc1tpICogMiArIDFdIHx8IG51bGw7XG4gICAgY29uc3QgaXNCeWUgPSAhdGVhbTEgfHwgIXRlYW0yO1xuXG4gICAgY29uc3QgbWF0Y2hJZCA9IGBXMS0ke21hdGNoQ291bnRlcn1gO1xuICAgIGNvbnN0IG5leHRNYXRjaElkID0gYFcyLSR7TWF0aC5jZWlsKG1hdGNoQ291bnRlciAvIDIpfWA7XG4gICAgY29uc3QgbmV4dExvc2VyTWF0Y2hJZCA9IGBMMS0ke01hdGguY2VpbChtYXRjaENvdW50ZXIgLyAyKX1gO1xuXG4gICAgbWF0Y2hlcy5wdXNoKFxuICAgICAgY3JlYXRlTWF0Y2goXG4gICAgICAgIG1hdGNoSWQsXG4gICAgICAgIDEsXG4gICAgICAgIHRlYW0xLFxuICAgICAgICB0ZWFtMixcbiAgICAgICAgaXNCeWUsXG4gICAgICAgIFwid2lubmVyc1wiLFxuICAgICAgICBuZXh0TWF0Y2hJZCxcbiAgICAgICAgbmV4dExvc2VyTWF0Y2hJZFxuICAgICAgKVxuICAgICk7XG4gICAgbWF0Y2hDb3VudGVyKys7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHJvdW5kczogW1xuICAgICAge1xuICAgICAgICByb3VuZE51bWJlcjogMSxcbiAgICAgICAgbWF0Y2hlcyxcbiAgICAgICAgaXNEb3VibGVFbGltaW5hdGlvbjogdHJ1ZSxcbiAgICAgICAgaXNDaGFtcGlvbnNoaXBSb3VuZDogZmFsc2VcbiAgICAgIH1cbiAgICBdLFxuICAgIGN1cnJlbnRSb3VuZDogMSxcbiAgICBlbGltaW5hdGVkVGVhbXM6IFtdLFxuICAgIGNoYW1waW9uc2hpcE1hdGNoZXNQbGF5ZWQ6IDBcbiAgfTtcbn07XG5cbmV4cG9ydCBjb25zdCB1cGRhdGVNYXRjaFNjb3JlID0gKFxuICBtYXRjaDogTWF0Y2gsXG4gIG5ld1Njb3JlOiB7IHRlYW0xU2NvcmU6IG51bWJlcjsgdGVhbTJTY29yZTogbnVtYmVyIH1cbik6IE1hdGNoID0+IHtcbiAgY29uc3QgaXNDb21wbGV0ZWQgPSBuZXdTY29yZS50ZWFtMVNjb3JlICE9PSBuZXdTY29yZS50ZWFtMlNjb3JlO1xuICBsZXQgd2lubmVyOiBUZWFtIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuICBsZXQgbG9zZXI6IFRlYW0gfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG4gIGlmIChpc0NvbXBsZXRlZCkge1xuICAgIGlmIChuZXdTY29yZS50ZWFtMVNjb3JlID4gbmV3U2NvcmUudGVhbTJTY29yZSkge1xuICAgICAgd2lubmVyID0gbWF0Y2gudGVhbTEgPyB7IC4uLm1hdGNoLnRlYW0xLCB3aW5zOiAobWF0Y2gudGVhbTEud2lucyA/PyAwKSArIDEsIGxvc3NlczogbWF0Y2gudGVhbTEubG9zc2VzID8/IDAgfSA6IHVuZGVmaW5lZDtcbiAgICAgIGxvc2VyID0gbWF0Y2gudGVhbTIgPyB7IC4uLm1hdGNoLnRlYW0yLCB3aW5zOiBtYXRjaC50ZWFtMi53aW5zID8/IDAsIGxvc3NlczogKG1hdGNoLnRlYW0yLmxvc3NlcyA/PyAwKSArIDEgfSA6IHVuZGVmaW5lZDtcbiAgICB9IGVsc2Uge1xuICAgICAgd2lubmVyID0gbWF0Y2gudGVhbTIgPyB7IC4uLm1hdGNoLnRlYW0yLCB3aW5zOiAobWF0Y2gudGVhbTIud2lucyA/PyAwKSArIDEsIGxvc3NlczogbWF0Y2gudGVhbTIubG9zc2VzID8/IDAgfSA6IHVuZGVmaW5lZDtcbiAgICAgIGxvc2VyID0gbWF0Y2gudGVhbTEgPyB7IC4uLm1hdGNoLnRlYW0xLCB3aW5zOiBtYXRjaC50ZWFtMS53aW5zID8/IDAsIGxvc3NlczogKG1hdGNoLnRlYW0xLmxvc3NlcyA/PyAwKSArIDEgfSA6IHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICAuLi5tYXRjaCxcbiAgICBzY29yZTogbmV3U2NvcmUsXG4gICAgaXNDb21wbGV0ZWQsXG4gICAgd2lubmVyLFxuICAgIGxvc2VyXG4gIH07XG59O1xuXG4vLyBIZWxwZXIgdG8gZGVkdXBsaWNhdGUgdGVhbXMgYnkgSURcbmZ1bmN0aW9uIGRlZHVwZVRlYW1zKHRlYW1zOiBUZWFtW10pOiBUZWFtW10ge1xuICBjb25zdCBzZWVuID0gbmV3IFNldDxzdHJpbmc+KCk7XG4gIHJldHVybiB0ZWFtcy5maWx0ZXIodGVhbSA9PiB7XG4gICAgaWYgKCF0ZWFtKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKHNlZW4uaGFzKHRlYW0uaWQpKSByZXR1cm4gZmFsc2U7XG4gICAgc2Vlbi5hZGQodGVhbS5pZCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0pO1xufVxuXG4vLyBIZWxwZXI6IGdldCBhbGwgdGVhbXMgd2l0aCBleGFjdGx5IE4gbG9zc2VzXG5mdW5jdGlvbiB0ZWFtc1dpdGhMb3NzZXMobG9zc0NvdW50czogUmVjb3JkPHN0cmluZywgbnVtYmVyPiwgbjogbnVtYmVyKTogc3RyaW5nW10ge1xuICByZXR1cm4gT2JqZWN0LmtleXMobG9zc0NvdW50cykuZmlsdGVyKHRlYW1JZCA9PiBsb3NzQ291bnRzW3RlYW1JZF0gPT09IG4pO1xufVxuZXhwb3J0IGNvbnN0IGFkdmFuY2VUb05leHRSb3VuZCA9ICh0b3VybmFtZW50OiBUb3VybmFtZW50KTogVG91cm5hbWVudCA9PiB7XG4gIGNvbnN0IGN1cnJlbnRSb3VuZCA9IHRvdXJuYW1lbnQucm91bmRzW3RvdXJuYW1lbnQucm91bmRzLmxlbmd0aCAtIDFdO1xuICBjb25zdCBuZXh0Um91bmROdW1iZXIgPSB0b3VybmFtZW50LmN1cnJlbnRSb3VuZCArIDE7XG5cbiAgLy8gVHJhY2sgYWxsIGxvc3NlcyBhbmQgd2lucyBhY3Jvc3MgdGhlIHRvdXJuYW1lbnRcbiAgY29uc3QgbG9zc0NvdW50czogUmVjb3JkPHN0cmluZywgbnVtYmVyPiA9IHt9O1xuICBjb25zdCB3aW5zQ291bnRzOiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+ID0ge307XG4gIHRvdXJuYW1lbnQucm91bmRzLmZvckVhY2goKHJvdW5kKSA9PiB7XG4gICAgcm91bmQubWF0Y2hlcy5mb3JFYWNoKChtYXRjaCkgPT4ge1xuICAgICAgaWYgKG1hdGNoLmlzQ29tcGxldGVkICYmIG1hdGNoLmxvc2VyKSB7XG4gICAgICAgIGxvc3NDb3VudHNbbWF0Y2gubG9zZXIuaWRdID0gKGxvc3NDb3VudHNbbWF0Y2gubG9zZXIuaWRdIHx8IDApICsgMTtcbiAgICAgIH1cbiAgICAgIGlmIChtYXRjaC5pc0NvbXBsZXRlZCAmJiBtYXRjaC53aW5uZXIpIHtcbiAgICAgICAgd2luc0NvdW50c1ttYXRjaC53aW5uZXIuaWRdID0gKHdpbnNDb3VudHNbbWF0Y2gud2lubmVyLmlkXSB8fCAwKSArIDE7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuXG4gIC8vIEdhdGhlciBhbGwgdGVhbXMgZXZlciBpbiB0aGUgdG91cm5hbWVudCwgYXR0YWNoaW5nIHdpbnNcbiAgY29uc3QgYWxsVGVhbXM6IFRlYW1bXSA9IFtdO1xuICBjb25zdCB0ZWFtSWRzID0gbmV3IFNldDxzdHJpbmc+KCk7XG4gIGZvciAoY29uc3Qgcm91bmQgb2YgdG91cm5hbWVudC5yb3VuZHMpIHtcbiAgICBmb3IgKGNvbnN0IG1hdGNoIG9mIHJvdW5kLm1hdGNoZXMpIHtcbiAgICAgIGlmIChtYXRjaC50ZWFtMSAmJiAhdGVhbUlkcy5oYXMobWF0Y2gudGVhbTEuaWQpKSB7XG4gICAgICAgIGFsbFRlYW1zLnB1c2goe1xuICAgICAgICAgIC4uLm1hdGNoLnRlYW0xLFxuICAgICAgICAgIHdpbnM6IHdpbnNDb3VudHNbbWF0Y2gudGVhbTEuaWRdIHx8IDAsXG4gICAgICAgICAgbG9zc2VzOiBsb3NzQ291bnRzW21hdGNoLnRlYW0xLmlkXSB8fCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0ZWFtSWRzLmFkZChtYXRjaC50ZWFtMS5pZCk7XG4gICAgICB9XG4gICAgICBpZiAobWF0Y2gudGVhbTIgJiYgIXRlYW1JZHMuaGFzKG1hdGNoLnRlYW0yLmlkKSkge1xuICAgICAgICBhbGxUZWFtcy5wdXNoKHtcbiAgICAgICAgICAuLi5tYXRjaC50ZWFtMixcbiAgICAgICAgICB3aW5zOiB3aW5zQ291bnRzW21hdGNoLnRlYW0yLmlkXSB8fCAwLFxuICAgICAgICAgIGxvc3NlczogbG9zc0NvdW50c1ttYXRjaC50ZWFtMi5pZF0gfHwgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGVhbUlkcy5hZGQobWF0Y2gudGVhbTIuaWQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIElkZW50aWZ5IG5ld2x5IGVsaW1pbmF0ZWQgdGVhbXMgKDIgbG9zc2VzKVxuICBjb25zdCBuZXdseUVsaW1pbmF0ZWQ6IFRlYW1bXSA9IFtdO1xuICBmb3IgKGNvbnN0IHRlYW0gb2YgYWxsVGVhbXMpIHtcbiAgICBpZiAoXG4gICAgICAobG9zc0NvdW50c1t0ZWFtLmlkXSB8fCAwKSA+PSAyICYmXG4gICAgICAhdG91cm5hbWVudC5lbGltaW5hdGVkVGVhbXMuc29tZSgodCkgPT4gdC5pZCA9PT0gdGVhbS5pZClcbiAgICApIHtcbiAgICAgIG5ld2x5RWxpbWluYXRlZC5wdXNoKHRlYW0pO1xuICAgIH1cbiAgfVxuXG4gIC8vIFdpbm5lcnM6IHRlYW1zIHdpdGggMCBsb3NzZXMgYW5kIG5vdCBlbGltaW5hdGVkXG4gIGNvbnN0IHdpbm5lcnNCcmFja2V0VGVhbXMgPSBhbGxUZWFtc1xuICAgIC5maWx0ZXIoXG4gICAgICAodGVhbSkgPT5cbiAgICAgICAgKGxvc3NDb3VudHNbdGVhbS5pZF0gfHwgMCkgPT09IDAgJiZcbiAgICAgICAgIXRvdXJuYW1lbnQuZWxpbWluYXRlZFRlYW1zLnNvbWUoKHQpID0+IHQuaWQgPT09IHRlYW0uaWQpICYmXG4gICAgICAgICFuZXdseUVsaW1pbmF0ZWQuc29tZSgodCkgPT4gdC5pZCA9PT0gdGVhbS5pZCkgJiZcbiAgICAgICAgIXRlYW0uaWQuc3RhcnRzV2l0aChcInRiZC1cIikgLy8gRXhjbHVkZSBwaGFudG9tIFRCRCB0ZWFtc1xuICAgIClcbiAgICAubWFwKCh0ZWFtKSA9PiAoe1xuICAgICAgLi4udGVhbSxcbiAgICAgIGxvc3NlczogbG9zc0NvdW50c1t0ZWFtLmlkXSB8fCAwLFxuICAgICAgd2luczogd2luc0NvdW50c1t0ZWFtLmlkXSB8fCAwXG4gICAgfSkpO1xuXG4gIC8vIExvc2VyczogdGVhbXMgd2l0aCAxIGxvc3MgYW5kIG5vdCBlbGltaW5hdGVkXG4gIGNvbnN0IGxvc2Vyc0JyYWNrZXRUZWFtcyA9IGFsbFRlYW1zXG4gICAgLmZpbHRlcihcbiAgICAgICh0ZWFtKSA9PlxuICAgICAgICAobG9zc0NvdW50c1t0ZWFtLmlkXSB8fCAwKSA9PT0gMSAmJlxuICAgICAgICAhdG91cm5hbWVudC5lbGltaW5hdGVkVGVhbXMuc29tZSgodCkgPT4gdC5pZCA9PT0gdGVhbS5pZCkgJiZcbiAgICAgICAgIW5ld2x5RWxpbWluYXRlZC5zb21lKCh0KSA9PiB0LmlkID09PSB0ZWFtLmlkKSAmJlxuICAgICAgICAvLyBEb24ndCBpbmNsdWRlIHRoZSB3aW5uZXJzIGJyYWNrZXQgZmluYWwgbG9zZXIgaW4gcmVndWxhciBsb3NlcnMgYnJhY2tldCB0ZWFtc1xuICAgICAgICAhKFxuICAgICAgICAgIHRvdXJuYW1lbnQud2lubmVyc0JyYWNrZXRGaW5hbExvc2VyICYmXG4gICAgICAgICAgdG91cm5hbWVudC53aW5uZXJzQnJhY2tldEZpbmFsTG9zZXIuaWQgPT09IHRlYW0uaWRcbiAgICAgICAgKVxuICAgIClcbiAgICAubWFwKCh0ZWFtKSA9PiAoe1xuICAgICAgLi4udGVhbSxcbiAgICAgIGxvc3NlczogbG9zc0NvdW50c1t0ZWFtLmlkXSB8fCAwLFxuICAgICAgd2luczogd2luc0NvdW50c1t0ZWFtLmlkXSB8fCAwXG4gICAgfSkpO1xuXG4gIGxldCBpc0NoYW1waW9uc2hpcFJvdW5kID0gZmFsc2U7XG4gIGxldCBjaGFtcGlvbnNoaXBNYXRjaGVzOiBNYXRjaFtdID0gW107XG4gIGxldCBuZXh0Um91bmRNYXRjaGVzOiBNYXRjaFtdID0gW107XG5cbiAgY29uc3QgcHJldkNoYW1waW9uc2hpcE1hdGNoZXMgPSB0b3VybmFtZW50LnJvdW5kc1xuICAgIC5maWx0ZXIoKHIpID0+IHIuaXNDaGFtcGlvbnNoaXBSb3VuZClcbiAgICAuZmxhdE1hcCgocikgPT4gci5tYXRjaGVzKVxuICAgIC5maWx0ZXIoKG0pID0+IG0uYnJhY2tldCA9PT0gXCJjaGFtcGlvbnNoaXBcIik7XG5cbiAgLy8gLS0tIENIQU1QSU9OU0hJUCBMT0dJQyAtLS1cblxuICAvLyBDaGVjayBpZiBhIGNoYW1waW9uc2hpcCBtYXRjaCBhbHJlYWR5IGhhcHBlbmVkIGFuZCB3YXMgY29tcGxldGVkXG4gIGlmIChcbiAgICBwcmV2Q2hhbXBpb25zaGlwTWF0Y2hlcy5sZW5ndGggPj0gMSAmJlxuICAgIHByZXZDaGFtcGlvbnNoaXBNYXRjaGVzW3ByZXZDaGFtcGlvbnNoaXBNYXRjaGVzLmxlbmd0aCAtIDFdLmlzQ29tcGxldGVkXG4gICkge1xuICAgIGNvbnN0IGxhc3RDaGFtcE1hdGNoID1cbiAgICAgIHByZXZDaGFtcGlvbnNoaXBNYXRjaGVzW3ByZXZDaGFtcGlvbnNoaXBNYXRjaGVzLmxlbmd0aCAtIDFdO1xuICAgIGNvbnN0IHdpbm5lcnNCcmFja2V0VGVhbSA9IGxhc3RDaGFtcE1hdGNoLnRlYW0xO1xuICAgIGNvbnN0IGxvc2Vyc0JyYWNrZXRUZWFtID0gbGFzdENoYW1wTWF0Y2gudGVhbTI7XG5cbiAgICAvLyBJZiBsb3NlcidzIGJyYWNrZXQgdGVhbSB3b24gdGhlIGZpcnN0IGNoYW1waW9uc2hpcCBtYXRjaCwgd2lubmVyJ3MgYnJhY2tldCB0ZWFtIGdldHMgYW5vdGhlciBjaGFuY2VcbiAgICBpZiAoXG4gICAgICBsYXN0Q2hhbXBNYXRjaC53aW5uZXI/LmlkID09PSBsb3NlcnNCcmFja2V0VGVhbT8uaWQgJiZcbiAgICAgIHRvdXJuYW1lbnQuY2hhbXBpb25zaGlwTWF0Y2hlc1BsYXllZCA9PT0gMVxuICAgICkge1xuICAgICAgaXNDaGFtcGlvbnNoaXBSb3VuZCA9IHRydWU7XG4gICAgICAvLyBDcmVhdGUgdGhlIFwicmVzZXRcIiBtYXRjaFxuICAgICAgY2hhbXBpb25zaGlwTWF0Y2hlcy5wdXNoKFxuICAgICAgICBjcmVhdGVNYXRjaChcbiAgICAgICAgICBgQyR7bmV4dFJvdW5kTnVtYmVyfS0xYCxcbiAgICAgICAgICBuZXh0Um91bmROdW1iZXIsXG4gICAgICAgICAgd2lubmVyc0JyYWNrZXRUZWFtLFxuICAgICAgICAgIGxvc2Vyc0JyYWNrZXRUZWFtLFxuICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgIFwiY2hhbXBpb25zaGlwXCJcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRWl0aGVyIHdpbm5lcidzIGJyYWNrZXQgdGVhbSB3b24gZmlyc3QgbWF0Y2gsIG9yIHRoaXMgd2FzIHRoZSByZXNldCBtYXRjaFxuICAgICAgaXNDaGFtcGlvbnNoaXBSb3VuZCA9IHRydWU7XG4gICAgICAvLyBObyBuZXcgbWF0Y2hlcywgd2lubmVyIHdpbGwgYmUgZGV0ZXJtaW5lZCBpbiB3aW5uZXIgZGV0ZWN0aW9uIGxvZ2ljXG4gICAgfVxuICB9XG4gIC8vIENoZWNrIGlmIHdlJ3JlIHJlYWR5IGZvciB0aGUgY2hhbXBpb25zaGlwIG1hdGNoIC0gb25lIHRlYW0gaW4gZWFjaCBicmFja2V0IGFuZCBsb3NlcidzIGZpbmFsIGlzIGNvbXBsZXRlXG4gIGVsc2UgaWYgKFxuICAgIHdpbm5lcnNCcmFja2V0VGVhbXMubGVuZ3RoID09PSAxICYmXG4gICAgbG9zZXJzQnJhY2tldFRlYW1zLmxlbmd0aCA9PT0gMSAmJlxuICAgIGN1cnJlbnRSb3VuZC5tYXRjaGVzLnNvbWUoXG4gICAgICAobSkgPT5cbiAgICAgICAgKG0uYnJhY2tldCA9PT0gXCJsb3NlcnNcIiB8fCBtLmlkLmluY2x1ZGVzKFwiTG9zZXJzTGFzdFwiKSkgJiZcbiAgICAgICAgbS5pc0NvbXBsZXRlZCAmJlxuICAgICAgICBtLndpbm5lciAmJlxuICAgICAgICAobG9zZXJzQnJhY2tldFRlYW1zLnNvbWUoKHQpID0+IHQuaWQgPT09IG0ud2lubmVyIS5pZCkgfHxcbiAgICAgICAgICAodG91cm5hbWVudC53aW5uZXJzQnJhY2tldEZpbmFsTG9zZXIgJiZcbiAgICAgICAgICAgIG0ud2lubmVyIS5pZCA9PT0gdG91cm5hbWVudC53aW5uZXJzQnJhY2tldEZpbmFsTG9zZXIuaWQpKVxuICAgIClcbiAgKSB7XG4gICAgLy8gRmluZCB0aGUgd2lubmVyIG9mIHRoZSBsb3NlcnMgYnJhY2tldCBmaW5hbFxuICAgIGNvbnN0IGxvc2Vyc0JyYWNrZXRXaW5uZXIgPSBjdXJyZW50Um91bmQubWF0Y2hlc1xuICAgICAgLmZpbHRlcihcbiAgICAgICAgKG0pID0+XG4gICAgICAgICAgKG0uYnJhY2tldCA9PT0gXCJsb3NlcnNcIiB8fCBtLmlkLmluY2x1ZGVzKFwiTG9zZXJzTGFzdFwiKSkgJiZcbiAgICAgICAgICBtLmlzQ29tcGxldGVkICYmXG4gICAgICAgICAgbS53aW5uZXJcbiAgICAgIClcbiAgICAgIC5tYXAoKG0pID0+IG0ud2lubmVyISlcbiAgICAgIC5wb3AoKTtcblxuICAgIGlmIChsb3NlcnNCcmFja2V0V2lubmVyKSB7XG4gICAgICAvLyBPbmx5IHNjaGVkdWxlIHRoZSBjaGFtcGlvbnNoaXAgaWYgdGhlcmUgaXMgbm8gd2lubmVyc0JyYWNrZXRGaW5hbExvc2VyIHdhaXRpbmcgdG8gcGxheVxuICAgICAgaWYgKCF0b3VybmFtZW50Lndpbm5lcnNCcmFja2V0RmluYWxMb3Nlcikge1xuICAgICAgICAvLyBTY2hlZHVsZSBjaGFtcGlvbnNoaXAgbWF0Y2ggaW1tZWRpYXRlbHkgKG5vIGV4dHJhIHJvdW5kKVxuICAgICAgICBuZXh0Um91bmRNYXRjaGVzLnB1c2goXG4gICAgICAgICAgY3JlYXRlTWF0Y2goXG4gICAgICAgICAgICBgQyR7bmV4dFJvdW5kTnVtYmVyfS0xYCxcbiAgICAgICAgICAgIG5leHRSb3VuZE51bWJlcixcbiAgICAgICAgICAgIHdpbm5lcnNCcmFja2V0VGVhbXNbMF0sIC8vIFdpbm5lcidzIGJyYWNrZXQgY2hhbXBpb25cbiAgICAgICAgICAgIGxvc2Vyc0JyYWNrZXRXaW5uZXIsIC8vIExvc2VyJ3MgYnJhY2tldCBjaGFtcGlvblxuICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICBcImNoYW1waW9uc2hpcFwiXG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgICBpc0NoYW1waW9uc2hpcFJvdW5kID0gdHJ1ZTtcbiAgICAgICAgLy8gRG8gTk9UIHNjaGVkdWxlIGFueSB3YWl0aW5nIGNhcmRzXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBJbnN0ZWFkLCBzY2hlZHVsZSB0aGUgbG9zZXJzIGJyYWNrZXQgZmluYWwgKExMV0IgdnMgTFdMQiksIGFuZCBzaG93IHRoZSB3aW5uZXJzIGJyYWNrZXQgY2hhbXBpb24gYXMgd2FpdGluZ1xuICAgICAgICBuZXh0Um91bmRNYXRjaGVzLnB1c2goXG4gICAgICAgICAgY3JlYXRlTWF0Y2goXG4gICAgICAgICAgICBgTG9zZXJzTGFzdC0ke25leHRSb3VuZE51bWJlcn1gLFxuICAgICAgICAgICAgbmV4dFJvdW5kTnVtYmVyLFxuICAgICAgICAgICAgdG91cm5hbWVudC53aW5uZXJzQnJhY2tldEZpbmFsTG9zZXIsXG4gICAgICAgICAgICBsb3NlcnNCcmFja2V0VGVhbXNbMF0sXG4gICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgIFwibG9zZXJzXCJcbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICAgIG5leHRSb3VuZE1hdGNoZXMucHVzaChcbiAgICAgICAgICBjcmVhdGVNYXRjaChcbiAgICAgICAgICAgIGBXaW5uZXJzQnJhY2tldENoYW1waW9uLXdhaXRpbmctJHtuZXh0Um91bmROdW1iZXJ9YCxcbiAgICAgICAgICAgIG5leHRSb3VuZE51bWJlcixcbiAgICAgICAgICAgIHdpbm5lcnNCcmFja2V0VGVhbXNbMF0sXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAgIFwid2lubmVyc1wiXG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvLyBDaGVjayBpZiB3ZSBuZWVkIHRvIGNyZWF0ZSB0aGUgZmluYWwgbG9zZXJzIGJyYWNrZXQgbWF0Y2ggKHdpbm5lcnMgYnJhY2tldCBmaW5hbCBsb3NlciB2cyBsb3NlcnMgYnJhY2tldCB3aW5uZXIpXG4gIGVsc2UgaWYgKFxuICAgIHdpbm5lcnNCcmFja2V0VGVhbXMubGVuZ3RoID09PSAxICYmXG4gICAgdG91cm5hbWVudC53aW5uZXJzQnJhY2tldEZpbmFsTG9zZXJcbiAgKSB7XG4gICAgaWYgKGxvc2Vyc0JyYWNrZXRUZWFtcy5sZW5ndGggPT09IDEpIHtcbiAgICAgIC8vIFByZXZlbnQgZHVwbGljYXRlIGxvc2VycyBicmFja2V0IGZpbmFsOiBjaGVjayBhbGwgcHJldmlvdXMgcm91bmRzIGZvciB0aGlzIG1hdGNoXG4gICAgICBsZXQgYWxyZWFkeVBsYXllZCA9IGZhbHNlO1xuICAgICAgZm9yIChsZXQgcm91bmQgb2YgdG91cm5hbWVudC5yb3VuZHMpIHtcbiAgICAgICAgaWYgKCFyb3VuZC5tYXRjaGVzKSBjb250aW51ZTtcbiAgICAgICAgZm9yIChsZXQgbSBvZiByb3VuZC5tYXRjaGVzKSB7XG4gICAgICAgICAgY29uc3QgaWRzID0gW20udGVhbTE/LmlkLCBtLnRlYW0yPy5pZF0uZmlsdGVyKEJvb2xlYW4pLnNvcnQoKTtcbiAgICAgICAgICBjb25zdCBjdXJySWRzID0gW3RvdXJuYW1lbnQud2lubmVyc0JyYWNrZXRGaW5hbExvc2VyLmlkLCBsb3NlcnNCcmFja2V0VGVhbXNbMF0uaWRdLnNvcnQoKTtcbiAgICAgICAgICBpZiAoaWRzLmxlbmd0aCA9PT0gMiAmJiBpZHNbMF0gPT09IGN1cnJJZHNbMF0gJiYgaWRzWzFdID09PSBjdXJySWRzWzFdKSB7XG4gICAgICAgICAgICBhbHJlYWR5UGxheWVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYWxyZWFkeVBsYXllZCkgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoIWFscmVhZHlQbGF5ZWQpIHtcbiAgICAgICAgLy8gT25seSBub3cgc2NoZWR1bGUgV0JGTCB2cyBMQkxcbiAgICAgICAgbmV4dFJvdW5kTWF0Y2hlcy5wdXNoKFxuICAgICAgICAgIGNyZWF0ZU1hdGNoKFxuICAgICAgICAgICAgYExvc2Vyc0xhc3QtJHtuZXh0Um91bmROdW1iZXJ9YCxcbiAgICAgICAgICAgIG5leHRSb3VuZE51bWJlcixcbiAgICAgICAgICAgIHRvdXJuYW1lbnQud2lubmVyc0JyYWNrZXRGaW5hbExvc2VyLFxuICAgICAgICAgICAgbG9zZXJzQnJhY2tldFRlYW1zWzBdLFxuICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICBcImxvc2Vyc1wiXG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgLy8gSWYgbWF0Y2ggYWxyZWFkeSBwbGF5ZWQsIGRvIG5vdCBzY2hlZHVsZSBhZ2FpbjsgY2hhbXBpb25zaGlwIGxvZ2ljIHdpbGwgaGFuZGxlIG5leHQgc3RlcFxuICAgIH0gZWxzZSBpZiAobG9zZXJzQnJhY2tldFRlYW1zLmxlbmd0aCA9PT0gMikge1xuICAgICAgLy8gU2NoZWR1bGUgdGhlIG1hdGNoIGJldHdlZW4gdGhlIGxhc3QgdHdvIGxvc2VycyBicmFja2V0IHRlYW1zXG4gICAgICBuZXh0Um91bmRNYXRjaGVzLnB1c2goXG4gICAgICAgIGNyZWF0ZU1hdGNoKFxuICAgICAgICAgIGBMJHtuZXh0Um91bmROdW1iZXJ9LTFgLFxuICAgICAgICAgIG5leHRSb3VuZE51bWJlcixcbiAgICAgICAgICBsb3NlcnNCcmFja2V0VGVhbXNbMF0sXG4gICAgICAgICAgbG9zZXJzQnJhY2tldFRlYW1zWzFdLFxuICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgIFwibG9zZXJzXCJcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICAgIC8vIFdCRkwgaXMgd2FpdGluZyBmb3IgdGhlIHdpbm5lclxuICAgICAgbmV4dFJvdW5kTWF0Y2hlcy5wdXNoKFxuICAgICAgICBjcmVhdGVNYXRjaChcbiAgICAgICAgICBgV2lubmVyc0ZpbmFsTG9zZXItd2FpdGluZy0ke25leHRSb3VuZE51bWJlcn1gLFxuICAgICAgICAgIG5leHRSb3VuZE51bWJlcixcbiAgICAgICAgICB0b3VybmFtZW50Lndpbm5lcnNCcmFja2V0RmluYWxMb3NlcixcbiAgICAgICAgICBudWxsLFxuICAgICAgICAgIHRydWUsXG4gICAgICAgICAgXCJsb3NlcnNcIlxuICAgICAgICApXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAobG9zZXJzQnJhY2tldFRlYW1zLmxlbmd0aCA+IDIpIHtcbiAgICAgIC8vIE1vcmUgdGhhbiAyIHRlYW1zOiBwYWlyIG9mZiBhcyB1c3VhbCwgV0JGTCB3YWl0c1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsb3NlcnNCcmFja2V0VGVhbXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgY29uc3QgdGVhbTEgPSBsb3NlcnNCcmFja2V0VGVhbXNbaV07XG4gICAgICAgIGNvbnN0IHRlYW0yID0gbG9zZXJzQnJhY2tldFRlYW1zW2kgKyAxXSA/PyBudWxsO1xuICAgICAgICBuZXh0Um91bmRNYXRjaGVzLnB1c2goXG4gICAgICAgICAgY3JlYXRlTWF0Y2goXG4gICAgICAgICAgICBgTCR7bmV4dFJvdW5kTnVtYmVyfS0ke01hdGguZmxvb3IoaSAvIDIpICsgMX1gLFxuICAgICAgICAgICAgbmV4dFJvdW5kTnVtYmVyLFxuICAgICAgICAgICAgdGVhbTEsXG4gICAgICAgICAgICB0ZWFtMixcbiAgICAgICAgICAgICF0ZWFtMixcbiAgICAgICAgICAgIFwibG9zZXJzXCJcbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBuZXh0Um91bmRNYXRjaGVzLnB1c2goXG4gICAgICAgIGNyZWF0ZU1hdGNoKFxuICAgICAgICAgIGBXaW5uZXJzRmluYWxMb3Nlci13YWl0aW5nLSR7bmV4dFJvdW5kTnVtYmVyfWAsXG4gICAgICAgICAgbmV4dFJvdW5kTnVtYmVyLFxuICAgICAgICAgIHRvdXJuYW1lbnQud2lubmVyc0JyYWNrZXRGaW5hbExvc2VyLFxuICAgICAgICAgIG51bGwsXG4gICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICBcImxvc2Vyc1wiXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFdCRkwgaXMgd2FpdGluZyBmb3IgdGhlIGxvc2VycyBicmFja2V0IHRvIHJlc29sdmVcbiAgICAgIG5leHRSb3VuZE1hdGNoZXMucHVzaChcbiAgICAgICAgY3JlYXRlTWF0Y2goXG4gICAgICAgICAgYFdpbm5lcnNGaW5hbExvc2VyLXdhaXRpbmctJHtuZXh0Um91bmROdW1iZXJ9YCxcbiAgICAgICAgICBuZXh0Um91bmROdW1iZXIsXG4gICAgICAgICAgdG91cm5hbWVudC53aW5uZXJzQnJhY2tldEZpbmFsTG9zZXIsXG4gICAgICAgICAgbnVsbCxcbiAgICAgICAgICB0cnVlLFxuICAgICAgICAgIFwibG9zZXJzXCJcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9XG4gICAgLy8gQWx3YXlzIHNob3cgYSB3YWl0aW5nIGNhcmQgZm9yIHRoZSB3aW5uZXJzIGJyYWNrZXQgY2hhbXBpb24gaWYgbm90IGluIGNoYW1waW9uc2hpcFxuICAgIG5leHRSb3VuZE1hdGNoZXMucHVzaChcbiAgICAgIGNyZWF0ZU1hdGNoKFxuICAgICAgICBgV2lubmVyc0JyYWNrZXRDaGFtcGlvbi13YWl0aW5nLSR7bmV4dFJvdW5kTnVtYmVyfWAsXG4gICAgICAgIG5leHRSb3VuZE51bWJlcixcbiAgICAgICAgd2lubmVyc0JyYWNrZXRUZWFtc1swXSxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgdHJ1ZSxcbiAgICAgICAgXCJ3aW5uZXJzXCJcbiAgICAgIClcbiAgICApO1xuICB9XG4gIC8vIENoZWNrIGlmIHRoaXMgaXMgdGhlIHdpbm5lcidzIGJyYWNrZXQgZmluYWwgKGV4YWN0bHkgMiB0ZWFtcyBpbiB3aW5uZXIncyBicmFja2V0KVxuICBlbHNlIGlmICh3aW5uZXJzQnJhY2tldFRlYW1zLmxlbmd0aCA9PT0gMikge1xuICAgIC8vIENyZWF0ZSB0aGUgd2lubmVyJ3MgYnJhY2tldCBmaW5hbCBtYXRjaFxuICAgIG5leHRSb3VuZE1hdGNoZXMucHVzaChcbiAgICAgIGNyZWF0ZU1hdGNoKFxuICAgICAgICBgVyR7bmV4dFJvdW5kTnVtYmVyfS0xYCxcbiAgICAgICAgbmV4dFJvdW5kTnVtYmVyLFxuICAgICAgICB3aW5uZXJzQnJhY2tldFRlYW1zWzBdLFxuICAgICAgICB3aW5uZXJzQnJhY2tldFRlYW1zWzFdLFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgXCJ3aW5uZXJzXCJcbiAgICAgIClcbiAgICApO1xuXG4gICAgLy8gQ29udGludWUgd2l0aCBsb3NlcnMgYnJhY2tldCBtYXRjaGVzIHNlcGFyYXRlbHlcbiAgICBjcmVhdGVMb3NlcnNCcmFja2V0TWF0Y2hlcygpO1xuICB9XG4gIC8vIE90aGVyd2lzZSwgY29udGludWUgd2l0aCBub3JtYWwgYnJhY2tldCBwbGF5XG4gIGVsc2Uge1xuICAgIGNyZWF0ZVN0YW5kYXJkQnJhY2tldE1hdGNoZXMoKTtcbiAgfVxuXG4gIC8vIEhlbHBlciBmdW5jdGlvbiB0byBjcmVhdGUgc3RhbmRhcmQgYnJhY2tldCBtYXRjaGVzXG4gIGZ1bmN0aW9uIGNyZWF0ZVN0YW5kYXJkQnJhY2tldE1hdGNoZXMoKSB7XG4gICAgLy8gLS0tIFdpbm5lcnMgQnJhY2tldCBNYXRjaGVzIC0tLVxuICAgIGxldCBtYXRjaENvdW50ZXIgPSAxO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgd2lubmVyc0JyYWNrZXRUZWFtcy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgY29uc3QgdGVhbTEgPSB3aW5uZXJzQnJhY2tldFRlYW1zW2ldO1xuICAgICAgY29uc3QgdGVhbTIgPSB3aW5uZXJzQnJhY2tldFRlYW1zW2kgKyAxXSA/PyBudWxsO1xuICAgICAgY29uc3QgaXNCeWUgPSAhdGVhbTI7XG4gICAgICBuZXh0Um91bmRNYXRjaGVzLnB1c2goXG4gICAgICAgIGNyZWF0ZU1hdGNoKFxuICAgICAgICAgIGBXJHtuZXh0Um91bmROdW1iZXJ9LSR7bWF0Y2hDb3VudGVyfWAsXG4gICAgICAgICAgbmV4dFJvdW5kTnVtYmVyLFxuICAgICAgICAgIHRlYW0xLFxuICAgICAgICAgIHRlYW0yLFxuICAgICAgICAgIGlzQnllLFxuICAgICAgICAgIFwid2lubmVyc1wiXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgICBtYXRjaENvdW50ZXIrKztcbiAgICB9XG5cbiAgICAvLyBDcmVhdGUgbG9zZXJzIGJyYWNrZXQgbWF0Y2hlcyBzZXBhcmF0ZWx5XG4gICAgY3JlYXRlTG9zZXJzQnJhY2tldE1hdGNoZXMoKTtcbiAgfVxuXG4gIC8vIEhlbHBlciBmdW5jdGlvbiB0byBjcmVhdGUgbG9zZXJzIGJyYWNrZXQgbWF0Y2hlc1xuICBmdW5jdGlvbiBjcmVhdGVMb3NlcnNCcmFja2V0TWF0Y2hlcygpIHtcbiAgICAvLyAtLS0gTG9zZXJzIEJyYWNrZXQgTWF0Y2hlcyAtLS1cbiAgICBjb25zdCBlbGlnaWJsZUxvc2VycyA9IGFsbFRlYW1zLmZpbHRlcihcbiAgICAgICh0ZWFtKSA9PlxuICAgICAgICAobG9zc0NvdW50c1t0ZWFtLmlkXSB8fCAwKSA9PT0gMSAmJlxuICAgICAgICAhdG91cm5hbWVudC5lbGltaW5hdGVkVGVhbXMuc29tZSgodCkgPT4gdC5pZCA9PT0gdGVhbS5pZCkgJiZcbiAgICAgICAgIW5ld2x5RWxpbWluYXRlZC5zb21lKCh0KSA9PiB0LmlkID09PSB0ZWFtLmlkKSAmJlxuICAgICAgICAvLyBFeGNsdWRlIHdpbm5lcidzIGJyYWNrZXQgZmluYWwgbG9zZXIgaWYgaXQgZXhpc3RzXG4gICAgICAgICEoXG4gICAgICAgICAgdG91cm5hbWVudC53aW5uZXJzQnJhY2tldEZpbmFsTG9zZXIgJiZcbiAgICAgICAgICB0b3VybmFtZW50Lndpbm5lcnNCcmFja2V0RmluYWxMb3Nlci5pZCA9PT0gdGVhbS5pZFxuICAgICAgICApXG4gICAgKTtcblxuICAgIC8vIEZpbmQgdGVhbXMgcmVjZW50bHkgZHJvcHBlZCBmcm9tIHdpbm5lcnMgYnJhY2tldFxuICAgIGNvbnN0IGp1c3REcm9wcGVkRnJvbVdpbm5lcnMgPSBjdXJyZW50Um91bmQubWF0Y2hlc1xuICAgICAgLmZpbHRlcigobSkgPT4gbS5icmFja2V0ID09PSBcIndpbm5lcnNcIiAmJiBtLmxvc2VyICYmIG0uaXNDb21wbGV0ZWQpXG4gICAgICAubWFwKChtKSA9PiBtLmxvc2VyISlcbiAgICAgIC5maWx0ZXIoKGxvc2VyKSA9PiBlbGlnaWJsZUxvc2Vycy5zb21lKCh0KSA9PiB0LmlkID09PSBsb3Nlci5pZCkpO1xuXG4gICAgLy8gSWYgdGhpcyBpcyB0aGUgd2lubmVyJ3MgYnJhY2tldCBmaW5hbCwgc3RvcmUgdGhlIGxvc2VyIGZvciBsYXRlciB1c2VcbiAgICBpZiAoXG4gICAgICBjdXJyZW50Um91bmQubWF0Y2hlcy5zb21lKFxuICAgICAgICAobSkgPT5cbiAgICAgICAgICBtLmJyYWNrZXQgPT09IFwid2lubmVyc1wiICYmXG4gICAgICAgICAgd2lubmVyc0JyYWNrZXRUZWFtcy5sZW5ndGggPT09IDEgJiZcbiAgICAgICAgICBtLmxvc2VyICYmXG4gICAgICAgICAgbS5pc0NvbXBsZXRlZFxuICAgICAgKVxuICAgICkge1xuICAgICAgLy8gVGhpcyBpcyBhIHNwZWNpYWwgY2FzZSAtIHdlIGZvdW5kIHRoZSB3aW5uZXIncyBicmFja2V0IGZpbmFsIGxvc2VyXG4gICAgICBjb25zdCB3aW5uZXJzRmluYWxMb3NlciA9IGN1cnJlbnRSb3VuZC5tYXRjaGVzXG4gICAgICAgIC5maWx0ZXIoKG0pID0+IG0uYnJhY2tldCA9PT0gXCJ3aW5uZXJzXCIgJiYgbS5pc0NvbXBsZXRlZCAmJiBtLmxvc2VyKVxuICAgICAgICAubWFwKChtKSA9PiBtLmxvc2VyISlcbiAgICAgICAgLnBvcCgpO1xuXG4gICAgICBpZiAoXG4gICAgICAgIHdpbm5lcnNGaW5hbExvc2VyICYmXG4gICAgICAgICF0b3VybmFtZW50LmVsaW1pbmF0ZWRUZWFtcy5zb21lKCh0KSA9PiB0LmlkID09PSB3aW5uZXJzRmluYWxMb3Nlci5pZClcbiAgICAgICkge1xuICAgICAgICB0b3VybmFtZW50Lndpbm5lcnNCcmFja2V0RmluYWxMb3NlciA9IHdpbm5lcnNGaW5hbExvc2VyO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEV4aXN0aW5nIGxvc2VycyBicmFja2V0IHRlYW1zXG4gICAgY29uc3QgZXhpc3RpbmdMb3NlcnMgPSBlbGlnaWJsZUxvc2Vycy5maWx0ZXIoXG4gICAgICAodCkgPT4gIWp1c3REcm9wcGVkRnJvbVdpbm5lcnMuc29tZSgoamQpID0+IGpkLmlkID09PSB0LmlkKVxuICAgICk7XG5cbiAgICAvLyBPcmRlcjogbW9zdCByZWNlbnQgZHJvcChzKSBmaXJzdFxuICAgIGNvbnN0IG9yZGVyZWRMb3NlcnMgPSBbLi4uanVzdERyb3BwZWRGcm9tV2lubmVycywgLi4uZXhpc3RpbmdMb3NlcnNdO1xuXG4gICAgaWYgKG9yZGVyZWRMb3NlcnMubGVuZ3RoID4gMCkge1xuICAgICAgaWYgKG9yZGVyZWRMb3NlcnMubGVuZ3RoICUgMiA9PT0gMSkge1xuICAgICAgICAvLyBPZGQ6IGJ5ZSBnb2VzIHRvIHRoZSBtb3N0IHJlY2VudCB0ZWFtIGRyb3BwZWQgZnJvbSB3aW5uZXJzIGJyYWNrZXRcbiAgICAgICAgbGV0IHRlYW1XaXRoQnllOiBUZWFtIHwgbnVsbCA9IG51bGw7XG4gICAgICAgIGlmIChqdXN0RHJvcHBlZEZyb21XaW5uZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICB0ZWFtV2l0aEJ5ZSA9XG4gICAgICAgICAgICBqdXN0RHJvcHBlZEZyb21XaW5uZXJzW2p1c3REcm9wcGVkRnJvbVdpbm5lcnMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgLy8gUmVtb3ZlIHRoZSBieWUgdGVhbSBmcm9tIG9yZGVyZWRMb3NlcnNcbiAgICAgICAgICBjb25zdCBieWVJbmRleCA9IG9yZGVyZWRMb3NlcnMuZmluZEluZGV4KFxuICAgICAgICAgICAgKHQpID0+IHQuaWQgPT09IHRlYW1XaXRoQnllIS5pZFxuICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKGJ5ZUluZGV4ICE9PSAtMSkgb3JkZXJlZExvc2Vycy5zcGxpY2UoYnllSW5kZXgsIDEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIERlZmVuc2l2ZTogZmFsbGJhY2sgdG8gZmlyc3QgdGVhbSBpZiBubyByZWNlbnQgZHJvcFxuICAgICAgICAgIHRlYW1XaXRoQnllID0gb3JkZXJlZExvc2Vycy5zaGlmdCgpITtcbiAgICAgICAgfVxuICAgICAgICBuZXh0Um91bmRNYXRjaGVzLnB1c2goXG4gICAgICAgICAgY3JlYXRlTWF0Y2goXG4gICAgICAgICAgICBgTCR7bmV4dFJvdW5kTnVtYmVyfS0xYCxcbiAgICAgICAgICAgIG5leHRSb3VuZE51bWJlcixcbiAgICAgICAgICAgIHRlYW1XaXRoQnllLFxuICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgIHRydWUsXG4gICAgICAgICAgICBcImxvc2Vyc1wiXG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgICAvLyBQYWlyIHRoZSByZXN0XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3JkZXJlZExvc2Vycy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgIGNvbnN0IHRlYW0xID0gb3JkZXJlZExvc2Vyc1tpXTtcbiAgICAgICAgICBjb25zdCB0ZWFtMiA9IG9yZGVyZWRMb3NlcnNbaSArIDFdID8/IG51bGw7XG4gICAgICAgICAgbmV4dFJvdW5kTWF0Y2hlcy5wdXNoKFxuICAgICAgICAgICAgY3JlYXRlTWF0Y2goXG4gICAgICAgICAgICAgIGBMJHtuZXh0Um91bmROdW1iZXJ9LSR7TWF0aC5mbG9vcihpIC8gMikgKyAyfWAsXG4gICAgICAgICAgICAgIG5leHRSb3VuZE51bWJlcixcbiAgICAgICAgICAgICAgdGVhbTEsXG4gICAgICAgICAgICAgIHRlYW0yLFxuICAgICAgICAgICAgICAhdGVhbTIsXG4gICAgICAgICAgICAgIFwibG9zZXJzXCJcbiAgICAgICAgICAgIClcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBFdmVuIG51bWJlcjogcGFpciBhbGxcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvcmRlcmVkTG9zZXJzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgY29uc3QgdGVhbTEgPSBvcmRlcmVkTG9zZXJzW2ldO1xuICAgICAgICAgIGNvbnN0IHRlYW0yID0gb3JkZXJlZExvc2Vyc1tpICsgMV0gPz8gbnVsbDtcbiAgICAgICAgICBuZXh0Um91bmRNYXRjaGVzLnB1c2goXG4gICAgICAgICAgICBjcmVhdGVNYXRjaChcbiAgICAgICAgICAgICAgYEwke25leHRSb3VuZE51bWJlcn0tJHtNYXRoLmZsb29yKGkgLyAyKSArIDF9YCxcbiAgICAgICAgICAgICAgbmV4dFJvdW5kTnVtYmVyLFxuICAgICAgICAgICAgICB0ZWFtMSxcbiAgICAgICAgICAgICAgdGVhbTIsXG4gICAgICAgICAgICAgICF0ZWFtMixcbiAgICAgICAgICAgICAgXCJsb3NlcnNcIlxuICAgICAgICAgICAgKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyAtLS0gV2lubmVyIGRldGVjdGlvbiBsb2dpYyAtLS1cbiAgbGV0IHdpbm5lcjogVGVhbSB8IHVuZGVmaW5lZCA9IHRvdXJuYW1lbnQud2lubmVyO1xuXG4gIGlmIChpc0NoYW1waW9uc2hpcFJvdW5kKSB7XG4gICAgLy8gRmluZCB0aGUgbGFzdCBjaGFtcGlvbnNoaXAgbWF0Y2ggcGxheWVkXG4gICAgY29uc3QgbGFzdENoYW1wTWF0Y2ggPVxuICAgICAgY2hhbXBpb25zaGlwTWF0Y2hlc1swXSB8fFxuICAgICAgcHJldkNoYW1waW9uc2hpcE1hdGNoZXNbcHJldkNoYW1waW9uc2hpcE1hdGNoZXMubGVuZ3RoIC0gMV07XG5cbiAgICBpZiAoXG4gICAgICBsYXN0Q2hhbXBNYXRjaCAmJlxuICAgICAgbGFzdENoYW1wTWF0Y2guaXNDb21wbGV0ZWQgJiZcbiAgICAgIGxhc3RDaGFtcE1hdGNoLndpbm5lciAmJlxuICAgICAgbGFzdENoYW1wTWF0Y2gubG9zZXJcbiAgICApIHtcbiAgICAgIGNvbnN0IHdpbm5lcnNCcmFja2V0VGVhbSA9IGxhc3RDaGFtcE1hdGNoLnRlYW0xO1xuICAgICAgY29uc3QgbG9zZXJzQnJhY2tldFRlYW0gPSBsYXN0Q2hhbXBNYXRjaC50ZWFtMjtcbiAgICAgIGNvbnN0IGxvc2Vyc0JyYWNrZXRUZWFtV29uID1cbiAgICAgICAgbG9zZXJzQnJhY2tldFRlYW0gJiYgbGFzdENoYW1wTWF0Y2gud2lubmVyLmlkID09PSBsb3NlcnNCcmFja2V0VGVhbS5pZDtcblxuICAgICAgLy8gSWYgbG9zZXIncyBicmFja2V0IHRlYW0gd29uIGZpcnN0IGNoYW1waW9uc2hpcCBtYXRjaCwgd2lubmVyJ3MgYnJhY2tldCB0ZWFtIGdldHMgYW5vdGhlciBjaGFuY2VcbiAgICAgIGlmIChsb3NlcnNCcmFja2V0VGVhbVdvbiAmJiB0b3VybmFtZW50LmNoYW1waW9uc2hpcE1hdGNoZXNQbGF5ZWQgPT09IDEpIHtcbiAgICAgICAgd2lubmVyID0gdW5kZWZpbmVkOyAvLyBObyB3aW5uZXIgeWV0LCBuZWVkIHJlc2V0IG1hdGNoXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBFaXRoZXIgd2lubmVyJ3MgYnJhY2tldCB0ZWFtIHdvbiBmaXJzdCBtYXRjaCwgb3IgdGhpcyB3YXMgdGhlIHJlc2V0IG1hdGNoXG4gICAgICAgIHdpbm5lciA9IGxhc3RDaGFtcE1hdGNoLndpbm5lcjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyAtLS0gSU5GSU5JVEUgUkVDVVJTSU9OIEdVQVJEIC0tLVxuICBjb25zdCBub01vcmVNYXRjaGVzID1cbiAgICAoaXNDaGFtcGlvbnNoaXBSb3VuZCAmJiBjaGFtcGlvbnNoaXBNYXRjaGVzLmxlbmd0aCA9PT0gMCkgfHxcbiAgICAoIWlzQ2hhbXBpb25zaGlwUm91bmQgJiYgbmV4dFJvdW5kTWF0Y2hlcy5sZW5ndGggPT09IDApO1xuXG4gIGlmIChub01vcmVNYXRjaGVzKSB7XG4gICAgLy8gVG91cm5hbWVudCBpcyBvdmVyLCBkbyBub3QgYWR2YW5jZSBmdXJ0aGVyXG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnRvdXJuYW1lbnQsXG4gICAgICB3aW5uZXIsXG4gICAgICBjdXJyZW50Um91bmQ6IHRvdXJuYW1lbnQuY3VycmVudFJvdW5kXG4gICAgfTtcbiAgfVxuXG4gIC8vIERlYnVnIGxvZyBiZWZvcmUgcmV0dXJuaW5nIHRoZSBuZXcgdG91cm5hbWVudCBvYmplY3RcbiAgbG9nVG91cm5hbWVudFN0YXRlKHtcbiAgICByb3VuZE51bWJlcjogbmV4dFJvdW5kTnVtYmVyLFxuICAgIHdpbm5lcnNCcmFja2V0VGVhbXMsXG4gICAgbG9zZXJzQnJhY2tldFRlYW1zLFxuICAgIG1hdGNoZXM6IGlzQ2hhbXBpb25zaGlwUm91bmQgPyBjaGFtcGlvbnNoaXBNYXRjaGVzIDogbmV4dFJvdW5kTWF0Y2hlcyxcbiAgICB3aW5uZXJzQnJhY2tldEZpbmFsTG9zZXI6IHRvdXJuYW1lbnQud2lubmVyc0JyYWNrZXRGaW5hbExvc2VyXG4gIH0pO1xuXG4gIC8vIENvbXBvc2UgdGhlIG5ldyB0b3VybmFtZW50IG9iamVjdFxuICByZXR1cm4ge1xuICAgIC4uLnRvdXJuYW1lbnQsXG4gICAgcm91bmRzOiBbXG4gICAgICAuLi50b3VybmFtZW50LnJvdW5kcyxcbiAgICAgIHtcbiAgICAgICAgcm91bmROdW1iZXI6IG5leHRSb3VuZE51bWJlcixcbiAgICAgICAgbWF0Y2hlczogaXNDaGFtcGlvbnNoaXBSb3VuZCA/IGNoYW1waW9uc2hpcE1hdGNoZXMgOiBuZXh0Um91bmRNYXRjaGVzLFxuICAgICAgICBpc0RvdWJsZUVsaW1pbmF0aW9uOiB0cnVlLFxuICAgICAgICBpc0NoYW1waW9uc2hpcFJvdW5kXG4gICAgICB9XG4gICAgXSxcbiAgICBjdXJyZW50Um91bmQ6IG5leHRSb3VuZE51bWJlcixcbiAgICBlbGltaW5hdGVkVGVhbXM6IFtcbiAgICAgIC4uLnRvdXJuYW1lbnQuZWxpbWluYXRlZFRlYW1zLFxuICAgICAgLi4ubmV3bHlFbGltaW5hdGVkLmZpbHRlcihcbiAgICAgICAgKHQpID0+ICF0b3VybmFtZW50LmVsaW1pbmF0ZWRUZWFtcy5zb21lKChldCkgPT4gZXQuaWQgPT09IHQuaWQpXG4gICAgICApXG4gICAgXSxcbiAgICBjaGFtcGlvbnNoaXBNYXRjaGVzUGxheWVkOiBpc0NoYW1waW9uc2hpcFJvdW5kXG4gICAgICA/IHRvdXJuYW1lbnQuY2hhbXBpb25zaGlwTWF0Y2hlc1BsYXllZCArIDFcbiAgICAgIDogdG91cm5hbWVudC5jaGFtcGlvbnNoaXBNYXRjaGVzUGxheWVkLFxuICAgIHdpbm5lcnNCcmFja2V0RmluYWxMb3NlcjogdG91cm5hbWVudC53aW5uZXJzQnJhY2tldEZpbmFsTG9zZXIsXG4gICAgd2lubmVyXG4gIH07XG59O1xuLy8gZXhwb3J0IGNvbnN0IGFkdmFuY2VUb05leHRSb3VuZCA9ICh0b3VybmFtZW50OiBUb3VybmFtZW50KTogVG91cm5hbWVudCA9PiB7XG4vLyAgIGNvbnN0IGN1cnJlbnRSb3VuZCA9IHRvdXJuYW1lbnQucm91bmRzW3RvdXJuYW1lbnQucm91bmRzLmxlbmd0aCAtIDFdO1xuLy8gICBjb25zdCBuZXh0Um91bmROdW1iZXIgPSB0b3VybmFtZW50LmN1cnJlbnRSb3VuZCArIDE7XG5cbi8vICAgLy8gVHJhY2sgYWxsIGxvc3NlcyBhY3Jvc3MgdGhlIHRvdXJuYW1lbnRcbi8vICAgY29uc3QgbG9zc0NvdW50czogUmVjb3JkPHN0cmluZywgbnVtYmVyPiA9IHt9O1xuLy8gICB0b3VybmFtZW50LnJvdW5kcy5mb3JFYWNoKChyb3VuZCkgPT4ge1xuLy8gICAgIHJvdW5kLm1hdGNoZXMuZm9yRWFjaCgobWF0Y2gpID0+IHtcbi8vICAgICAgIGlmIChtYXRjaC5pc0NvbXBsZXRlZCAmJiBtYXRjaC5sb3Nlcikge1xuLy8gICAgICAgICBsb3NzQ291bnRzW21hdGNoLmxvc2VyLmlkXSA9IChsb3NzQ291bnRzW21hdGNoLmxvc2VyLmlkXSB8fCAwKSArIDE7XG4vLyAgICAgICB9XG4vLyAgICAgfSk7XG4vLyAgIH0pO1xuXG4vLyAgIC8vIEdhdGhlciBhbGwgdGVhbXMgZXZlciBpbiB0aGUgdG91cm5hbWVudFxuLy8gICBjb25zdCBhbGxUZWFtczogVGVhbVtdID0gW107XG4vLyAgIGNvbnN0IHRlYW1JZHMgPSBuZXcgU2V0PHN0cmluZz4oKTtcbi8vICAgZm9yIChjb25zdCByb3VuZCBvZiB0b3VybmFtZW50LnJvdW5kcykge1xuLy8gICAgIGZvciAoY29uc3QgbWF0Y2ggb2Ygcm91bmQubWF0Y2hlcykge1xuLy8gICAgICAgaWYgKG1hdGNoLnRlYW0xICYmICF0ZWFtSWRzLmhhcyhtYXRjaC50ZWFtMS5pZCkpIHtcbi8vICAgICAgICAgYWxsVGVhbXMucHVzaChtYXRjaC50ZWFtMSk7XG4vLyAgICAgICAgIHRlYW1JZHMuYWRkKG1hdGNoLnRlYW0xLmlkKTtcbi8vICAgICAgIH1cbi8vICAgICAgIGlmIChtYXRjaC50ZWFtMiAmJiAhdGVhbUlkcy5oYXMobWF0Y2gudGVhbTIuaWQpKSB7XG4vLyAgICAgICAgIGFsbFRlYW1zLnB1c2gobWF0Y2gudGVhbTIpO1xuLy8gICAgICAgICB0ZWFtSWRzLmFkZChtYXRjaC50ZWFtMi5pZCk7XG4vLyAgICAgICB9XG4vLyAgICAgfVxuLy8gICB9XG5cbi8vICAgLy8gSWRlbnRpZnkgbmV3bHkgZWxpbWluYXRlZCB0ZWFtcyAoMiBsb3NzZXMpXG4vLyAgIGNvbnN0IG5ld2x5RWxpbWluYXRlZDogVGVhbVtdID0gW107XG4vLyAgIGZvciAoY29uc3QgdGVhbSBvZiBhbGxUZWFtcykge1xuLy8gICAgIGlmIChcbi8vICAgICAgIChsb3NzQ291bnRzW3RlYW0uaWRdIHx8IDApID49IDIgJiZcbi8vICAgICAgICF0b3VybmFtZW50LmVsaW1pbmF0ZWRUZWFtcy5zb21lKCh0KSA9PiB0LmlkID09PSB0ZWFtLmlkKVxuLy8gICAgICkge1xuLy8gICAgICAgbmV3bHlFbGltaW5hdGVkLnB1c2godGVhbSk7XG4vLyAgICAgfVxuLy8gICB9XG5cbi8vICAgLy8gV2lubmVyczogdGVhbXMgd2l0aCAwIGxvc3NlcyBhbmQgbm90IGVsaW1pbmF0ZWRcbi8vICAgY29uc3Qgd2lubmVyc0JyYWNrZXRUZWFtcyA9IGFsbFRlYW1zLmZpbHRlcihcbi8vICAgICAodGVhbSkgPT5cbi8vICAgICAgIChsb3NzQ291bnRzW3RlYW0uaWRdIHx8IDApID09PSAwICYmXG4vLyAgICAgICAhdG91cm5hbWVudC5lbGltaW5hdGVkVGVhbXMuc29tZSgodCkgPT4gdC5pZCA9PT0gdGVhbS5pZCkgJiZcbi8vICAgICAgICFuZXdseUVsaW1pbmF0ZWQuc29tZSgodCkgPT4gdC5pZCA9PT0gdGVhbS5pZClcbi8vICAgKTtcblxuLy8gICAvLyBMb3NlcnM6IHRlYW1zIHdpdGggMSBsb3NzIGFuZCBub3QgZWxpbWluYXRlZFxuLy8gICBjb25zdCBsb3NlcnNCcmFja2V0VGVhbXMgPSBhbGxUZWFtcy5maWx0ZXIoXG4vLyAgICAgKHRlYW0pID0+XG4vLyAgICAgICAobG9zc0NvdW50c1t0ZWFtLmlkXSB8fCAwKSA9PT0gMSAmJlxuLy8gICAgICAgIXRvdXJuYW1lbnQuZWxpbWluYXRlZFRlYW1zLnNvbWUoKHQpID0+IHQuaWQgPT09IHRlYW0uaWQpICYmXG4vLyAgICAgICAhbmV3bHlFbGltaW5hdGVkLnNvbWUoKHQpID0+IHQuaWQgPT09IHRlYW0uaWQpXG4vLyAgICk7XG5cbi8vICAgbGV0IGlzQ2hhbXBpb25zaGlwUm91bmQgPSBmYWxzZTtcbi8vICAgbGV0IGNoYW1waW9uc2hpcE1hdGNoZXM6IE1hdGNoW10gPSBbXTtcbi8vICAgbGV0IG5leHRSb3VuZE1hdGNoZXM6IE1hdGNoW10gPSBbXTtcblxuLy8gICBjb25zdCBwcmV2Q2hhbXBpb25zaGlwTWF0Y2hlcyA9IHRvdXJuYW1lbnQucm91bmRzXG4vLyAgICAgLmZpbHRlcigocikgPT4gci5pc0NoYW1waW9uc2hpcFJvdW5kKVxuLy8gICAgIC5mbGF0TWFwKChyKSA9PiByLm1hdGNoZXMpXG4vLyAgICAgLmZpbHRlcigobSkgPT4gbS5icmFja2V0ID09PSBcImNoYW1waW9uc2hpcFwiKTtcblxuLy8gICAvLyAtLS0gQ0hBTVBJT05TSElQIExPR0lDIC0tLVxuXG4vLyAgIC8vIENoZWNrIGlmIGEgY2hhbXBpb25zaGlwIG1hdGNoIGFscmVhZHkgaGFwcGVuZWQgYW5kIHdhcyBjb21wbGV0ZWRcbi8vICAgaWYgKFxuLy8gICAgIHByZXZDaGFtcGlvbnNoaXBNYXRjaGVzLmxlbmd0aCA+PSAxICYmXG4vLyAgICAgcHJldkNoYW1waW9uc2hpcE1hdGNoZXNbcHJldkNoYW1waW9uc2hpcE1hdGNoZXMubGVuZ3RoIC0gMV0uaXNDb21wbGV0ZWRcbi8vICAgKSB7XG4vLyAgICAgY29uc3QgbGFzdENoYW1wTWF0Y2ggPVxuLy8gICAgICAgcHJldkNoYW1waW9uc2hpcE1hdGNoZXNbcHJldkNoYW1waW9uc2hpcE1hdGNoZXMubGVuZ3RoIC0gMV07XG4vLyAgICAgY29uc3Qgd2lubmVyc0JyYWNrZXRUZWFtID0gbGFzdENoYW1wTWF0Y2gudGVhbTE7XG4vLyAgICAgY29uc3QgbG9zZXJzQnJhY2tldFRlYW0gPSBsYXN0Q2hhbXBNYXRjaC50ZWFtMjtcblxuLy8gICAgIC8vIElmIGxvc2VyJ3MgYnJhY2tldCB0ZWFtIHdvbiB0aGUgZmlyc3QgY2hhbXBpb25zaGlwIG1hdGNoLCB3aW5uZXIncyBicmFja2V0IHRlYW0gZ2V0cyBhbm90aGVyIGNoYW5jZVxuLy8gICAgIGlmIChcbi8vICAgICAgIGxhc3RDaGFtcE1hdGNoLndpbm5lcj8uaWQgPT09IGxvc2Vyc0JyYWNrZXRUZWFtPy5pZCAmJlxuLy8gICAgICAgdG91cm5hbWVudC5jaGFtcGlvbnNoaXBNYXRjaGVzUGxheWVkID09PSAxXG4vLyAgICAgKSB7XG4vLyAgICAgICBpc0NoYW1waW9uc2hpcFJvdW5kID0gdHJ1ZTtcbi8vICAgICAgIC8vIENyZWF0ZSB0aGUgXCJyZXNldFwiIG1hdGNoXG4vLyAgICAgICBjaGFtcGlvbnNoaXBNYXRjaGVzLnB1c2goXG4vLyAgICAgICAgIGNyZWF0ZU1hdGNoKFxuLy8gICAgICAgICAgIGBDJHtuZXh0Um91bmROdW1iZXJ9LTFgLFxuLy8gICAgICAgICAgIG5leHRSb3VuZE51bWJlcixcbi8vICAgICAgICAgICB3aW5uZXJzQnJhY2tldFRlYW0sXG4vLyAgICAgICAgICAgbG9zZXJzQnJhY2tldFRlYW0sXG4vLyAgICAgICAgICAgZmFsc2UsXG4vLyAgICAgICAgICAgXCJjaGFtcGlvbnNoaXBcIlxuLy8gICAgICAgICApXG4vLyAgICAgICApO1xuLy8gICAgIH0gZWxzZSB7XG4vLyAgICAgICAvLyBFaXRoZXIgd2lubmVyJ3MgYnJhY2tldCB0ZWFtIHdvbiBmaXJzdCBtYXRjaCwgb3IgdGhpcyB3YXMgdGhlIHJlc2V0IG1hdGNoXG4vLyAgICAgICBpc0NoYW1waW9uc2hpcFJvdW5kID0gdHJ1ZTtcbi8vICAgICAgIC8vIE5vIG5ldyBtYXRjaGVzLCB3aW5uZXIgd2lsbCBiZSBkZXRlcm1pbmVkIGluIHdpbm5lciBkZXRlY3Rpb24gbG9naWNcbi8vICAgICB9XG4vLyAgIH1cbi8vICAgLy8gQ2hlY2sgaWYgd2UncmUgcmVhZHkgZm9yIHRoZSBjaGFtcGlvbnNoaXAgbWF0Y2ggLSBvbmUgdGVhbSBpbiBlYWNoIGJyYWNrZXQgYW5kIGxvc2VyJ3MgZmluYWwgaXMgY29tcGxldGVcbi8vICAgZWxzZSBpZiAoXG4vLyAgICAgd2lubmVyc0JyYWNrZXRUZWFtcy5sZW5ndGggPT09IDEgJiZcbi8vICAgICBsb3NlcnNCcmFja2V0VGVhbXMubGVuZ3RoID09PSAxICYmXG4vLyAgICAgY3VycmVudFJvdW5kLm1hdGNoZXMuc29tZShcbi8vICAgICAgIChtKSA9PlxuLy8gICAgICAgICAobS5icmFja2V0ID09PSBcImxvc2Vyc1wiIHx8IG0uaWQuaW5jbHVkZXMoXCJMb3NlcnNMYXN0XCIpKSAmJlxuLy8gICAgICAgICBtLmlzQ29tcGxldGVkICYmXG4vLyAgICAgICAgIG0ud2lubmVyICYmXG4vLyAgICAgICAgIGxvc2Vyc0JyYWNrZXRUZWFtcy5zb21lKCh0KSA9PiB0LmlkID09PSBtLndpbm5lciEuaWQpXG4vLyAgICAgKVxuLy8gICApIHtcbi8vICAgICAvLyBDaGFtcGlvbnNoaXAgbWF0Y2g6IFdpbm5lcidzIGJyYWNrZXQgY2hhbXBpb24gdnMgTG9zZXIncyBicmFja2V0IGNoYW1waW9uXG4vLyAgICAgaXNDaGFtcGlvbnNoaXBSb3VuZCA9IHRydWU7XG4vLyAgICAgY2hhbXBpb25zaGlwTWF0Y2hlcy5wdXNoKFxuLy8gICAgICAgY3JlYXRlTWF0Y2goXG4vLyAgICAgICAgIGBDJHtuZXh0Um91bmROdW1iZXJ9LTFgLFxuLy8gICAgICAgICBuZXh0Um91bmROdW1iZXIsXG4vLyAgICAgICAgIHdpbm5lcnNCcmFja2V0VGVhbXNbMF0sIC8vIFdpbm5lcidzIGJyYWNrZXQgY2hhbXBpb25cbi8vICAgICAgICAgbG9zZXJzQnJhY2tldFRlYW1zWzBdLCAvLyBMb3NlcidzIGJyYWNrZXQgY2hhbXBpb25cbi8vICAgICAgICAgZmFsc2UsXG4vLyAgICAgICAgIFwiY2hhbXBpb25zaGlwXCJcbi8vICAgICAgIClcbi8vICAgICApO1xuLy8gICB9XG4vLyAgIC8vIENoZWNrIGlmIHdlIGhhdmUgYSBsb3NlciBmcm9tIHdpbm5lcidzIGJyYWNrZXQgZmluYWwgd2FpdGluZyB0byBwbGF5IGFnYWluc3QgbG9zZXIncyBicmFja2V0IHdpbm5lclxuLy8gICBlbHNlIGlmIChcbi8vICAgICB3aW5uZXJzQnJhY2tldFRlYW1zLmxlbmd0aCA9PT0gMSAmJiAvLyBXZSBoYXZlIGEgd2lubmVyJ3MgYnJhY2tldCBjaGFtcGlvblxuLy8gICAgIGxvc2Vyc0JyYWNrZXRUZWFtcy5sZW5ndGggPj0gMSAmJiAvLyBXZSBoYXZlIGF0IGxlYXN0IG9uZSB0ZWFtIGluIGxvc2VyJ3MgYnJhY2tldFxuLy8gICAgIHRvdXJuYW1lbnQud2lubmVyc0JyYWNrZXRGaW5hbExvc2VyIC8vIFdlIGhhdmUgc3RvcmVkIHRoZSB3aW5uZXIncyBicmFja2V0IGZpbmFsIGxvc2VyXG4vLyAgICkge1xuLy8gICAgIC8vIEZpbmQgdGhlIHdpbm5lciBvZiB0aGUgbG9zZXIncyBicmFja2V0XG4vLyAgICAgY29uc3QgbG9zZXJzQnJhY2tldFdpbm5lciA9IGN1cnJlbnRSb3VuZC5tYXRjaGVzXG4vLyAgICAgICAuZmlsdGVyKChtKSA9PiBtLmJyYWNrZXQgPT09IFwibG9zZXJzXCIgJiYgbS5pc0NvbXBsZXRlZCAmJiBtLndpbm5lcilcbi8vICAgICAgIC5tYXAoKG0pID0+IG0ud2lubmVyISlcbi8vICAgICAgIC5maW5kKCh3aW5uZXIpID0+IGxvc2Vyc0JyYWNrZXRUZWFtcy5zb21lKCh0KSA9PiB0LmlkID09PSB3aW5uZXIuaWQpKTtcblxuLy8gICAgIGlmIChcbi8vICAgICAgIGxvc2Vyc0JyYWNrZXRXaW5uZXIgJiZcbi8vICAgICAgIGxvc2Vyc0JyYWNrZXRXaW5uZXIuaWQgIT09IHRvdXJuYW1lbnQud2lubmVyc0JyYWNrZXRGaW5hbExvc2VyLmlkXG4vLyAgICAgKSB7XG4vLyAgICAgICAvLyBPbmx5IHNjaGVkdWxlIGlmIHRoZXkncmUgbm90IHRoZSBzYW1lIHRlYW0hXG4vLyAgICAgICBuZXh0Um91bmRNYXRjaGVzLnB1c2goXG4vLyAgICAgICAgIGNyZWF0ZU1hdGNoKFxuLy8gICAgICAgICAgIGBMb3NlcnNMYXN0LSR7bmV4dFJvdW5kTnVtYmVyfWAsXG4vLyAgICAgICAgICAgbmV4dFJvdW5kTnVtYmVyLFxuLy8gICAgICAgICAgIHRvdXJuYW1lbnQud2lubmVyc0JyYWNrZXRGaW5hbExvc2VyLFxuLy8gICAgICAgICAgIGxvc2Vyc0JyYWNrZXRXaW5uZXIsXG4vLyAgICAgICAgICAgZmFsc2UsXG4vLyAgICAgICAgICAgXCJsb3NlcnNcIlxuLy8gICAgICAgICApXG4vLyAgICAgICApO1xuLy8gICAgIH0gZWxzZSB7XG4vLyAgICAgICAvLyBXYWl0IGZvciB0aGUgbG9zZXJzIGJyYWNrZXQgdG8gcmVzb2x2ZSBwcm9wZXJseVxuLy8gICAgICAgY3JlYXRlU3RhbmRhcmRCcmFja2V0TWF0Y2hlcygpO1xuLy8gICAgIH1cbi8vICAgfVxuLy8gICAvLyBDaGVjayBpZiB0aGlzIGlzIHRoZSB3aW5uZXIncyBicmFja2V0IGZpbmFsIChleGFjdGx5IDIgdGVhbXMgaW4gd2lubmVyJ3MgYnJhY2tldClcbi8vICAgZWxzZSBpZiAod2lubmVyc0JyYWNrZXRUZWFtcy5sZW5ndGggPT09IDIgJiYgbG9zZXJzQnJhY2tldFRlYW1zLmxlbmd0aCA+PSAxKSB7XG4vLyAgICAgLy8gQ3JlYXRlIHRoZSB3aW5uZXIncyBicmFja2V0IGZpbmFsIG1hdGNoXG4vLyAgICAgbmV4dFJvdW5kTWF0Y2hlcy5wdXNoKFxuLy8gICAgICAgY3JlYXRlTWF0Y2goXG4vLyAgICAgICAgIGBXJHtuZXh0Um91bmROdW1iZXJ9LTFgLFxuLy8gICAgICAgICBuZXh0Um91bmROdW1iZXIsXG4vLyAgICAgICAgIHdpbm5lcnNCcmFja2V0VGVhbXNbMF0sXG4vLyAgICAgICAgIHdpbm5lcnNCcmFja2V0VGVhbXNbMV0sXG4vLyAgICAgICAgIGZhbHNlLFxuLy8gICAgICAgICBcIndpbm5lcnNcIlxuLy8gICAgICAgKVxuLy8gICAgICk7XG5cbi8vICAgICAvLyBDb250aW51ZSB3aXRoIGxvc2VycyBicmFja2V0IG1hdGNoZXMgc2VwYXJhdGVseVxuLy8gICAgIGNyZWF0ZUxvc2Vyc0JyYWNrZXRNYXRjaGVzKCk7XG4vLyAgIH1cbi8vICAgLy8gT3RoZXJ3aXNlLCBjb250aW51ZSB3aXRoIG5vcm1hbCBicmFja2V0IHBsYXlcbi8vICAgZWxzZSB7XG4vLyAgICAgY3JlYXRlU3RhbmRhcmRCcmFja2V0TWF0Y2hlcygpO1xuLy8gICB9XG5cbi8vICAgLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGNyZWF0ZSBzdGFuZGFyZCBicmFja2V0IG1hdGNoZXNcbi8vICAgZnVuY3Rpb24gY3JlYXRlU3RhbmRhcmRCcmFja2V0TWF0Y2hlcygpIHtcbi8vICAgICAvLyAtLS0gV2lubmVycyBCcmFja2V0IE1hdGNoZXMgLS0tXG4vLyAgICAgbGV0IG1hdGNoQ291bnRlciA9IDE7XG4vLyAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB3aW5uZXJzQnJhY2tldFRlYW1zLmxlbmd0aDsgaSArPSAyKSB7XG4vLyAgICAgICBjb25zdCB0ZWFtMSA9IHdpbm5lcnNCcmFja2V0VGVhbXNbaV07XG4vLyAgICAgICBjb25zdCB0ZWFtMiA9IHdpbm5lcnNCcmFja2V0VGVhbXNbaSArIDFdID8/IG51bGw7XG4vLyAgICAgICBjb25zdCBpc0J5ZSA9ICF0ZWFtMjtcbi8vICAgICAgIG5leHRSb3VuZE1hdGNoZXMucHVzaChcbi8vICAgICAgICAgY3JlYXRlTWF0Y2goXG4vLyAgICAgICAgICAgYFcke25leHRSb3VuZE51bWJlcn0tJHttYXRjaENvdW50ZXJ9YCxcbi8vICAgICAgICAgICBuZXh0Um91bmROdW1iZXIsXG4vLyAgICAgICAgICAgdGVhbTEsXG4vLyAgICAgICAgICAgdGVhbTIsXG4vLyAgICAgICAgICAgaXNCeWUsXG4vLyAgICAgICAgICAgXCJ3aW5uZXJzXCJcbi8vICAgICAgICAgKVxuLy8gICAgICAgKTtcbi8vICAgICAgIG1hdGNoQ291bnRlcisrO1xuLy8gICAgIH1cblxuLy8gICAgIC8vIENyZWF0ZSBsb3NlcnMgYnJhY2tldCBtYXRjaGVzIHNlcGFyYXRlbHlcbi8vICAgICBjcmVhdGVMb3NlcnNCcmFja2V0TWF0Y2hlcygpO1xuLy8gICB9XG5cbi8vICAgLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGNyZWF0ZSBsb3NlcnMgYnJhY2tldCBtYXRjaGVzXG4vLyAgIGZ1bmN0aW9uIGNyZWF0ZUxvc2Vyc0JyYWNrZXRNYXRjaGVzKCkge1xuLy8gICAgIC8vIC0tLSBMb3NlcnMgQnJhY2tldCBNYXRjaGVzIC0tLVxuLy8gICAgIGNvbnN0IGVsaWdpYmxlTG9zZXJzID0gYWxsVGVhbXMuZmlsdGVyKFxuLy8gICAgICAgKHRlYW0pID0+XG4vLyAgICAgICAgIChsb3NzQ291bnRzW3RlYW0uaWRdIHx8IDApID09PSAxICYmXG4vLyAgICAgICAgICF0b3VybmFtZW50LmVsaW1pbmF0ZWRUZWFtcy5zb21lKCh0KSA9PiB0LmlkID09PSB0ZWFtLmlkKSAmJlxuLy8gICAgICAgICAhbmV3bHlFbGltaW5hdGVkLnNvbWUoKHQpID0+IHQuaWQgPT09IHRlYW0uaWQpICYmXG4vLyAgICAgICAgIC8vIEV4Y2x1ZGUgd2lubmVyJ3MgYnJhY2tldCBmaW5hbCBsb3NlciBpZiBpdCBleGlzdHMgYnV0IGhhc24ndCBwbGF5ZWQgeWV0IGluIGxvc2Vyc1xuLy8gICAgICAgICAhKFxuLy8gICAgICAgICAgIHRvdXJuYW1lbnQud2lubmVyc0JyYWNrZXRGaW5hbExvc2VyICYmXG4vLyAgICAgICAgICAgdG91cm5hbWVudC53aW5uZXJzQnJhY2tldEZpbmFsTG9zZXIuaWQgPT09IHRlYW0uaWRcbi8vICAgICAgICAgKVxuLy8gICAgICk7XG5cbi8vICAgICAvLyBGaW5kIHRlYW1zIHJlY2VudGx5IGRyb3BwZWQgZnJvbSB3aW5uZXJzIGJyYWNrZXRcbi8vICAgICBjb25zdCBqdXN0RHJvcHBlZEZyb21XaW5uZXJzID0gY3VycmVudFJvdW5kLm1hdGNoZXNcbi8vICAgICAgIC5maWx0ZXIoKG0pID0+IG0uYnJhY2tldCA9PT0gXCJ3aW5uZXJzXCIgJiYgbS5sb3NlciAmJiBtLmlzQ29tcGxldGVkKVxuLy8gICAgICAgLm1hcCgobSkgPT4gbS5sb3NlciEpXG4vLyAgICAgICAuZmlsdGVyKChsb3NlcikgPT4gZWxpZ2libGVMb3NlcnMuc29tZSgodCkgPT4gdC5pZCA9PT0gbG9zZXIuaWQpKTtcblxuLy8gICAgIC8vIElmIHRoaXMgaXMgdGhlIHdpbm5lcidzIGJyYWNrZXQgZmluYWwsIHN0b3JlIHRoZSBsb3NlciBmb3IgbGF0ZXIgdXNlXG4vLyAgICAgaWYgKFxuLy8gICAgICAgY3VycmVudFJvdW5kLm1hdGNoZXMuc29tZShcbi8vICAgICAgICAgKG0pID0+XG4vLyAgICAgICAgICAgbS5icmFja2V0ID09PSBcIndpbm5lcnNcIiAmJlxuLy8gICAgICAgICAgIHdpbm5lcnNCcmFja2V0VGVhbXMubGVuZ3RoID09PSAxICYmXG4vLyAgICAgICAgICAgbS5sb3NlciAmJlxuLy8gICAgICAgICAgIG0uaXNDb21wbGV0ZWRcbi8vICAgICAgIClcbi8vICAgICApIHtcbi8vICAgICAgIC8vIFRoaXMgaXMgYSBzcGVjaWFsIGNhc2UgLSB3ZSBmb3VuZCB0aGUgd2lubmVyJ3MgYnJhY2tldCBmaW5hbCBsb3NlclxuLy8gICAgICAgY29uc3Qgd2lubmVyc0ZpbmFsTG9zZXIgPSBjdXJyZW50Um91bmQubWF0Y2hlc1xuLy8gICAgICAgICAuZmlsdGVyKChtKSA9PiBtLmJyYWNrZXQgPT09IFwid2lubmVyc1wiICYmIG0uaXNDb21wbGV0ZWQgJiYgbS5sb3Nlcilcbi8vICAgICAgICAgLm1hcCgobSkgPT4gbS5sb3NlciEpXG4vLyAgICAgICAgIC5wb3AoKTtcblxuLy8gICAgICAgaWYgKHdpbm5lcnNGaW5hbExvc2VyKSB7XG4vLyAgICAgICAgIHRvdXJuYW1lbnQud2lubmVyc0JyYWNrZXRGaW5hbExvc2VyID0gd2lubmVyc0ZpbmFsTG9zZXI7XG4vLyAgICAgICB9XG4vLyAgICAgfVxuXG4vLyAgICAgLy8gRXhpc3RpbmcgbG9zZXJzIGJyYWNrZXQgdGVhbXNcbi8vICAgICBjb25zdCBleGlzdGluZ0xvc2VycyA9IGVsaWdpYmxlTG9zZXJzLmZpbHRlcihcbi8vICAgICAgICh0KSA9PiAhanVzdERyb3BwZWRGcm9tV2lubmVycy5zb21lKChqZCkgPT4gamQuaWQgPT09IHQuaWQpXG4vLyAgICAgKTtcblxuLy8gICAgIC8vIE9yZGVyOiBtb3N0IHJlY2VudCBkcm9wKHMpIGZpcnN0XG4vLyAgICAgY29uc3Qgb3JkZXJlZExvc2VycyA9IFsuLi5qdXN0RHJvcHBlZEZyb21XaW5uZXJzLCAuLi5leGlzdGluZ0xvc2Vyc107XG5cbi8vICAgICBpZiAob3JkZXJlZExvc2Vycy5sZW5ndGggPiAwKSB7XG4vLyAgICAgICBpZiAob3JkZXJlZExvc2Vycy5sZW5ndGggJSAyID09PSAxKSB7XG4vLyAgICAgICAgIC8vIE9kZDogYnllIGdvZXMgdG8gdGhlIG1vc3QgcmVjZW50IHRlYW0gZHJvcHBlZCBmcm9tIHdpbm5lcnMgYnJhY2tldFxuLy8gICAgICAgICBsZXQgdGVhbVdpdGhCeWU6IFRlYW0gfCBudWxsID0gbnVsbDtcbi8vICAgICAgICAgaWYgKGp1c3REcm9wcGVkRnJvbVdpbm5lcnMubGVuZ3RoID4gMCkge1xuLy8gICAgICAgICAgIHRlYW1XaXRoQnllID1cbi8vICAgICAgICAgICAgIGp1c3REcm9wcGVkRnJvbVdpbm5lcnNbanVzdERyb3BwZWRGcm9tV2lubmVycy5sZW5ndGggLSAxXTtcbi8vICAgICAgICAgICAvLyBSZW1vdmUgdGhlIGJ5ZSB0ZWFtIGZyb20gb3JkZXJlZExvc2Vyc1xuLy8gICAgICAgICAgIGNvbnN0IGJ5ZUluZGV4ID0gb3JkZXJlZExvc2Vycy5maW5kSW5kZXgoXG4vLyAgICAgICAgICAgICAodCkgPT4gdC5pZCA9PT0gdGVhbVdpdGhCeWUhLmlkXG4vLyAgICAgICAgICAgKTtcbi8vICAgICAgICAgICBpZiAoYnllSW5kZXggIT09IC0xKSBvcmRlcmVkTG9zZXJzLnNwbGljZShieWVJbmRleCwgMSk7XG4vLyAgICAgICAgIH0gZWxzZSB7XG4vLyAgICAgICAgICAgLy8gRGVmZW5zaXZlOiBmYWxsYmFjayB0byBmaXJzdCB0ZWFtIGlmIG5vIHJlY2VudCBkcm9wXG4vLyAgICAgICAgICAgdGVhbVdpdGhCeWUgPSBvcmRlcmVkTG9zZXJzLnNoaWZ0KCkhO1xuLy8gICAgICAgICB9XG4vLyAgICAgICAgIG5leHRSb3VuZE1hdGNoZXMucHVzaChcbi8vICAgICAgICAgICBjcmVhdGVNYXRjaChcbi8vICAgICAgICAgICAgIGBMJHtuZXh0Um91bmROdW1iZXJ9LTFgLFxuLy8gICAgICAgICAgICAgbmV4dFJvdW5kTnVtYmVyLFxuLy8gICAgICAgICAgICAgdGVhbVdpdGhCeWUsXG4vLyAgICAgICAgICAgICBudWxsLFxuLy8gICAgICAgICAgICAgdHJ1ZSxcbi8vICAgICAgICAgICAgIFwibG9zZXJzXCJcbi8vICAgICAgICAgICApXG4vLyAgICAgICAgICk7XG4vLyAgICAgICAgIC8vIFBhaXIgdGhlIHJlc3Rcbi8vICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvcmRlcmVkTG9zZXJzLmxlbmd0aDsgaSArPSAyKSB7XG4vLyAgICAgICAgICAgY29uc3QgdGVhbTEgPSBvcmRlcmVkTG9zZXJzW2ldO1xuLy8gICAgICAgICAgIGNvbnN0IHRlYW0yID0gb3JkZXJlZExvc2Vyc1tpICsgMV0gPz8gbnVsbDtcbi8vICAgICAgICAgICBuZXh0Um91bmRNYXRjaGVzLnB1c2goXG4vLyAgICAgICAgICAgICBjcmVhdGVNYXRjaChcbi8vICAgICAgICAgICAgICAgYEwke25leHRSb3VuZE51bWJlcn0tJHtNYXRoLmZsb29yKGkgLyAyKSArIDJ9YCxcbi8vICAgICAgICAgICAgICAgbmV4dFJvdW5kTnVtYmVyLFxuLy8gICAgICAgICAgICAgICB0ZWFtMSxcbi8vICAgICAgICAgICAgICAgdGVhbTIsXG4vLyAgICAgICAgICAgICAgICF0ZWFtMixcbi8vICAgICAgICAgICAgICAgXCJsb3NlcnNcIlxuLy8gICAgICAgICAgICAgKVxuLy8gICAgICAgICAgICk7XG4vLyAgICAgICAgIH1cbi8vICAgICAgIH0gZWxzZSB7XG4vLyAgICAgICAgIC8vIEV2ZW4gbnVtYmVyOiBwYWlyIGFsbFxuLy8gICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9yZGVyZWRMb3NlcnMubGVuZ3RoOyBpICs9IDIpIHtcbi8vICAgICAgICAgICBjb25zdCB0ZWFtMSA9IG9yZGVyZWRMb3NlcnNbaV07XG4vLyAgICAgICAgICAgY29uc3QgdGVhbTIgPSBvcmRlcmVkTG9zZXJzW2kgKyAxXSA/PyBudWxsO1xuLy8gICAgICAgICAgIG5leHRSb3VuZE1hdGNoZXMucHVzaChcbi8vICAgICAgICAgICAgIGNyZWF0ZU1hdGNoKFxuLy8gICAgICAgICAgICAgICBgTCR7bmV4dFJvdW5kTnVtYmVyfS0ke01hdGguZmxvb3IoaSAvIDIpICsgMX1gLFxuLy8gICAgICAgICAgICAgICBuZXh0Um91bmROdW1iZXIsXG4vLyAgICAgICAgICAgICAgIHRlYW0xLFxuLy8gICAgICAgICAgICAgICB0ZWFtMixcbi8vICAgICAgICAgICAgICAgIXRlYW0yLFxuLy8gICAgICAgICAgICAgICBcImxvc2Vyc1wiXG4vLyAgICAgICAgICAgICApXG4vLyAgICAgICAgICAgKTtcbi8vICAgICAgICAgfVxuLy8gICAgICAgfVxuLy8gICAgIH1cbi8vICAgfVxuXG4vLyAgIC8vIC0tLSBXaW5uZXIgZGV0ZWN0aW9uIGxvZ2ljIC0tLVxuLy8gICBsZXQgd2lubmVyOiBUZWFtIHwgdW5kZWZpbmVkID0gdG91cm5hbWVudC53aW5uZXI7XG5cbi8vICAgaWYgKGlzQ2hhbXBpb25zaGlwUm91bmQpIHtcbi8vICAgICAvLyBGaW5kIHRoZSBsYXN0IGNoYW1waW9uc2hpcCBtYXRjaCBwbGF5ZWRcbi8vICAgICBjb25zdCBsYXN0Q2hhbXBNYXRjaCA9XG4vLyAgICAgICBjaGFtcGlvbnNoaXBNYXRjaGVzWzBdIHx8XG4vLyAgICAgICBwcmV2Q2hhbXBpb25zaGlwTWF0Y2hlc1twcmV2Q2hhbXBpb25zaGlwTWF0Y2hlcy5sZW5ndGggLSAxXTtcblxuLy8gICAgIGlmIChcbi8vICAgICAgIGxhc3RDaGFtcE1hdGNoICYmXG4vLyAgICAgICBsYXN0Q2hhbXBNYXRjaC5pc0NvbXBsZXRlZCAmJlxuLy8gICAgICAgbGFzdENoYW1wTWF0Y2gud2lubmVyICYmXG4vLyAgICAgICBsYXN0Q2hhbXBNYXRjaC5sb3NlclxuLy8gICAgICkge1xuLy8gICAgICAgY29uc3Qgd2lubmVyc0JyYWNrZXRUZWFtID0gbGFzdENoYW1wTWF0Y2gudGVhbTE7XG4vLyAgICAgICBjb25zdCBsb3NlcnNCcmFja2V0VGVhbSA9IGxhc3RDaGFtcE1hdGNoLnRlYW0yO1xuLy8gICAgICAgY29uc3QgbG9zZXJzQnJhY2tldFRlYW1Xb24gPVxuLy8gICAgICAgICBsYXN0Q2hhbXBNYXRjaC53aW5uZXIuaWQgPT09IGxvc2Vyc0JyYWNrZXRUZWFtLmlkO1xuXG4vLyAgICAgICAvLyBJZiBsb3NlcidzIGJyYWNrZXQgdGVhbSB3b24gZmlyc3QgY2hhbXBpb25zaGlwIG1hdGNoLCB3aW5uZXIncyBicmFja2V0IHRlYW0gZ2V0cyBhbm90aGVyIGNoYW5jZVxuLy8gICAgICAgaWYgKGxvc2Vyc0JyYWNrZXRUZWFtV29uICYmIHRvdXJuYW1lbnQuY2hhbXBpb25zaGlwTWF0Y2hlc1BsYXllZCA9PT0gMSkge1xuLy8gICAgICAgICB3aW5uZXIgPSB1bmRlZmluZWQ7IC8vIE5vIHdpbm5lciB5ZXQsIG5lZWQgcmVzZXQgbWF0Y2hcbi8vICAgICAgIH0gZWxzZSB7XG4vLyAgICAgICAgIC8vIEVpdGhlciB3aW5uZXIncyBicmFja2V0IHRlYW0gd29uIGZpcnN0IG1hdGNoLCBvciB0aGlzIHdhcyB0aGUgcmVzZXQgbWF0Y2hcbi8vICAgICAgICAgd2lubmVyID0gbGFzdENoYW1wTWF0Y2gud2lubmVyO1xuLy8gICAgICAgfVxuLy8gICAgIH1cbi8vICAgfVxuXG4vLyAgIC8vIC0tLSBJTkZJTklURSBSRUNVUlNJT04gR1VBUkQgLS0tXG4vLyAgIGNvbnN0IG5vTW9yZU1hdGNoZXMgPVxuLy8gICAgIChpc0NoYW1waW9uc2hpcFJvdW5kICYmIGNoYW1waW9uc2hpcE1hdGNoZXMubGVuZ3RoID09PSAwKSB8fFxuLy8gICAgICghaXNDaGFtcGlvbnNoaXBSb3VuZCAmJiBuZXh0Um91bmRNYXRjaGVzLmxlbmd0aCA9PT0gMCk7XG5cbi8vICAgaWYgKG5vTW9yZU1hdGNoZXMpIHtcbi8vICAgICAvLyBUb3VybmFtZW50IGlzIG92ZXIsIGRvIG5vdCBhZHZhbmNlIGZ1cnRoZXJcbi8vICAgICByZXR1cm4ge1xuLy8gICAgICAgLi4udG91cm5hbWVudCxcbi8vICAgICAgIHdpbm5lcixcbi8vICAgICAgIGN1cnJlbnRSb3VuZDogdG91cm5hbWVudC5jdXJyZW50Um91bmRcbi8vICAgICB9O1xuLy8gICB9XG5cbi8vICAgLy8gQ29tcG9zZSB0aGUgbmV3IHRvdXJuYW1lbnQgb2JqZWN0XG4gIFxuLy8gICByZXR1cm4ge1xuLy8gICAgIC4uLnRvdXJuYW1lbnQsXG4vLyAgICAgcm91bmRzOiBbXG4vLyAgICAgICAuLi50b3VybmFtZW50LnJvdW5kcyxcbi8vICAgICAgIHtcbi8vICAgICAgICAgcm91bmROdW1iZXI6IG5leHRSb3VuZE51bWJlcixcbi8vICAgICAgICAgbWF0Y2hlczogaXNDaGFtcGlvbnNoaXBSb3VuZCA/IGNoYW1waW9uc2hpcE1hdGNoZXMgOiBuZXh0Um91bmRNYXRjaGVzLFxuLy8gICAgICAgICBpc0RvdWJsZUVsaW1pbmF0aW9uOiB0cnVlLFxuLy8gICAgICAgICBpc0NoYW1waW9uc2hpcFJvdW5kXG4vLyAgICAgICB9XG4vLyAgICAgXSxcbi8vICAgICBjdXJyZW50Um91bmQ6IG5leHRSb3VuZE51bWJlcixcbi8vICAgICBlbGltaW5hdGVkVGVhbXM6IFtcbi8vICAgICAgIC4uLnRvdXJuYW1lbnQuZWxpbWluYXRlZFRlYW1zLFxuLy8gICAgICAgLi4ubmV3bHlFbGltaW5hdGVkLmZpbHRlcihcbi8vICAgICAgICAgKHQpID0+ICF0b3VybmFtZW50LmVsaW1pbmF0ZWRUZWFtcy5zb21lKChldCkgPT4gZXQuaWQgPT09IHQuaWQpXG4vLyAgICAgICApXG4vLyAgICAgXSxcbi8vICAgICBjaGFtcGlvbnNoaXBNYXRjaGVzUGxheWVkOiBpc0NoYW1waW9uc2hpcFJvdW5kXG4vLyAgICAgICA/IHRvdXJuYW1lbnQuY2hhbXBpb25zaGlwTWF0Y2hlc1BsYXllZCArIDFcbi8vICAgICAgIDogdG91cm5hbWVudC5jaGFtcGlvbnNoaXBNYXRjaGVzUGxheWVkLFxuLy8gICAgIHdpbm5lcnNCcmFja2V0RmluYWxMb3NlcjogdG91cm5hbWVudC53aW5uZXJzQnJhY2tldEZpbmFsTG9zZXIsXG4vLyAgICAgd2lubmVyXG4vLyAgIH07XG4vLyB9O1xuXG5cblxuLy8gaW1wb3J0IHR5cGUgeyBUZWFtIH0gZnJvbSBcIi4vbWxiLXRlYW1zXCI7XG5cbi8vIGV4cG9ydCBpbnRlcmZhY2UgTWF0Y2gge1xuLy8gICBpZDogc3RyaW5nO1xuLy8gICByb3VuZE51bWJlcjogbnVtYmVyO1xuLy8gICB0ZWFtMTogVGVhbSB8IG51bGw7XG4vLyAgIHRlYW0yOiBUZWFtIHwgbnVsbDtcbi8vICAgaXNDb21wbGV0ZWQ6IGJvb2xlYW47XG4vLyAgIGlzQnllPzogYm9vbGVhbjtcbi8vICAgd2lubmVyPzogVGVhbTtcbi8vICAgbG9zZXI/OiBUZWFtO1xuLy8gICBicmFja2V0OiBcIndpbm5lcnNcIiB8IFwibG9zZXJzXCIgfCBcImNoYW1waW9uc2hpcFwiO1xuLy8gICBzY29yZTogeyB0ZWFtMVNjb3JlOiBudW1iZXI7IHRlYW0yU2NvcmU6IG51bWJlciB9O1xuLy8gICBuZXh0TWF0Y2hJZD86IHN0cmluZztcbi8vICAgbmV4dExvc2VyTWF0Y2hJZD86IHN0cmluZztcbi8vICAgZWxpbWluYXRlZExhYmVsPzogc3RyaW5nOyAvLyBsYWJlbCBmb3IgZWxpbWluYXRlZCB0ZWFtcyBpbiBsb3NlcnMgYnJhY2tldFxuLy8gICByZXF1aXJlc1JlbWF0Y2g/OiBib29sZWFuOyAvLyBpbmRpY2F0ZXMgaWYgYSBjaGFtcGlvbnNoaXAgcmVtYXRjaCBpcyByZXF1aXJlZFxuLy8gfVxuXG4vLyBleHBvcnQgaW50ZXJmYWNlIFJvdW5kIHtcbi8vICAgcm91bmROdW1iZXI6IG51bWJlcjtcbi8vICAgbWF0Y2hlczogTWF0Y2hbXTtcbi8vICAgaXNEb3VibGVFbGltaW5hdGlvbjogYm9vbGVhbjtcbi8vICAgaXNDaGFtcGlvbnNoaXBSb3VuZDogYm9vbGVhbjtcbi8vIH1cblxuLy8gZXhwb3J0IGludGVyZmFjZSBUb3VybmFtZW50IHtcbi8vICAgcm91bmRzOiBSb3VuZFtdO1xuLy8gICBjdXJyZW50Um91bmQ6IG51bWJlcjtcbi8vICAgZWxpbWluYXRlZFRlYW1zOiBUZWFtW107XG4vLyAgIGNoYW1waW9uc2hpcE1hdGNoZXNQbGF5ZWQ6IG51bWJlcjtcbi8vICAgd2lubmVyPzogVGVhbTtcbi8vICAgd2lubmVyc0JyYWNrZXRGaW5hbExvc2VyPzogVGVhbTsgLy8gdHJhY2tzIHRoZSB3aW5uZXIncyBicmFja2V0IGZpbmFsIGxvc2VyIGZvciBjaGFtcGlvbnNoaXAgcmVtYXRjaCBsb2dpY1xuLy8gfVxuXG4vLyBleHBvcnQgY29uc3QgY3JlYXRlTWF0Y2ggPSAoXG4vLyAgIGlkOiBzdHJpbmcsXG4vLyAgIHJvdW5kTnVtYmVyOiBudW1iZXIsXG4vLyAgIHRlYW0xOiBUZWFtIHwgbnVsbCxcbi8vICAgdGVhbTI6IFRlYW0gfCBudWxsLFxuLy8gICBpc0J5ZTogYm9vbGVhbiA9IGZhbHNlLFxuLy8gICBicmFja2V0OiBcIndpbm5lcnNcIiB8IFwibG9zZXJzXCIgfCBcImNoYW1waW9uc2hpcFwiID0gXCJ3aW5uZXJzXCIsXG4vLyAgIG5leHRNYXRjaElkPzogc3RyaW5nLFxuLy8gICBuZXh0TG9zZXJNYXRjaElkPzogc3RyaW5nXG4vLyApOiBNYXRjaCA9PiAoe1xuLy8gICBpZCxcbi8vICAgcm91bmROdW1iZXIsXG4vLyAgIHRlYW0xLFxuLy8gICB0ZWFtMixcbi8vICAgaXNDb21wbGV0ZWQ6IGlzQnllLFxuLy8gICBpc0J5ZSxcbi8vICAgYnJhY2tldCxcbi8vICAgd2lubmVyOiBpc0J5ZSA/ICh0ZWFtMSA/PyB0ZWFtMiA/PyB1bmRlZmluZWQpIDogdW5kZWZpbmVkLFxuLy8gICBsb3NlcjogaXNCeWUgPyB1bmRlZmluZWQgOiB1bmRlZmluZWQsXG4vLyAgIHNjb3JlOiB7IHRlYW0xU2NvcmU6IDAsIHRlYW0yU2NvcmU6IDAgfSxcbi8vICAgbmV4dE1hdGNoSWQsXG4vLyAgIG5leHRMb3Nlck1hdGNoSWQsXG4vLyAgIGVsaW1pbmF0ZWRMYWJlbDogdW5kZWZpbmVkXG4vLyB9KTtcblxuLy8gZXhwb3J0IGNvbnN0IGNyZWF0ZUluaXRpYWxSb3VuZHMgPSAodGVhbXM6IFRlYW1bXSk6IFRvdXJuYW1lbnQgPT4ge1xuLy8gICBjb25zdCBudW1UZWFtcyA9IHRlYW1zLmxlbmd0aDtcbi8vICAgY29uc3QgbWF0Y2hlczogTWF0Y2hbXSA9IFtdO1xuLy8gICBjb25zdCBudW1Sb3VuZHMgPSBNYXRoLmNlaWwoTWF0aC5sb2cyKG51bVRlYW1zKSk7XG5cbi8vICAgY29uc3QgZmlyc3RSb3VuZE1hdGNoZXMgPSBNYXRoLnBvdygyLCBudW1Sb3VuZHMgLSAxKTtcbi8vICAgbGV0IG1hdGNoQ291bnRlciA9IDE7XG5cbi8vICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmaXJzdFJvdW5kTWF0Y2hlczsgaSsrKSB7XG4vLyAgICAgY29uc3QgdGVhbTEgPSB0ZWFtc1tpICogMl0gfHwgbnVsbDtcbi8vICAgICBjb25zdCB0ZWFtMiA9IHRlYW1zW2kgKiAyICsgMV0gfHwgbnVsbDtcbi8vICAgICBjb25zdCBpc0J5ZSA9ICF0ZWFtMSB8fCAhdGVhbTI7XG5cbi8vICAgICBjb25zdCBtYXRjaElkID0gYFcxLSR7bWF0Y2hDb3VudGVyfWA7XG4vLyAgICAgY29uc3QgbmV4dE1hdGNoSWQgPSBgVzItJHtNYXRoLmNlaWwobWF0Y2hDb3VudGVyIC8gMil9YDtcbi8vICAgICBjb25zdCBuZXh0TG9zZXJNYXRjaElkID0gYEwxLSR7TWF0aC5jZWlsKG1hdGNoQ291bnRlciAvIDIpfWA7XG5cbi8vICAgICBtYXRjaGVzLnB1c2goXG4vLyAgICAgICBjcmVhdGVNYXRjaChcbi8vICAgICAgICAgbWF0Y2hJZCxcbi8vICAgICAgICAgMSxcbi8vICAgICAgICAgdGVhbTEsXG4vLyAgICAgICAgIHRlYW0yLFxuLy8gICAgICAgICBpc0J5ZSxcbi8vICAgICAgICAgXCJ3aW5uZXJzXCIsXG4vLyAgICAgICAgIG5leHRNYXRjaElkLFxuLy8gICAgICAgICBuZXh0TG9zZXJNYXRjaElkXG4vLyAgICAgICApXG4vLyAgICAgKTtcbi8vICAgICBtYXRjaENvdW50ZXIrKztcbi8vICAgfVxuXG4vLyAgIHJldHVybiB7XG4vLyAgICAgcm91bmRzOiBbXG4vLyAgICAgICB7XG4vLyAgICAgICAgIHJvdW5kTnVtYmVyOiAxLFxuLy8gICAgICAgICBtYXRjaGVzLFxuLy8gICAgICAgICBpc0RvdWJsZUVsaW1pbmF0aW9uOiB0cnVlLFxuLy8gICAgICAgICBpc0NoYW1waW9uc2hpcFJvdW5kOiBmYWxzZVxuLy8gICAgICAgfVxuLy8gICAgIF0sXG4vLyAgICAgY3VycmVudFJvdW5kOiAxLFxuLy8gICAgIGVsaW1pbmF0ZWRUZWFtczogW10sXG4vLyAgICAgY2hhbXBpb25zaGlwTWF0Y2hlc1BsYXllZDogMFxuLy8gICB9O1xuLy8gfTtcblxuLy8gZXhwb3J0IGNvbnN0IHVwZGF0ZU1hdGNoU2NvcmUgPSAoXG4vLyAgIG1hdGNoOiBNYXRjaCxcbi8vICAgbmV3U2NvcmU6IHsgdGVhbTFTY29yZTogbnVtYmVyOyB0ZWFtMlNjb3JlOiBudW1iZXIgfVxuLy8gKTogTWF0Y2ggPT4ge1xuLy8gICAvLyBNYXJrIG1hdGNoIGFzIGNvbXBsZXRlZCBpZiBib3RoIHRlYW1zIGhhdmUgYSBzY29yZSBlbnRlcmVkIChldmVuIGlmIHNjb3JlcyBhcmUgZXF1YWwpXG4vLyAgIGNvbnN0IGlzQ29tcGxldGVkID1cbi8vICAgICB0eXBlb2YgbmV3U2NvcmUudGVhbTFTY29yZSA9PT0gXCJudW1iZXJcIiAmJlxuLy8gICAgIHR5cGVvZiBuZXdTY29yZS50ZWFtMlNjb3JlID09PSBcIm51bWJlclwiICYmXG4vLyAgICAgKCFpc05hTihuZXdTY29yZS50ZWFtMVNjb3JlKSAmJiAhaXNOYU4obmV3U2NvcmUudGVhbTJTY29yZSkpO1xuLy8gICBsZXQgd2lubmVyOiBUZWFtIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuLy8gICBsZXQgbG9zZXI6IFRlYW0gfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG4vLyAgIGlmIChpc0NvbXBsZXRlZCkge1xuLy8gICAgIGlmIChuZXdTY29yZS50ZWFtMVNjb3JlID4gbmV3U2NvcmUudGVhbTJTY29yZSkge1xuLy8gICAgICAgd2lubmVyID0gbWF0Y2gudGVhbTEgPyB7IC4uLm1hdGNoLnRlYW0xLCB3aW5zOiAobWF0Y2gudGVhbTEud2lucyA/PyAwKSArIDEsIGxvc3NlczogbWF0Y2gudGVhbTEubG9zc2VzID8/IDAgfSA6IHVuZGVmaW5lZDtcbi8vICAgICAgIGxvc2VyID0gbWF0Y2gudGVhbTIgPyB7IC4uLm1hdGNoLnRlYW0yLCB3aW5zOiBtYXRjaC50ZWFtMi53aW5zID8/IDAsIGxvc3NlczogKG1hdGNoLnRlYW0yLmxvc3NlcyA/PyAwKSArIDEgfSA6IHVuZGVmaW5lZDtcbi8vICAgICB9IGVsc2Uge1xuLy8gICAgICAgd2lubmVyID0gbWF0Y2gudGVhbTIgPyB7IC4uLm1hdGNoLnRlYW0yLCB3aW5zOiAobWF0Y2gudGVhbTIud2lucyA/PyAwKSArIDEsIGxvc3NlczogbWF0Y2gudGVhbTIubG9zc2VzID8/IDAgfSA6IHVuZGVmaW5lZDtcbi8vICAgICAgIGxvc2VyID0gbWF0Y2gudGVhbTEgPyB7IC4uLm1hdGNoLnRlYW0xLCB3aW5zOiBtYXRjaC50ZWFtMS53aW5zID8/IDAsIGxvc3NlczogKG1hdGNoLnRlYW0xLmxvc3NlcyA/PyAwKSArIDEgfSA6IHVuZGVmaW5lZDtcbi8vICAgICB9XG4vLyAgIH1cbi8vICAgcmV0dXJuIHtcbi8vICAgICAuLi5tYXRjaCxcbi8vICAgICBzY29yZTogbmV3U2NvcmUsXG4vLyAgICAgaXNDb21wbGV0ZWQsXG4vLyAgICAgd2lubmVyLFxuLy8gICAgIGxvc2VyXG4vLyAgIH07XG4vLyB9O1xuXG4vLyAvLyBIZWxwZXIgdG8gZGVkdXBsaWNhdGUgdGVhbXMgYnkgSURcbi8vIGZ1bmN0aW9uIGRlZHVwZVRlYW1zKHRlYW1zOiBUZWFtW10pOiBUZWFtW10ge1xuLy8gICBjb25zdCBzZWVuID0gbmV3IFNldDxzdHJpbmc+KCk7XG4vLyAgIHJldHVybiB0ZWFtcy5maWx0ZXIodGVhbSA9PiB7XG4vLyAgICAgaWYgKCF0ZWFtKSByZXR1cm4gZmFsc2U7XG4vLyAgICAgaWYgKHNlZW4uaGFzKHRlYW0uaWQpKSByZXR1cm4gZmFsc2U7XG4vLyAgICAgc2Vlbi5hZGQodGVhbS5pZCk7XG4vLyAgICAgcmV0dXJuIHRydWU7XG4vLyAgIH0pO1xuLy8gfVxuXG4vLyAvLyBIZWxwZXI6IGdldCBhbGwgdGVhbXMgd2l0aCBleGFjdGx5IE4gbG9zc2VzXG4vLyBmdW5jdGlvbiB0ZWFtc1dpdGhMb3NzZXMobG9zc0NvdW50czogUmVjb3JkPHN0cmluZywgbnVtYmVyPiwgbjogbnVtYmVyKTogc3RyaW5nW10ge1xuLy8gICByZXR1cm4gT2JqZWN0LmtleXMobG9zc0NvdW50cykuZmlsdGVyKHRlYW1JZCA9PiBsb3NzQ291bnRzW3RlYW1JZF0gPT09IG4pO1xuLy8gfVxuXG4vLyBleHBvcnQgY29uc3QgYWR2YW5jZVRvTmV4dFJvdW5kID0gKHRvdXJuYW1lbnQ6IFRvdXJuYW1lbnQpOiBUb3VybmFtZW50ID0+IHtcbi8vICAgY29uc3QgY3VycmVudFJvdW5kID0gdG91cm5hbWVudC5yb3VuZHNbdG91cm5hbWVudC5yb3VuZHMubGVuZ3RoIC0gMV07XG4vLyAgIGNvbnN0IG5leHRSb3VuZE51bWJlciA9IHRvdXJuYW1lbnQuY3VycmVudFJvdW5kICsgMTtcblxuLy8gICAvLyBUcmFjayBhbGwgbG9zc2VzIGFuZCB3aW5zIGFjcm9zcyB0aGUgdG91cm5hbWVudFxuLy8gICBjb25zdCBsb3NzQ291bnRzOiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+ID0ge307XG4vLyAgIGNvbnN0IHdpbnNDb3VudHM6IFJlY29yZDxzdHJpbmcsIG51bWJlcj4gPSB7fTtcbi8vICAgdG91cm5hbWVudC5yb3VuZHMuZm9yRWFjaCgocm91bmQpID0+IHtcbi8vICAgICByb3VuZC5tYXRjaGVzLmZvckVhY2goKG1hdGNoKSA9PiB7XG4vLyAgICAgICBpZiAobWF0Y2guaXNDb21wbGV0ZWQgJiYgbWF0Y2gubG9zZXIpIHtcbi8vICAgICAgICAgbG9zc0NvdW50c1ttYXRjaC5sb3Nlci5pZF0gPSAobG9zc0NvdW50c1ttYXRjaC5sb3Nlci5pZF0gfHwgMCkgKyAxO1xuLy8gICAgICAgfVxuLy8gICAgICAgaWYgKG1hdGNoLmlzQ29tcGxldGVkICYmIG1hdGNoLndpbm5lcikge1xuLy8gICAgICAgICB3aW5zQ291bnRzW21hdGNoLndpbm5lci5pZF0gPSAod2luc0NvdW50c1ttYXRjaC53aW5uZXIuaWRdIHx8IDApICsgMTtcbi8vICAgICAgIH1cbi8vICAgICB9KTtcbi8vICAgfSk7XG5cbi8vICAgLy8gR2F0aGVyIGFsbCB0ZWFtcyBldmVyIGluIHRoZSB0b3VybmFtZW50LCBhdHRhY2hpbmcgd2luc1xuLy8gICBjb25zdCBhbGxUZWFtczogVGVhbVtdID0gW107XG4vLyAgIGNvbnN0IHRlYW1JZHMgPSBuZXcgU2V0PHN0cmluZz4oKTtcbi8vICAgZm9yIChjb25zdCByb3VuZCBvZiB0b3VybmFtZW50LnJvdW5kcykge1xuLy8gICAgIGZvciAoY29uc3QgbWF0Y2ggb2Ygcm91bmQubWF0Y2hlcykge1xuLy8gICAgICAgaWYgKG1hdGNoLnRlYW0xICYmICF0ZWFtSWRzLmhhcyhtYXRjaC50ZWFtMS5pZCkpIHtcbi8vICAgICAgICAgYWxsVGVhbXMucHVzaCh7XG4vLyAgICAgICAgICAgLi4ubWF0Y2gudGVhbTEsXG4vLyAgICAgICAgICAgd2luczogd2luc0NvdW50c1ttYXRjaC50ZWFtMS5pZF0gfHwgMCxcbi8vICAgICAgICAgICBsb3NzZXM6IGxvc3NDb3VudHNbbWF0Y2gudGVhbTEuaWRdIHx8IDBcbi8vICAgICAgICAgfSk7XG4vLyAgICAgICAgIHRlYW1JZHMuYWRkKG1hdGNoLnRlYW0xLmlkKTtcbi8vICAgICAgIH1cbi8vICAgICAgIGlmIChtYXRjaC50ZWFtMiAmJiAhdGVhbUlkcy5oYXMobWF0Y2gudGVhbTIuaWQpKSB7XG4vLyAgICAgICAgIGFsbFRlYW1zLnB1c2goe1xuLy8gICAgICAgICAgIC4uLm1hdGNoLnRlYW0yLFxuLy8gICAgICAgICAgIHdpbnM6IHdpbnNDb3VudHNbbWF0Y2gudGVhbTIuaWRdIHx8IDAsXG4vLyAgICAgICAgICAgbG9zc2VzOiBsb3NzQ291bnRzW21hdGNoLnRlYW0yLmlkXSB8fCAwXG4vLyAgICAgICAgIH0pO1xuLy8gICAgICAgICB0ZWFtSWRzLmFkZChtYXRjaC50ZWFtMi5pZCk7XG4vLyAgICAgICB9XG4vLyAgICAgfVxuLy8gICB9XG5cbi8vICAgLy8gSWRlbnRpZnkgbmV3bHkgZWxpbWluYXRlZCB0ZWFtcyAoMiBsb3NzZXMpXG4vLyAgIGNvbnN0IG5ld2x5RWxpbWluYXRlZDogVGVhbVtdID0gW107XG4vLyAgIGZvciAoY29uc3QgdGVhbSBvZiBhbGxUZWFtcykge1xuLy8gICAgIGlmIChcbi8vICAgICAgIChsb3NzQ291bnRzW3RlYW0uaWRdIHx8IDApID49IDIgJiZcbi8vICAgICAgICF0b3VybmFtZW50LmVsaW1pbmF0ZWRUZWFtcy5zb21lKCh0KSA9PiB0LmlkID09PSB0ZWFtLmlkKVxuLy8gICAgICkge1xuLy8gICAgICAgbmV3bHlFbGltaW5hdGVkLnB1c2godGVhbSk7XG4vLyAgICAgfVxuLy8gICB9XG5cbi8vICAgLy8gV2lubmVyczogdGVhbXMgd2l0aCAwIGxvc3NlcyBhbmQgbm90IGVsaW1pbmF0ZWRcbi8vICAgY29uc3Qgd2lubmVyc0JyYWNrZXRUZWFtcyA9IGFsbFRlYW1zXG4vLyAgICAgLmZpbHRlcihcbi8vICAgICAgICh0ZWFtKSA9PlxuLy8gICAgICAgICAobG9zc0NvdW50c1t0ZWFtLmlkXSB8fCAwKSA9PT0gMCAmJlxuLy8gICAgICAgICAhdG91cm5hbWVudC5lbGltaW5hdGVkVGVhbXMuc29tZSgodCkgPT4gdC5pZCA9PT0gdGVhbS5pZCkgJiZcbi8vICAgICAgICAgIW5ld2x5RWxpbWluYXRlZC5zb21lKCh0KSA9PiB0LmlkID09PSB0ZWFtLmlkKSAmJlxuLy8gICAgICAgICAhdGVhbS5pZC5zdGFydHNXaXRoKCd0YmQtJykgLy8gRXhjbHVkZSBhbnkgcGhhbnRvbSBUQkQgdGVhbXNcbi8vICAgICApXG4vLyAgICAgLm1hcCgodGVhbSkgPT4gKHsgLi4udGVhbSwgbG9zc2VzOiBsb3NzQ291bnRzW3RlYW0uaWRdIHx8IDAsIHdpbnM6IHdpbnNDb3VudHNbdGVhbS5pZF0gfHwgMCB9KSk7XG4vLyAgIC8vIExvc2VyczogdGVhbXMgd2l0aCAxIGxvc3MgYW5kIG5vdCBlbGltaW5hdGVkXG4vLyAgIGNvbnN0IGxvc2Vyc0JyYWNrZXRUZWFtcyA9IGFsbFRlYW1zXG4vLyAgICAgLmZpbHRlcihcbi8vICAgICAgICh0ZWFtKSA9PlxuLy8gICAgICAgICAobG9zc0NvdW50c1t0ZWFtLmlkXSB8fCAwKSA9PT0gMSAmJlxuLy8gICAgICAgICAhdG91cm5hbWVudC5lbGltaW5hdGVkVGVhbXMuc29tZSgodCkgPT4gdC5pZCA9PT0gdGVhbS5pZCkgJiZcbi8vICAgICAgICAgIW5ld2x5RWxpbWluYXRlZC5zb21lKCh0KSA9PiB0LmlkID09PSB0ZWFtLmlkKVxuLy8gICAgIClcbi8vICAgICAubWFwKCh0ZWFtKSA9PiAoe1xuLy8gICAgICAgLi4udGVhbSxcbi8vICAgICAgIGxvc3NlczogbG9zc0NvdW50c1t0ZWFtLmlkXSB8fCAwLFxuLy8gICAgICAgd2luczogd2luc0NvdW50c1t0ZWFtLmlkXSB8fCAwXG4vLyAgICAgfSkpO1xuXG4vLyAgIGxldCBpc0NoYW1waW9uc2hpcFJvdW5kID0gZmFsc2U7XG4vLyAgIGxldCBjaGFtcGlvbnNoaXBNYXRjaGVzOiBNYXRjaFtdID0gW107XG4vLyAgIGxldCBuZXh0Um91bmRNYXRjaGVzOiBNYXRjaFtdID0gW107XG5cbi8vICAgY29uc3QgcHJldkNoYW1waW9uc2hpcE1hdGNoZXMgPSB0b3VybmFtZW50LnJvdW5kc1xuLy8gICAgIC5maWx0ZXIoKHIpID0+IHIuaXNDaGFtcGlvbnNoaXBSb3VuZClcbi8vICAgICAuZmxhdE1hcCgocikgPT4gci5tYXRjaGVzKVxuLy8gICAgIC5maWx0ZXIoKG0pID0+IG0uYnJhY2tldCA9PT0gXCJjaGFtcGlvbnNoaXBcIik7XG5cbi8vICAgLy8gLS0tIENIQU1QSU9OU0hJUCBMT0dJQyAtLS1cblxuLy8gICAvLyBDaGVjayBpZiBhIGNoYW1waW9uc2hpcCBtYXRjaCBhbHJlYWR5IGhhcHBlbmVkIGFuZCB3YXMgY29tcGxldGVkXG4vLyAgIGlmIChcbi8vICAgICBwcmV2Q2hhbXBpb25zaGlwTWF0Y2hlcy5sZW5ndGggPj0gMSAmJlxuLy8gICAgIHByZXZDaGFtcGlvbnNoaXBNYXRjaGVzW3ByZXZDaGFtcGlvbnNoaXBNYXRjaGVzLmxlbmd0aCAtIDFdLmlzQ29tcGxldGVkXG4vLyAgICkge1xuLy8gICAgIGNvbnN0IGxhc3RDaGFtcE1hdGNoID1cbi8vICAgICAgIHByZXZDaGFtcGlvbnNoaXBNYXRjaGVzW3ByZXZDaGFtcGlvbnNoaXBNYXRjaGVzLmxlbmd0aCAtIDFdO1xuLy8gICAgIGNvbnN0IHdpbm5lcnNCcmFja2V0VGVhbSA9IGxhc3RDaGFtcE1hdGNoLnRlYW0xO1xuLy8gICAgIGNvbnN0IGxvc2Vyc0JyYWNrZXRUZWFtID0gbGFzdENoYW1wTWF0Y2gudGVhbTI7XG5cbi8vICAgICAvLyBJZiBsb3NlcidzIGJyYWNrZXQgdGVhbSB3b24gdGhlIGZpcnN0IGNoYW1waW9uc2hpcCBtYXRjaCwgd2lubmVyJ3MgYnJhY2tldCB0ZWFtIGdldHMgYW5vdGhlciBjaGFuY2Vcbi8vICAgICBpZiAoXG4vLyAgICAgICBsYXN0Q2hhbXBNYXRjaC53aW5uZXI/LmlkID09PSBsb3NlcnNCcmFja2V0VGVhbT8uaWQgJiZcbi8vICAgICAgIHRvdXJuYW1lbnQuY2hhbXBpb25zaGlwTWF0Y2hlc1BsYXllZCA9PT0gMVxuLy8gICAgICkge1xuLy8gICAgICAgaXNDaGFtcGlvbnNoaXBSb3VuZCA9IHRydWU7XG4vLyAgICAgICAvLyBDcmVhdGUgdGhlIFwicmVzZXRcIiBtYXRjaCB3aXRoIHJlcXVpcmVzUmVtYXRjaDogdHJ1ZVxuLy8gICAgICAgY2hhbXBpb25zaGlwTWF0Y2hlcy5wdXNoKHtcbi8vICAgICAgICAgLi4uY3JlYXRlTWF0Y2goXG4vLyAgICAgICAgICAgYEMke25leHRSb3VuZE51bWJlcn0tMWAsXG4vLyAgICAgICAgICAgbmV4dFJvdW5kTnVtYmVyLFxuLy8gICAgICAgICAgIHdpbm5lcnNCcmFja2V0VGVhbSxcbi8vICAgICAgICAgICBsb3NlcnNCcmFja2V0VGVhbSxcbi8vICAgICAgICAgICBmYWxzZSxcbi8vICAgICAgICAgICBcImNoYW1waW9uc2hpcFwiXG4vLyAgICAgICAgICksXG4vLyAgICAgICAgIHJlcXVpcmVzUmVtYXRjaDogdHJ1ZVxuLy8gICAgICAgfSk7XG5cbi8vICAgICAgIC8vIEluY3JlbWVudCB0aGUgd2lubmVyJ3MgYnJhY2tldCB0ZWFtJ3MgbG9zcyBjb3VudCBmb3IgdGhlIHJlY29yZFxuLy8gICAgICAgaWYgKHdpbm5lcnNCcmFja2V0VGVhbSAmJiB0eXBlb2Ygd2lubmVyc0JyYWNrZXRUZWFtLmxvc3NlcyA9PT0gXCJudW1iZXJcIikge1xuLy8gICAgICAgICB3aW5uZXJzQnJhY2tldFRlYW0ubG9zc2VzICs9IDE7XG4vLyAgICAgICB9XG4vLyAgICAgfSBlbHNlIHtcbi8vICAgICAgIC8vIEVpdGhlciB3aW5uZXIncyBicmFja2V0IHRlYW0gd29uIGZpcnN0IG1hdGNoLCBvciB0aGlzIHdhcyB0aGUgcmVzZXQgbWF0Y2hcbi8vICAgICAgIGlzQ2hhbXBpb25zaGlwUm91bmQgPSB0cnVlO1xuLy8gICAgICAgLy8gTm8gbmV3IG1hdGNoZXMsIHdpbm5lciB3aWxsIGJlIGRldGVybWluZWQgaW4gd2lubmVyIGRldGVjdGlvbiBsb2dpY1xuLy8gICAgIH1cbi8vICAgfVxuLy8gICAvLyBDaGVjayBpZiB3ZSdyZSByZWFkeSBmb3IgdGhlIGNoYW1waW9uc2hpcCBtYXRjaCAtIG9uZSB0ZWFtIGluIGVhY2ggYnJhY2tldCBhbmQgbG9zZXIncyBmaW5hbCBpcyBjb21wbGV0ZVxuLy8gICBlbHNlIGlmIChcbi8vICAgICB3aW5uZXJzQnJhY2tldFRlYW1zLmxlbmd0aCA9PT0gMSAmJlxuLy8gICAgIC8vIElmIEFOWSBsb3NlcnMgYnJhY2tldCBtYXRjaCBpbiB0aGUgY3VycmVudCByb3VuZCBpcyBpbmNvbXBsZXRlLCBzaG93IHdhaXRpbmcgY2FyZHNcbi8vICAgICBjdXJyZW50Um91bmQubWF0Y2hlcy5zb21lKFxuLy8gICAgICAgKG0pID0+XG4vLyAgICAgICAgIChtLmJyYWNrZXQgPT09IFwibG9zZXJzXCIgfHwgbS5pZC5pbmNsdWRlcyhcIkxvc2Vyc0xhc3RcIikpICYmXG4vLyAgICAgICAgICFtLmlzQ29tcGxldGVkXG4vLyAgICAgKVxuLy8gICApIHtcbi8vICAgICAvLyBOb3QgcmVhZHkgZm9yIGNoYW1waW9uc2hpcDogc2hvdyB3YWl0aW5nIGNhcmRzIGZvciBib3RoXG4vLyAgICAgbmV4dFJvdW5kTWF0Y2hlcy5wdXNoKFxuLy8gICAgICAgY3JlYXRlTWF0Y2goXG4vLyAgICAgICAgIGBXJHtuZXh0Um91bmROdW1iZXJ9LXdhaXRpbmdgLFxuLy8gICAgICAgICBuZXh0Um91bmROdW1iZXIsXG4vLyAgICAgICAgIHdpbm5lcnNCcmFja2V0VGVhbXNbMF0sXG4vLyAgICAgICAgIHtcbi8vICAgICAgICAgICBpZDogYHRiZC0ke25leHRSb3VuZE51bWJlcn0td2FpdGluZ2AsXG4vLyAgICAgICAgICAgbmFtZTogXCJUQkRcIixcbi8vICAgICAgICAgICBjaXR5OiBcIlwiLFxuLy8gICAgICAgICAgIGxvc3NlczogMFxuLy8gICAgICAgICB9LFxuLy8gICAgICAgICB0cnVlLFxuLy8gICAgICAgICBcIndpbm5lcnNcIlxuLy8gICAgICAgKVxuLy8gICAgICk7XG4vLyAgICAgaWYgKHRvdXJuYW1lbnQud2lubmVyc0JyYWNrZXRGaW5hbExvc2VyKSB7XG4vLyAgICAgICBuZXh0Um91bmRNYXRjaGVzLnB1c2goXG4vLyAgICAgICAgIGNyZWF0ZU1hdGNoKFxuLy8gICAgICAgICAgIGBMb3NlcnNMYXN0LSR7bmV4dFJvdW5kTnVtYmVyfWAsXG4vLyAgICAgICAgICAgbmV4dFJvdW5kTnVtYmVyLFxuLy8gICAgICAgICAgIHRvdXJuYW1lbnQud2lubmVyc0JyYWNrZXRGaW5hbExvc2VyLFxuLy8gICAgICAgICAgIHtcbi8vICAgICAgICAgICAgIGlkOiBgdGJkLWxvc2Vycy0ke25leHRSb3VuZE51bWJlcn1gLFxuLy8gICAgICAgICAgICAgbmFtZTogXCJUQkRcIixcbi8vICAgICAgICAgICAgIGNpdHk6IFwiXCIsXG4vLyAgICAgICAgICAgICBsb3NzZXM6IDBcbi8vICAgICAgICAgICB9LFxuLy8gICAgICAgICAgIHRydWUsXG4vLyAgICAgICAgICAgXCJsb3NlcnNcIlxuLy8gICAgICAgICApXG4vLyAgICAgICApO1xuLy8gICAgIH1cbi8vICAgICBsb2dUb3VybmFtZW50U3RhdGUoe1xuLy8gICAgICAgcm91bmROdW1iZXI6IG5leHRSb3VuZE51bWJlcixcbi8vICAgICAgIHdpbm5lcnNCcmFja2V0VGVhbXMsXG4vLyAgICAgICBsb3NlcnNCcmFja2V0VGVhbXMsXG4vLyAgICAgICBtYXRjaGVzOiBuZXh0Um91bmRNYXRjaGVzLFxuLy8gICAgICAgd2lubmVyc0JyYWNrZXRGaW5hbExvc2VyOiB0b3VybmFtZW50Lndpbm5lcnNCcmFja2V0RmluYWxMb3NlclxuLy8gICAgIH0pO1xuLy8gICAgIGNyZWF0ZUxvc2Vyc0JyYWNrZXRNYXRjaGVzKCk7XG4vLyAgIH1cbi8vICAgLy8gQ2hlY2sgaWYgd2UgaGF2ZSBhIGxvc2VyIGZyb20gd2lubmVyJ3MgYnJhY2tldCBmaW5hbCB3YWl0aW5nIHRvIHBsYXkgYWdhaW5zdCBsb3NlcidzIGJyYWNrZXQgd2lubmVyXG4vLyAgIGVsc2UgaWYgKFxuLy8gICAgIHdpbm5lcnNCcmFja2V0VGVhbXMubGVuZ3RoID09PSAxICYmXG4vLyAgICAgdG91cm5hbWVudC53aW5uZXJzQnJhY2tldEZpbmFsTG9zZXJcbi8vICAgKSB7XG4vLyAgICAgLy8gQWx3YXlzIHNob3cgdGhlIHdhaXRpbmcgY2FyZCBmb3IgdGhlIGxvc2VycyBicmFja2V0IGZpbmFsIGxvc2VyLCBldmVuIGlmIHRoZSBvcHBvbmVudCBpcyBUQkRcbi8vICAgICBsZXQgbG9zZXJzQnJhY2tldFdpbm5lciA9IG51bGw7XG4vLyAgICAgaWYgKGxvc2Vyc0JyYWNrZXRUZWFtcy5sZW5ndGggPj0gMSkge1xuLy8gICAgICAgbG9zZXJzQnJhY2tldFdpbm5lciA9IGN1cnJlbnRSb3VuZC5tYXRjaGVzXG4vLyAgICAgICAgIC5maWx0ZXIoKG0pID0+IG0uYnJhY2tldCA9PT0gXCJsb3NlcnNcIiAmJiBtLmlzQ29tcGxldGVkICYmIG0ud2lubmVyKVxuLy8gICAgICAgICAubWFwKChtKSA9PiBtLndpbm5lciEpXG4vLyAgICAgICAgIC5maW5kKCh3aW5uZXIpID0+IGxvc2Vyc0JyYWNrZXRUZWFtcy5zb21lKCh0KSA9PiB0LmlkID09PSB3aW5uZXIuaWQpKTtcbi8vICAgICB9XG4vLyAgICAgY29uc3Qgb3Bwb25lbnQgPVxuLy8gICAgICAgbG9zZXJzQnJhY2tldFdpbm5lciAmJlxuLy8gICAgICAgbG9zZXJzQnJhY2tldFdpbm5lci5pZCAhPT0gdG91cm5hbWVudC53aW5uZXJzQnJhY2tldEZpbmFsTG9zZXIuaWRcbi8vICAgICAgICAgPyBsb3NlcnNCcmFja2V0V2lubmVyXG4vLyAgICAgICAgIDoge1xuLy8gICAgICAgICAgICAgaWQ6IGB0YmQtbG9zZXJzLSR7bmV4dFJvdW5kTnVtYmVyfWAsXG4vLyAgICAgICAgICAgICBuYW1lOiBcIlRCRFwiLFxuLy8gICAgICAgICAgICAgY2l0eTogXCJcIixcbi8vICAgICAgICAgICAgIGxvc3NlczogMFxuLy8gICAgICAgICAgIH07XG4vLyAgICAgY29uc3QgaXNCeWUgPVxuLy8gICAgICAgIWxvc2Vyc0JyYWNrZXRXaW5uZXIgfHxcbi8vICAgICAgIGxvc2Vyc0JyYWNrZXRXaW5uZXIuaWQgPT09IHRvdXJuYW1lbnQud2lubmVyc0JyYWNrZXRGaW5hbExvc2VyLmlkO1xuLy8gICAgIG5leHRSb3VuZE1hdGNoZXMucHVzaChcbi8vICAgICAgIGNyZWF0ZU1hdGNoKFxuLy8gICAgICAgICBgTG9zZXJzTGFzdC0ke25leHRSb3VuZE51bWJlcn1gLFxuLy8gICAgICAgICBuZXh0Um91bmROdW1iZXIsXG4vLyAgICAgICAgIHRvdXJuYW1lbnQud2lubmVyc0JyYWNrZXRGaW5hbExvc2VyLFxuLy8gICAgICAgICBvcHBvbmVudCxcbi8vICAgICAgICAgaXNCeWUsXG4vLyAgICAgICAgIFwibG9zZXJzXCJcbi8vICAgICAgIClcbi8vICAgICApO1xuLy8gICAgIC8vIEFsd2F5cyByZW5kZXIgdGhlIHdpbm5lcnMgYnJhY2tldCBjaGFtcGlvbiBhcyBhIG5vbi1zY29yZWFibGUgd2FpdGluZyBjYXJkIGlmIHRoZSBsb3NlcnMgYnJhY2tldCBpcyBub3QgcmVzb2x2ZWRcbi8vICAgICBuZXh0Um91bmRNYXRjaGVzLnB1c2goXG4vLyAgICAgICBjcmVhdGVNYXRjaChcbi8vICAgICAgICAgYFcke25leHRSb3VuZE51bWJlcn0td2FpdGluZ2AsXG4vLyAgICAgICAgIG5leHRSb3VuZE51bWJlcixcbi8vICAgICAgICAgd2lubmVyc0JyYWNrZXRUZWFtc1swXSxcbi8vICAgICAgICAge1xuLy8gICAgICAgICAgIGlkOiBgdGJkLSR7bmV4dFJvdW5kTnVtYmVyfS13YWl0aW5nYCxcbi8vICAgICAgICAgICBuYW1lOiBcIlRCRFwiLFxuLy8gICAgICAgICAgIGNpdHk6IFwiXCIsXG4vLyAgICAgICAgICAgbG9zc2VzOiAwXG4vLyAgICAgICAgIH0sXG4vLyAgICAgICAgIHRydWUsIC8vIGlzQnllOiB0cnVlIHRvIGVuc3VyZSBpdCdzIG5vdCBzY29yZWFibGVcbi8vICAgICAgICAgXCJ3aW5uZXJzXCJcbi8vICAgICAgIClcbi8vICAgICApO1xuLy8gICAgIGNyZWF0ZUxvc2Vyc0JyYWNrZXRNYXRjaGVzKCk7XG4vLyAgIH1cbi8vICAgLy8gT3RoZXJ3aXNlLCBjb250aW51ZSB3aXRoIG5vcm1hbCBicmFja2V0IHBsYXlcbi8vICAgZWxzZSB7XG4vLyAgICAgLy8gSWYgb25seSBvbmUgdGVhbSBpbiB3aW5uZXJzIGFuZCBsb3NlcnMgYnJhY2tldCBpcyBub3QgcmVzb2x2ZWQsIGFsd2F5cyBzaG93IHdhaXRpbmcgY2FyZHNcbi8vICAgICBpZiAod2lubmVyc0JyYWNrZXRUZWFtcy5sZW5ndGggPT09IDEgJiYgbG9zZXJzQnJhY2tldFRlYW1zLmxlbmd0aCA+PSAxKSB7XG4vLyAgICAgICBuZXh0Um91bmRNYXRjaGVzLnB1c2goXG4vLyAgICAgICAgIGNyZWF0ZU1hdGNoKFxuLy8gICAgICAgICAgIGBXJHtuZXh0Um91bmROdW1iZXJ9LXdhaXRpbmdgLFxuLy8gICAgICAgICAgIG5leHRSb3VuZE51bWJlcixcbi8vICAgICAgICAgICB3aW5uZXJzQnJhY2tldFRlYW1zWzBdLFxuLy8gICAgICAgICAgIHtcbi8vICAgICAgICAgICAgIGlkOiBgdGJkLSR7bmV4dFJvdW5kTnVtYmVyfS13YWl0aW5nYCxcbi8vICAgICAgICAgICAgIG5hbWU6IFwiVEJEXCIsXG4vLyAgICAgICAgICAgICBjaXR5OiBcIlwiLFxuLy8gICAgICAgICAgICAgbG9zc2VzOiAwXG4vLyAgICAgICAgICAgfSxcbi8vICAgICAgICAgICB0cnVlLFxuLy8gICAgICAgICAgIFwid2lubmVyc1wiXG4vLyAgICAgICAgIClcbi8vICAgICAgICk7XG4vLyAgICAgICBpZiAodG91cm5hbWVudC53aW5uZXJzQnJhY2tldEZpbmFsTG9zZXIpIHtcbi8vICAgICAgICAgbmV4dFJvdW5kTWF0Y2hlcy5wdXNoKFxuLy8gICAgICAgICAgIGNyZWF0ZU1hdGNoKFxuLy8gICAgICAgICAgICAgYExvc2Vyc0xhc3QtJHtuZXh0Um91bmROdW1iZXJ9YCxcbi8vICAgICAgICAgICAgIG5leHRSb3VuZE51bWJlcixcbi8vICAgICAgICAgICAgIHRvdXJuYW1lbnQud2lubmVyc0JyYWNrZXRGaW5hbExvc2VyLFxuLy8gICAgICAgICAgICAge1xuLy8gICAgICAgICAgICAgICBpZDogYHRiZC1sb3NlcnMtJHtuZXh0Um91bmROdW1iZXJ9YCxcbi8vICAgICAgICAgICAgICAgbmFtZTogXCJUQkRcIixcbi8vICAgICAgICAgICAgICAgY2l0eTogXCJcIixcbi8vICAgICAgICAgICAgICAgbG9zc2VzOiAwXG4vLyAgICAgICAgICAgICB9LFxuLy8gICAgICAgICAgICAgdHJ1ZSxcbi8vICAgICAgICAgICAgIFwibG9zZXJzXCJcbi8vICAgICAgICAgICApXG4vLyAgICAgICAgICk7XG4vLyAgICAgICB9XG4vLyAgICAgfVxuLy8gICB9XG5cbi8vICAgLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGNyZWF0ZSBzdGFuZGFyZCBicmFja2V0IG1hdGNoZXNcbi8vICAgZnVuY3Rpb24gY3JlYXRlU3RhbmRhcmRCcmFja2V0TWF0Y2hlcygpIHtcbi8vICAgICAvLyAtLS0gV2lubmVycyBCcmFja2V0IE1hdGNoZXMgLS0tXG4vLyAgICAgbGV0IG1hdGNoQ291bnRlciA9IDE7XG4vLyAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB3aW5uZXJzQnJhY2tldFRlYW1zLmxlbmd0aDsgaSArPSAyKSB7XG4vLyAgICAgICBjb25zdCB0ZWFtMSA9IHdpbm5lcnNCcmFja2V0VGVhbXNbaV07XG4vLyAgICAgICBjb25zdCB0ZWFtMiA9IHdpbm5lcnNCcmFja2V0VGVhbXNbaSArIDFdID8/IG51bGw7XG4vLyAgICAgICBjb25zdCBpc0J5ZSA9ICF0ZWFtMjtcbi8vICAgICAgIG5leHRSb3VuZE1hdGNoZXMucHVzaChcbi8vICAgICAgICAgY3JlYXRlTWF0Y2goXG4vLyAgICAgICAgICAgYFcke25leHRSb3VuZE51bWJlcn0tJHttYXRjaENvdW50ZXJ9YCxcbi8vICAgICAgICAgICBuZXh0Um91bmROdW1iZXIsXG4vLyAgICAgICAgICAgdGVhbTEsXG4vLyAgICAgICAgICAgdGVhbTIsXG4vLyAgICAgICAgICAgaXNCeWUsXG4vLyAgICAgICAgICAgXCJ3aW5uZXJzXCJcbi8vICAgICAgICAgKVxuLy8gICAgICAgKTtcbi8vICAgICAgIG1hdGNoQ291bnRlcisrO1xuLy8gICAgIH1cblxuLy8gICAgIC8vIENyZWF0ZSBsb3NlcnMgYnJhY2tldCBtYXRjaGVzIHNlcGFyYXRlbHlcbi8vICAgICBjcmVhdGVMb3NlcnNCcmFja2V0TWF0Y2hlcygpO1xuLy8gICB9XG5cbi8vICAgLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGNyZWF0ZSBsb3NlcnMgYnJhY2tldCBtYXRjaGVzXG4vLyAgIGZ1bmN0aW9uIGNyZWF0ZUxvc2Vyc0JyYWNrZXRNYXRjaGVzKCkge1xuLy8gICAgIC8vIC0tLSBMb3NlcnMgQnJhY2tldCBNYXRjaGVzIC0tLVxuLy8gICAgIGNvbnN0IGVsaWdpYmxlTG9zZXJzID0gYWxsVGVhbXMuZmlsdGVyKFxuLy8gICAgICAgKHRlYW0pID0+XG4vLyAgICAgICAgIChsb3NzQ291bnRzW3RlYW0uaWRdIHx8IDApID09PSAxICYmXG4vLyAgICAgICAgICF0b3VybmFtZW50LmVsaW1pbmF0ZWRUZWFtcy5zb21lKCh0KSA9PiB0LmlkID09PSB0ZWFtLmlkKSAmJlxuLy8gICAgICAgICAhbmV3bHlFbGltaW5hdGVkLnNvbWUoKHQpID0+IHQuaWQgPT09IHRlYW0uaWQpICYmXG4vLyAgICAgICAgIC8vIEV4Y2x1ZGUgd2lubmVyJ3MgYnJhY2tldCBmaW5hbCBsb3NlciBpZiBpdCBleGlzdHMgYnV0IGhhc24ndCBwbGF5ZWQgeWV0IGluIGxvc2Vyc1xuLy8gICAgICAgICAhKFxuLy8gICAgICAgICAgIHRvdXJuYW1lbnQud2lubmVyc0JyYWNrZXRGaW5hbExvc2VyICYmXG4vLyAgICAgICAgICAgdG91cm5hbWVudC53aW5uZXJzQnJhY2tldEZpbmFsTG9zZXIuaWQgPT09IHRlYW0uaWRcbi8vICAgICAgICAgKVxuLy8gICAgICk7XG5cbi8vICAgICAvLyBGaW5kIHRlYW1zIHJlY2VudGx5IGRyb3BwZWQgZnJvbSB3aW5uZXJzIGJyYWNrZXRcbi8vICAgICBjb25zdCBqdXN0RHJvcHBlZEZyb21XaW5uZXJzID0gY3VycmVudFJvdW5kLm1hdGNoZXNcbi8vICAgICAgIC5maWx0ZXIoKG0pID0+IG0uYnJhY2tldCA9PT0gXCJ3aW5uZXJzXCIgJiYgbS5sb3NlciAmJiBtLmlzQ29tcGxldGVkKVxuLy8gICAgICAgLm1hcCgobSkgPT4gbS5sb3NlciEpXG4vLyAgICAgICAuZmlsdGVyKChsb3NlcikgPT4gZWxpZ2libGVMb3NlcnMuc29tZSgodCkgPT4gdC5pZCA9PT0gbG9zZXIuaWQpKTtcblxuLy8gICAgIC8vIElmIHRoaXMgaXMgdGhlIHdpbm5lcidzIGJyYWNrZXQgZmluYWwsIHN0b3JlIHRoZSBsb3NlciBmb3IgbGF0ZXIgdXNlXG4vLyAgICAgaWYgKFxuLy8gICAgICAgY3VycmVudFJvdW5kLm1hdGNoZXMuc29tZShcbi8vICAgICAgICAgKG0pID0+XG4vLyAgICAgICAgICAgbS5icmFja2V0ID09PSBcIndpbm5lcnNcIiAmJlxuLy8gICAgICAgICAgIHdpbm5lcnNCcmFja2V0VGVhbXMubGVuZ3RoID09PSAxICYmXG4vLyAgICAgICAgICAgbS5sb3NlciAmJlxuLy8gICAgICAgICAgIG0uaXNDb21wbGV0ZWRcbi8vICAgICAgIClcbi8vICAgICApIHtcbi8vICAgICAgIC8vIFRoaXMgaXMgYSBzcGVjaWFsIGNhc2UgLSB3ZSBmb3VuZCB0aGUgd2lubmVyJ3MgYnJhY2tldCBmaW5hbCBsb3NlclxuLy8gICAgICAgY29uc3Qgd2lubmVyc0ZpbmFsTG9zZXIgPSBjdXJyZW50Um91bmQubWF0Y2hlc1xuLy8gICAgICAgICAuZmlsdGVyKChtKSA9PiBtLmJyYWNrZXQgPT09IFwid2lubmVyc1wiICYmIG0uaXNDb21wbGV0ZWQgJiYgbS5sb3Nlcilcbi8vICAgICAgICAgLm1hcCgobSkgPT4gbS5sb3NlciEpXG4vLyAgICAgICAgIC5wb3AoKTtcblxuLy8gICAgICAgaWYgKHdpbm5lcnNGaW5hbExvc2VyKSB7XG4vLyAgICAgICAgIHRvdXJuYW1lbnQud2lubmVyc0JyYWNrZXRGaW5hbExvc2VyID0gd2lubmVyc0ZpbmFsTG9zZXI7XG4vLyAgICAgICB9XG4vLyAgICAgfVxuXG4vLyAgICAgLy8gRXhpc3RpbmcgbG9zZXJzIGJyYWNrZXQgdGVhbXNcbi8vICAgICBjb25zdCBleGlzdGluZ0xvc2VycyA9IGVsaWdpYmxlTG9zZXJzLmZpbHRlcihcbi8vICAgICAgICh0KSA9PiAhanVzdERyb3BwZWRGcm9tV2lubmVycy5zb21lKChqZCkgPT4gamQuaWQgPT09IHQuaWQpXG4vLyAgICAgKTtcblxuLy8gICAgIC8vIE9yZGVyOiBtb3N0IHJlY2VudCBkcm9wKHMpIGZpcnN0XG4vLyAgICAgY29uc3Qgb3JkZXJlZExvc2VycyA9IFsuLi5qdXN0RHJvcHBlZEZyb21XaW5uZXJzLCAuLi5leGlzdGluZ0xvc2Vyc107XG5cbi8vICAgICBpZiAob3JkZXJlZExvc2Vycy5sZW5ndGggPiAwKSB7XG4vLyAgICAgICBpZiAob3JkZXJlZExvc2Vycy5sZW5ndGggJSAyID09PSAxKSB7XG4vLyAgICAgICAgIC8vIE9kZDogYnllIGdvZXMgdG8gdGhlIG1vc3QgcmVjZW50IHRlYW0gZHJvcHBlZCBmcm9tIHdpbm5lcnMgYnJhY2tldFxuLy8gICAgICAgICBsZXQgdGVhbVdpdGhCeWU6IFRlYW0gfCBudWxsID0gbnVsbDtcbi8vICAgICAgICAgaWYgKGp1c3REcm9wcGVkRnJvbVdpbm5lcnMubGVuZ3RoID4gMCkge1xuLy8gICAgICAgICAgIHRlYW1XaXRoQnllID1cbi8vICAgICAgICAgICAgIGp1c3REcm9wcGVkRnJvbVdpbm5lcnNbanVzdERyb3BwZWRGcm9tV2lubmVycy5sZW5ndGggLSAxXTtcbi8vICAgICAgICAgICAvLyBSZW1vdmUgdGhlIGJ5ZSB0ZWFtIGZyb20gb3JkZXJlZExvc2Vyc1xuLy8gICAgICAgICAgIGNvbnN0IGJ5ZUluZGV4ID0gb3JkZXJlZExvc2Vycy5maW5kSW5kZXgoXG4vLyAgICAgICAgICAgICAodCkgPT4gdC5pZCA9PT0gdGVhbVdpdGhCeWUhLmlkXG4vLyAgICAgICAgICAgKTtcbi8vICAgICAgICAgICBpZiAoYnllSW5kZXggIT09IC0xKSBvcmRlcmVkTG9zZXJzLnNwbGljZShieWVJbmRleCwgMSk7XG4vLyAgICAgICAgIH0gZWxzZSB7XG4vLyAgICAgICAgICAgLy8gRGVmZW5zaXZlOiBmYWxsYmFjayB0byBmaXJzdCB0ZWFtIGlmIG5vIHJlY2VudCBkcm9wXG4vLyAgICAgICAgICAgdGVhbVdpdGhCeWUgPSBvcmRlcmVkTG9zZXJzLnNoaWZ0KCkhO1xuLy8gICAgICAgICB9XG4vLyAgICAgICAgIG5leHRSb3VuZE1hdGNoZXMucHVzaChcbi8vICAgICAgICAgICBjcmVhdGVNYXRjaChcbi8vICAgICAgICAgICAgIGBMJHtuZXh0Um91bmROdW1iZXJ9LTFgLFxuLy8gICAgICAgICAgICAgbmV4dFJvdW5kTnVtYmVyLFxuLy8gICAgICAgICAgICAgdGVhbVdpdGhCeWUsXG4vLyAgICAgICAgICAgICBudWxsLFxuLy8gICAgICAgICAgICAgdHJ1ZSxcbi8vICAgICAgICAgICAgIFwibG9zZXJzXCJcbi8vICAgICAgICAgICApXG4vLyAgICAgICAgICk7XG4vLyAgICAgICAgIC8vIFBhaXIgdGhlIHJlc3Rcbi8vICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvcmRlcmVkTG9zZXJzLmxlbmd0aDsgaSArPSAyKSB7XG4vLyAgICAgICAgICAgY29uc3QgdGVhbTEgPSBvcmRlcmVkTG9zZXJzW2ldO1xuLy8gICAgICAgICAgIGNvbnN0IHRlYW0yID0gb3JkZXJlZExvc2Vyc1tpICsgMV0gPz8gbnVsbDtcbi8vICAgICAgICAgICBuZXh0Um91bmRNYXRjaGVzLnB1c2goXG4vLyAgICAgICAgICAgICBjcmVhdGVNYXRjaChcbi8vICAgICAgICAgICAgICAgYEwke25leHRSb3VuZE51bWJlcn0tJHtNYXRoLmZsb29yKGkgLyAyKSArIDJ9YCxcbi8vICAgICAgICAgICAgICAgbmV4dFJvdW5kTnVtYmVyLFxuLy8gICAgICAgICAgICAgICB0ZWFtMSxcbi8vICAgICAgICAgICAgICAgdGVhbTIsXG4vLyAgICAgICAgICAgICAgICF0ZWFtMixcbi8vICAgICAgICAgICAgICAgXCJsb3NlcnNcIlxuLy8gICAgICAgICAgICAgKVxuLy8gICAgICAgICAgICk7XG4vLyAgICAgICAgIH1cbi8vICAgICAgIH0gZWxzZSB7XG4vLyAgICAgICAgIC8vIEV2ZW4gbnVtYmVyOiBwYWlyIGFsbFxuLy8gICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9yZGVyZWRMb3NlcnMubGVuZ3RoOyBpICs9IDIpIHtcbi8vICAgICAgICAgICBjb25zdCB0ZWFtMSA9IG9yZGVyZWRMb3NlcnNbaV07XG4vLyAgICAgICAgICAgY29uc3QgdGVhbTIgPSBvcmRlcmVkTG9zZXJzW2kgKyAxXSA/PyBudWxsO1xuLy8gICAgICAgICAgIG5leHRSb3VuZE1hdGNoZXMucHVzaChcbi8vICAgICAgICAgICAgIGNyZWF0ZU1hdGNoKFxuLy8gICAgICAgICAgICAgICBgTCR7bmV4dFJvdW5kTnVtYmVyfS0ke01hdGguZmxvb3IoaSAvIDIpICsgMX1gLFxuLy8gICAgICAgICAgICAgICBuZXh0Um91bmROdW1iZXIsXG4vLyAgICAgICAgICAgICAgIHRlYW0xLFxuLy8gICAgICAgICAgICAgICB0ZWFtMixcbi8vICAgICAgICAgICAgICAgIXRlYW0yLFxuLy8gICAgICAgICAgICAgICBcImxvc2Vyc1wiXG4vLyAgICAgICAgICAgICApXG4vLyAgICAgICAgICAgKTtcbi8vICAgICAgICAgfVxuLy8gICAgICAgfVxuLy8gICAgIH1cbi8vICAgfVxuXG4vLyAgIC8vIC0tLSBXaW5uZXIgZGV0ZWN0aW9uIGxvZ2ljIC0tLVxuLy8gICBsZXQgd2lubmVyOiBUZWFtIHwgdW5kZWZpbmVkID0gdG91cm5hbWVudC53aW5uZXI7XG5cbi8vICAgaWYgKGlzQ2hhbXBpb25zaGlwUm91bmQpIHtcbi8vICAgICAvLyBGaW5kIHRoZSBsYXN0IGNoYW1waW9uc2hpcCBtYXRjaCBwbGF5ZWRcbi8vICAgICBjb25zdCBsYXN0Q2hhbXBNYXRjaCA9XG4vLyAgICAgICBjaGFtcGlvbnNoaXBNYXRjaGVzWzBdIHx8XG4vLyAgICAgICBwcmV2Q2hhbXBpb25zaGlwTWF0Y2hlc1twcmV2Q2hhbXBpb25zaGlwTWF0Y2hlcy5sZW5ndGggLSAxXTtcblxuLy8gICAgIGlmIChcbi8vICAgICAgIGxhc3RDaGFtcE1hdGNoICYmXG4vLyAgICAgICBsYXN0Q2hhbXBNYXRjaC5pc0NvbXBsZXRlZCAmJlxuLy8gICAgICAgbGFzdENoYW1wTWF0Y2gud2lubmVyICYmXG4vLyAgICAgICBsYXN0Q2hhbXBNYXRjaC5sb3NlclxuLy8gICAgICkge1xuLy8gICAgICAgY29uc3Qgd2lubmVyc0JyYWNrZXRUZWFtID0gbGFzdENoYW1wTWF0Y2gudGVhbTE7XG4vLyAgICAgICBjb25zdCBsb3NlcnNCcmFja2V0VGVhbSA9IGxhc3RDaGFtcE1hdGNoLnRlYW0yO1xuLy8gICAgICAgY29uc3QgbG9zZXJzQnJhY2tldFRlYW1Xb24gPVxuLy8gICAgICAgICBsb3NlcnNCcmFja2V0VGVhbSAmJiBsYXN0Q2hhbXBNYXRjaC53aW5uZXIuaWQgPT09IGxvc2Vyc0JyYWNrZXRUZWFtLmlkO1xuXG4vLyAgICAgICAvLyBJZiBsb3NlcidzIGJyYWNrZXQgdGVhbSB3b24gZmlyc3QgY2hhbXBpb25zaGlwIG1hdGNoLCB3aW5uZXIncyBicmFja2V0IHRlYW0gZ2V0cyBhbm90aGVyIGNoYW5jZVxuLy8gICAgICAgaWYgKGxvc2Vyc0JyYWNrZXRUZWFtV29uICYmIHRvdXJuYW1lbnQuY2hhbXBpb25zaGlwTWF0Y2hlc1BsYXllZCA9PT0gMSkge1xuLy8gICAgICAgICAvLyBEbyBOT1QgaW5jcmVtZW50IHRoZSB3aW5uZXIncyBicmFja2V0IHRlYW0ncyBsb3NzIGNvdW50IG9yIHNldCB3aW5uZXIgeWV0XG4vLyAgICAgICAgIC8vIFdhaXQgZm9yIHRoZSByZW1hdGNoIHRvIGJlIHBsYXllZFxuLy8gICAgICAgICB3aW5uZXIgPSB1bmRlZmluZWQ7IC8vIE5vIHdpbm5lciB5ZXQsIG5lZWQgcmVzZXQgbWF0Y2hcbi8vICAgICAgIH0gZWxzZSBpZiAoXG4vLyAgICAgICAgIGxhc3RDaGFtcE1hdGNoLnJlcXVpcmVzUmVtYXRjaCAmJlxuLy8gICAgICAgICAhbGFzdENoYW1wTWF0Y2guaXNDb21wbGV0ZWRcbi8vICAgICAgICkge1xuLy8gICAgICAgICAvLyBJZiB0aGUgcmVtYXRjaCBpcyByZXF1aXJlZCBidXQgbm90IGNvbXBsZXRlZCwgZG8gbm90IHNldCB3aW5uZXIgb3IgaW5jcmVtZW50IGxvc3Nlc1xuLy8gICAgICAgICB3aW5uZXIgPSB1bmRlZmluZWQ7XG4vLyAgICAgICB9IGVsc2Uge1xuLy8gICAgICAgICAvLyBJZiB0aGlzIGlzIHRoZSByZW1hdGNoIGFuZCBpdCdzIGNvbXBsZXRlZCwgaW5jcmVtZW50IGxvc3MgZm9yIHdpbm5lcidzIGJyYWNrZXQgdGVhbSBPTkxZIElGIHRoZXkgbG9zZSBhZ2FpblxuLy8gICAgICAgICBpZiAoXG4vLyAgICAgICAgICAgbGFzdENoYW1wTWF0Y2gucmVxdWlyZXNSZW1hdGNoICYmXG4vLyAgICAgICAgICAgbGFzdENoYW1wTWF0Y2guaXNDb21wbGV0ZWQgJiZcbi8vICAgICAgICAgICB3aW5uZXJzQnJhY2tldFRlYW0gJiZcbi8vICAgICAgICAgICBsYXN0Q2hhbXBNYXRjaC53aW5uZXIuaWQgIT09IHdpbm5lcnNCcmFja2V0VGVhbS5pZCAmJlxuLy8gICAgICAgICAgIHR5cGVvZiB3aW5uZXJzQnJhY2tldFRlYW0ubG9zc2VzID09PSBcIm51bWJlclwiXG4vLyAgICAgICAgICkge1xuLy8gICAgICAgICAgIHdpbm5lcnNCcmFja2V0VGVhbS5sb3NzZXMgKz0gMTtcbi8vICAgICAgICAgfVxuLy8gICAgICAgICB3aW5uZXIgPSBsYXN0Q2hhbXBNYXRjaC53aW5uZXI7XG4vLyAgICAgICB9XG4vLyAgICAgfVxuLy8gICB9XG5cbi8vICAgLy8gLS0tIElORklOSVRFIFJFQ1VSU0lPTiBHVUFSRCAtLS1cbi8vICAgY29uc3Qgbm9Nb3JlTWF0Y2hlcyA9XG4vLyAgICAgKGlzQ2hhbXBpb25zaGlwUm91bmQgJiYgY2hhbXBpb25zaGlwTWF0Y2hlcy5sZW5ndGggPT09IDApIHx8XG4vLyAgICAgKCFpc0NoYW1waW9uc2hpcFJvdW5kICYmIG5leHRSb3VuZE1hdGNoZXMubGVuZ3RoID09PSAwKTtcblxuLy8gICBpZiAobm9Nb3JlTWF0Y2hlcykge1xuLy8gICAgIC8vIFRvdXJuYW1lbnQgaXMgb3ZlciwgZG8gbm90IGFkdmFuY2UgZnVydGhlclxuLy8gICAgIHJldHVybiB7XG4vLyAgICAgICAuLi50b3VybmFtZW50LFxuLy8gICAgICAgd2lubmVyLFxuLy8gICAgICAgY3VycmVudFJvdW5kOiB0b3VybmFtZW50LmN1cnJlbnRSb3VuZFxuLy8gICAgIH07XG4vLyAgIH1cbi8vICAgLy8gPC0tLSBQTEFDRSBUSEUgREVCVUcgQ0FMTCBIRVJFLCBqdXN0IGJlZm9yZSByZXR1cm5pbmcgdGhlIG5ldyB0b3VybmFtZW50IG9iamVjdCFcbi8vICAgbG9nVG91cm5hbWVudFN0YXRlKHtcbi8vICAgICByb3VuZE51bWJlcjogbmV4dFJvdW5kTnVtYmVyLFxuLy8gICAgIHdpbm5lcnNCcmFja2V0VGVhbXMsXG4vLyAgICAgbG9zZXJzQnJhY2tldFRlYW1zLFxuLy8gICAgIG1hdGNoZXM6IGlzQ2hhbXBpb25zaGlwUm91bmQgPyBjaGFtcGlvbnNoaXBNYXRjaGVzIDogbmV4dFJvdW5kTWF0Y2hlcyxcbi8vICAgICB3aW5uZXJzQnJhY2tldEZpbmFsTG9zZXI6IHRvdXJuYW1lbnQud2lubmVyc0JyYWNrZXRGaW5hbExvc2VyXG4vLyAgIH0pO1xuXG4vLyAgIC8vIENvbXBvc2UgdGhlIG5ldyB0b3VybmFtZW50IG9iamVjdFxuLy8gICByZXR1cm4ge1xuLy8gICAgIC4uLnRvdXJuYW1lbnQsXG4vLyAgICAgcm91bmRzOiBbXG4vLyAgICAgICAuLi50b3VybmFtZW50LnJvdW5kcyxcbi8vICAgICAgIHtcbi8vICAgICAgICAgcm91bmROdW1iZXI6IG5leHRSb3VuZE51bWJlcixcbi8vICAgICAgICAgbWF0Y2hlczogaXNDaGFtcGlvbnNoaXBSb3VuZCA/IGNoYW1waW9uc2hpcE1hdGNoZXMgOiBuZXh0Um91bmRNYXRjaGVzLFxuLy8gICAgICAgICBpc0RvdWJsZUVsaW1pbmF0aW9uOiB0cnVlLFxuLy8gICAgICAgICBpc0NoYW1waW9uc2hpcFJvdW5kXG4vLyAgICAgICB9XG4vLyAgICAgXSxcbi8vICAgICBjdXJyZW50Um91bmQ6IG5leHRSb3VuZE51bWJlcixcbi8vICAgICBlbGltaW5hdGVkVGVhbXM6IFtcbi8vICAgICAgIC4uLnRvdXJuYW1lbnQuZWxpbWluYXRlZFRlYW1zLFxuLy8gICAgICAgLi4ubmV3bHlFbGltaW5hdGVkLmZpbHRlcihcbi8vICAgICAgICAgKHQpID0+ICF0b3VybmFtZW50LmVsaW1pbmF0ZWRUZWFtcy5zb21lKChldCkgPT4gZXQuaWQgPT09IHQuaWQpXG4vLyAgICAgICApXG4vLyAgICAgXSxcbi8vICAgICBjaGFtcGlvbnNoaXBNYXRjaGVzUGxheWVkOiBpc0NoYW1waW9uc2hpcFJvdW5kXG4vLyAgICAgICA/IHRvdXJuYW1lbnQuY2hhbXBpb25zaGlwTWF0Y2hlc1BsYXllZCArIDFcbi8vICAgICAgIDogdG91cm5hbWVudC5jaGFtcGlvbnNoaXBNYXRjaGVzUGxheWVkLFxuLy8gICAgIHdpbm5lcnNCcmFja2V0RmluYWxMb3NlcjogdG91cm5hbWVudC53aW5uZXJzQnJhY2tldEZpbmFsTG9zZXIsXG4vLyAgICAgd2lubmVyXG4vLyAgIH07XG4vLyB9O1xuXG4vLyBmdW5jdGlvbiBsb2dUb3VybmFtZW50U3RhdGUoe1xuLy8gICByb3VuZE51bWJlcixcbi8vICAgd2lubmVyc0JyYWNrZXRUZWFtcyxcbi8vICAgbG9zZXJzQnJhY2tldFRlYW1zLFxuLy8gICBtYXRjaGVzLFxuLy8gICB3aW5uZXJzQnJhY2tldEZpbmFsTG9zZXJcbi8vIH06IHtcbi8vICAgcm91bmROdW1iZXI6IG51bWJlcixcbi8vICAgd2lubmVyc0JyYWNrZXRUZWFtczogYW55W10sXG4vLyAgIGxvc2Vyc0JyYWNrZXRUZWFtczogYW55W10sXG4vLyAgIG1hdGNoZXM6IGFueVtdLFxuLy8gICB3aW5uZXJzQnJhY2tldEZpbmFsTG9zZXI6IGFueVxuLy8gfSkge1xuLy8gICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuLy8gICBjb25zb2xlLmxvZygnLS0tIFRPVVJOQU1FTlQgREVCVUcgLS0tJyk7XG4vLyAgIGNvbnNvbGUubG9nKCdSb3VuZDonLCByb3VuZE51bWJlcik7XG4vLyAgIGNvbnNvbGUubG9nKCdXaW5uZXJzIEJyYWNrZXQgVGVhbXM6Jywgd2lubmVyc0JyYWNrZXRUZWFtcy5tYXAodCA9PiBgJHt0Lm5hbWV9ICgke3QuaWR9KWApLmpvaW4oJywgJykpO1xuLy8gICBjb25zb2xlLmxvZygnTG9zZXJzIEJyYWNrZXQgVGVhbXM6JywgbG9zZXJzQnJhY2tldFRlYW1zLm1hcCh0ID0+IGAke3QubmFtZX0gKCR7dC5pZH0pYCkuam9pbignLCAnKSk7XG4vLyAgIGNvbnNvbGUubG9nKCdNYXRjaGVzOicpO1xuLy8gICBtYXRjaGVzLmZvckVhY2gobSA9PlxuLy8gICAgIGNvbnNvbGUubG9nKGAgIFske20uYnJhY2tldH1dICR7bS50ZWFtMT8ubmFtZSA/PyAnVEJEJ30gdnMgJHttLnRlYW0yPy5uYW1lID8/ICdUQkQnfSB8IGlzQ29tcGxldGVkOiAke20uaXNDb21wbGV0ZWR9IHwgaXNCeWU6ICR7bS5pc0J5ZX1gKVxuLy8gICApO1xuLy8gICBpZiAod2lubmVyc0JyYWNrZXRGaW5hbExvc2VyKSB7XG4vLyAgICAgY29uc29sZS5sb2coJ1dpbm5lcnMgQnJhY2tldCBGaW5hbCBMb3NlcjonLCB3aW5uZXJzQnJhY2tldEZpbmFsTG9zZXIubmFtZSwgd2lubmVyc0JyYWNrZXRGaW5hbExvc2VyLmlkKTtcbi8vICAgfVxuLy8gICBjb25zb2xlLmxvZygnLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tJyk7XG4vLyB9XG5cbiJdLCJuYW1lcyI6WyJsb2dUb3VybmFtZW50U3RhdGUiLCJjcmVhdGVNYXRjaCIsImlkIiwicm91bmROdW1iZXIiLCJ0ZWFtMSIsInRlYW0yIiwiaXNCeWUiLCJicmFja2V0IiwibmV4dE1hdGNoSWQiLCJuZXh0TG9zZXJNYXRjaElkIiwiaXNDb21wbGV0ZWQiLCJ3aW5uZXIiLCJ1bmRlZmluZWQiLCJsb3NlciIsInNjb3JlIiwidGVhbTFTY29yZSIsInRlYW0yU2NvcmUiLCJlbGltaW5hdGVkTGFiZWwiLCJjcmVhdGVJbml0aWFsUm91bmRzIiwidGVhbXMiLCJudW1UZWFtcyIsImxlbmd0aCIsIm1hdGNoZXMiLCJudW1Sb3VuZHMiLCJNYXRoIiwiY2VpbCIsImxvZzIiLCJmaXJzdFJvdW5kTWF0Y2hlcyIsInBvdyIsIm1hdGNoQ291bnRlciIsImkiLCJtYXRjaElkIiwicHVzaCIsInJvdW5kcyIsImlzRG91YmxlRWxpbWluYXRpb24iLCJpc0NoYW1waW9uc2hpcFJvdW5kIiwiY3VycmVudFJvdW5kIiwiZWxpbWluYXRlZFRlYW1zIiwiY2hhbXBpb25zaGlwTWF0Y2hlc1BsYXllZCIsInVwZGF0ZU1hdGNoU2NvcmUiLCJtYXRjaCIsIm5ld1Njb3JlIiwid2lucyIsImxvc3NlcyIsImRlZHVwZVRlYW1zIiwic2VlbiIsIlNldCIsImZpbHRlciIsInRlYW0iLCJoYXMiLCJhZGQiLCJ0ZWFtc1dpdGhMb3NzZXMiLCJsb3NzQ291bnRzIiwibiIsIk9iamVjdCIsImtleXMiLCJ0ZWFtSWQiLCJhZHZhbmNlVG9OZXh0Um91bmQiLCJ0b3VybmFtZW50IiwibmV4dFJvdW5kTnVtYmVyIiwid2luc0NvdW50cyIsImZvckVhY2giLCJyb3VuZCIsImFsbFRlYW1zIiwidGVhbUlkcyIsIm5ld2x5RWxpbWluYXRlZCIsInNvbWUiLCJ0Iiwid2lubmVyc0JyYWNrZXRUZWFtcyIsInN0YXJ0c1dpdGgiLCJtYXAiLCJsb3NlcnNCcmFja2V0VGVhbXMiLCJ3aW5uZXJzQnJhY2tldEZpbmFsTG9zZXIiLCJjaGFtcGlvbnNoaXBNYXRjaGVzIiwibmV4dFJvdW5kTWF0Y2hlcyIsInByZXZDaGFtcGlvbnNoaXBNYXRjaGVzIiwiciIsImZsYXRNYXAiLCJtIiwibGFzdENoYW1wTWF0Y2giLCJ3aW5uZXJzQnJhY2tldFRlYW0iLCJsb3NlcnNCcmFja2V0VGVhbSIsImluY2x1ZGVzIiwibG9zZXJzQnJhY2tldFdpbm5lciIsInBvcCIsImFscmVhZHlQbGF5ZWQiLCJpZHMiLCJCb29sZWFuIiwic29ydCIsImN1cnJJZHMiLCJmbG9vciIsImNyZWF0ZUxvc2Vyc0JyYWNrZXRNYXRjaGVzIiwiY3JlYXRlU3RhbmRhcmRCcmFja2V0TWF0Y2hlcyIsImVsaWdpYmxlTG9zZXJzIiwianVzdERyb3BwZWRGcm9tV2lubmVycyIsIndpbm5lcnNGaW5hbExvc2VyIiwiZXhpc3RpbmdMb3NlcnMiLCJqZCIsIm9yZGVyZWRMb3NlcnMiLCJ0ZWFtV2l0aEJ5ZSIsImJ5ZUluZGV4IiwiZmluZEluZGV4Iiwic3BsaWNlIiwic2hpZnQiLCJsb3NlcnNCcmFja2V0VGVhbVdvbiIsIm5vTW9yZU1hdGNoZXMiLCJldCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./types/tournament/matches.ts\n"));

/***/ })

});
"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/tournament/page",{

/***/ "(app-pages-browser)/./types/tournament/matches.ts":
/*!*************************************!*\
  !*** ./types/tournament/matches.ts ***!
  \*************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   advanceToNextRound: function() { return /* binding */ advanceToNextRound; },\n/* harmony export */   createInitialRounds: function() { return /* binding */ createInitialRounds; },\n/* harmony export */   createMatch: function() { return /* binding */ createMatch; },\n/* harmony export */   updateMatchScore: function() { return /* binding */ updateMatchScore; }\n/* harmony export */ });\nconst createMatch = function(id, roundNumber, team1, team2) {\n    let isBye = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : false, bracket = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : \"winners\", nextMatchId = arguments.length > 6 ? arguments[6] : void 0, nextLoserMatchId = arguments.length > 7 ? arguments[7] : void 0;\n    var _ref;\n    return {\n        id,\n        roundNumber,\n        team1,\n        team2,\n        isCompleted: isBye,\n        isBye,\n        bracket,\n        winner: isBye ? (_ref = team1 !== null && team1 !== void 0 ? team1 : team2) !== null && _ref !== void 0 ? _ref : undefined : undefined,\n        loser: isBye ? undefined : undefined,\n        score: {\n            team1Score: 0,\n            team2Score: 0\n        },\n        nextMatchId,\n        nextLoserMatchId,\n        eliminatedLabel: undefined\n    };\n};\nconst createInitialRounds = (teams)=>{\n    const numTeams = teams.length;\n    const matches = [];\n    const numRounds = Math.ceil(Math.log2(numTeams));\n    const firstRoundMatches = Math.pow(2, numRounds - 1);\n    let matchCounter = 1;\n    for(let i = 0; i < firstRoundMatches; i++){\n        const team1 = teams[i * 2] || null;\n        const team2 = teams[i * 2 + 1] || null;\n        const isBye = !team1 || !team2;\n        const matchId = \"W1-\".concat(matchCounter);\n        const nextMatchId = \"W2-\".concat(Math.ceil(matchCounter / 2));\n        const nextLoserMatchId = \"L1-\".concat(Math.ceil(matchCounter / 2));\n        matches.push(createMatch(matchId, 1, team1, team2, isBye, \"winners\", nextMatchId, nextLoserMatchId));\n        matchCounter++;\n    }\n    return {\n        rounds: [\n            {\n                roundNumber: 1,\n                matches,\n                isDoubleElimination: true,\n                isChampionshipRound: false\n            }\n        ],\n        currentRound: 1,\n        eliminatedTeams: [],\n        championshipMatchesPlayed: 0\n    };\n};\nconst updateMatchScore = (match, newScore)=>{\n    const isCompleted = newScore.team1Score !== newScore.team2Score;\n    let winner = undefined;\n    let loser = undefined;\n    if (isCompleted) {\n        if (newScore.team1Score > newScore.team2Score) {\n            var _match_team1_wins, _match_team1_losses;\n            winner = match.team1 ? {\n                ...match.team1,\n                wins: ((_match_team1_wins = match.team1.wins) !== null && _match_team1_wins !== void 0 ? _match_team1_wins : 0) + 1,\n                losses: (_match_team1_losses = match.team1.losses) !== null && _match_team1_losses !== void 0 ? _match_team1_losses : 0\n            } : undefined;\n            var _match_team2_wins, _match_team2_losses;\n            loser = match.team2 ? {\n                ...match.team2,\n                wins: (_match_team2_wins = match.team2.wins) !== null && _match_team2_wins !== void 0 ? _match_team2_wins : 0,\n                losses: ((_match_team2_losses = match.team2.losses) !== null && _match_team2_losses !== void 0 ? _match_team2_losses : 0) + 1\n            } : undefined;\n        } else {\n            var _match_team2_wins1, _match_team2_losses1;\n            winner = match.team2 ? {\n                ...match.team2,\n                wins: ((_match_team2_wins1 = match.team2.wins) !== null && _match_team2_wins1 !== void 0 ? _match_team2_wins1 : 0) + 1,\n                losses: (_match_team2_losses1 = match.team2.losses) !== null && _match_team2_losses1 !== void 0 ? _match_team2_losses1 : 0\n            } : undefined;\n            var _match_team1_wins1, _match_team1_losses1;\n            loser = match.team1 ? {\n                ...match.team1,\n                wins: (_match_team1_wins1 = match.team1.wins) !== null && _match_team1_wins1 !== void 0 ? _match_team1_wins1 : 0,\n                losses: ((_match_team1_losses1 = match.team1.losses) !== null && _match_team1_losses1 !== void 0 ? _match_team1_losses1 : 0) + 1\n            } : undefined;\n        }\n    }\n    return {\n        ...match,\n        score: newScore,\n        isCompleted,\n        winner,\n        loser\n    };\n};\n// Helper to create a TBD team\nfunction createTBDTeam(slot) {\n    return {\n        id: \"tbd-\".concat(slot),\n        name: \"TBD\",\n        wins: 0,\n        losses: 0\n    };\n}\n// Helper to deduplicate teams by ID\nfunction dedupeTeams(teams) {\n    const seen = new Set();\n    return teams.filter((team)=>{\n        if (!team) return false;\n        if (seen.has(team.id)) return false;\n        seen.add(team.id);\n        return true;\n    });\n}\n// Helper: get all teams with exactly N losses\nfunction teamsWithLosses(lossCounts, n) {\n    return Object.keys(lossCounts).filter((teamId)=>lossCounts[teamId] === n);\n}\nconst advanceToNextRound = (tournament)=>{\n    const currentRound = tournament.rounds[tournament.rounds.length - 1];\n    const nextRoundNumber = tournament.currentRound + 1;\n    // Track all losses and wins across the tournament\n    const lossCounts = {};\n    const winsCounts = {};\n    tournament.rounds.forEach((round)=>{\n        round.matches.forEach((match)=>{\n            if (match.isCompleted && match.loser) {\n                lossCounts[match.loser.id] = (lossCounts[match.loser.id] || 0) + 1;\n            }\n            if (match.isCompleted && match.winner) {\n                winsCounts[match.winner.id] = (winsCounts[match.winner.id] || 0) + 1;\n            }\n        });\n    });\n    // Gather all teams ever in the tournament, attaching wins/losses\n    const allTeams = [];\n    const teamIds = new Set();\n    for (const round of tournament.rounds){\n        for (const match of round.matches){\n            if (match.team1 && !teamIds.has(match.team1.id)) {\n                allTeams.push({\n                    ...match.team1,\n                    wins: winsCounts[match.team1.id] || 0,\n                    losses: lossCounts[match.team1.id] || 0\n                });\n                teamIds.add(match.team1.id);\n            }\n            if (match.team2 && !teamIds.has(match.team2.id)) {\n                allTeams.push({\n                    ...match.team2,\n                    wins: winsCounts[match.team2.id] || 0,\n                    losses: lossCounts[match.team2.id] || 0\n                });\n                teamIds.add(match.team2.id);\n            }\n        }\n    }\n    // Identify newly eliminated teams (2 losses)\n    const newlyEliminated = [];\n    for (const team of allTeams){\n        if ((lossCounts[team.id] || 0) >= 2 && !tournament.eliminatedTeams.some((t)=>t.id === team.id)) {\n            newlyEliminated.push(team);\n        }\n    }\n    // Winners: teams with 0 losses and not eliminated\n    const winnersBracketTeams = allTeams.filter((team)=>(lossCounts[team.id] || 0) === 0 && !tournament.eliminatedTeams.some((t)=>t.id === team.id) && !newlyEliminated.some((t)=>t.id === team.id)).map((team)=>({\n            ...team,\n            losses: lossCounts[team.id] || 0,\n            wins: winsCounts[team.id] || 0\n        }));\n    // Losers: teams with 1 loss and not eliminated\n    const losersBracketTeams = allTeams.filter((team)=>(lossCounts[team.id] || 0) === 1 && !tournament.eliminatedTeams.some((t)=>t.id === team.id) && !newlyEliminated.some((t)=>t.id === team.id)).map((team)=>({\n            ...team,\n            losses: lossCounts[team.id] || 0,\n            wins: winsCounts[team.id] || 0\n        }));\n    let isChampionshipRound = false;\n    let championshipMatches = [];\n    let nextRoundMatches = [];\n    const prevChampionshipMatches = tournament.rounds.filter((r)=>r.isChampionshipRound).flatMap((r)=>r.matches).filter((m)=>m.bracket === \"championship\");\n    // --- CHAMPIONSHIP LOGIC ---\n    // If a championship match has been played and completed, check if reset is needed\n    if (prevChampionshipMatches.length >= 1 && prevChampionshipMatches[prevChampionshipMatches.length - 1].isCompleted) {\n        var _lastChampMatch_winner;\n        const lastChampMatch = prevChampionshipMatches[prevChampionshipMatches.length - 1];\n        const winnersBracketTeam = lastChampMatch.team1;\n        const losersBracketTeam = lastChampMatch.team2;\n        // If loser's bracket team won the first championship match, schedule a reset\n        if (((_lastChampMatch_winner = lastChampMatch.winner) === null || _lastChampMatch_winner === void 0 ? void 0 : _lastChampMatch_winner.id) === (losersBracketTeam === null || losersBracketTeam === void 0 ? void 0 : losersBracketTeam.id) && tournament.championshipMatchesPlayed === 1) {\n            isChampionshipRound = true;\n            championshipMatches.push(createMatch(\"C\".concat(nextRoundNumber, \"-2\"), nextRoundNumber, winnersBracketTeam, losersBracketTeam, false, \"championship\"));\n        } else {\n            // Championship is over, winner will be set below\n            isChampionshipRound = true;\n        }\n    } else if (winnersBracketTeams.length === 1 && losersBracketTeams.length === 1 && currentRound.matches.some((m)=>(m.bracket === \"losers\" || m.id.includes(\"LosersLast\")) && m.isCompleted && m.winner && losersBracketTeams.some((t)=>t.id === m.winner.id))) {\n        isChampionshipRound = true;\n        championshipMatches.push(createMatch(\"C\".concat(nextRoundNumber, \"-1\"), nextRoundNumber, winnersBracketTeams[0], losersBracketTeams[0], false, \"championship\"));\n    } else if (winnersBracketTeams.length === 1 && losersBracketTeams.length === 0 && // The losers bracket champion is not yet determined, but WB champ is waiting\n    currentRound.matches.some((m)=>m.bracket === \"losers\" && !m.isCompleted)) {\n        // Insert a TBD card for the championship opponent\n        isChampionshipRound = true;\n        championshipMatches.push(createMatch(\"C\".concat(nextRoundNumber, \"-tbd\"), nextRoundNumber, winnersBracketTeams[0], createTBDTeam(\"championship-\".concat(nextRoundNumber)), true, \"championship\"));\n    } else if (winnersBracketTeams.length === 1 && losersBracketTeams.length >= 1 && tournament.winnersBracketFinalLoser) {\n        const losersBracketWinner = currentRound.matches.filter((m)=>m.bracket === \"losers\" && m.isCompleted && m.winner).map((m)=>m.winner).find((winner)=>losersBracketTeams.some((t)=>t.id === winner.id));\n        if (losersBracketWinner && losersBracketWinner.id !== tournament.winnersBracketFinalLoser.id) {\n            nextRoundMatches.push(createMatch(\"LosersLast-\".concat(nextRoundNumber), nextRoundNumber, tournament.winnersBracketFinalLoser, losersBracketWinner, false, \"losers\"));\n        } else {\n            // Insert a TBD card for the opponent if only one side is known (the WB Final Loser)\n            if (tournament.winnersBracketFinalLoser && losersBracketTeams.length === 1) {\n                nextRoundMatches.push(createMatch(\"LosersLast-\".concat(nextRoundNumber), nextRoundNumber, tournament.winnersBracketFinalLoser, createTBDTeam(\"losers-\".concat(nextRoundNumber)), true, \"losers\"));\n            }\n            createStandardBracketMatches();\n        }\n    } else if (winnersBracketTeams.length === 2 && losersBracketTeams.length >= 1) {\n        nextRoundMatches.push(createMatch(\"W\".concat(nextRoundNumber, \"-1\"), nextRoundNumber, winnersBracketTeams[0], winnersBracketTeams[1], false, \"winners\"));\n        createLosersBracketMatches();\n    } else {\n        createStandardBracketMatches();\n    }\n    // --- Helper: Standard Winners Bracket Matches ---\n    function createStandardBracketMatches() {\n        let matchCounter = 1;\n        for(let i = 0; i < winnersBracketTeams.length; i += 2){\n            const team1 = winnersBracketTeams[i];\n            var _winnersBracketTeams_;\n            const team2 = (_winnersBracketTeams_ = winnersBracketTeams[i + 1]) !== null && _winnersBracketTeams_ !== void 0 ? _winnersBracketTeams_ : null;\n            const isBye = !team2;\n            nextRoundMatches.push(createMatch(\"W\".concat(nextRoundNumber, \"-\").concat(matchCounter), nextRoundNumber, team1, team2, isBye, \"winners\"));\n            matchCounter++;\n        }\n        createLosersBracketMatches();\n    }\n    // --- Helper: Losers Bracket Matches ---\n    function createLosersBracketMatches() {\n        const eligibleLosers = allTeams.filter((team)=>(lossCounts[team.id] || 0) === 1 && !tournament.eliminatedTeams.some((t)=>t.id === team.id) && !newlyEliminated.some((t)=>t.id === team.id) && !(tournament.winnersBracketFinalLoser && tournament.winnersBracketFinalLoser.id === team.id));\n        const justDroppedFromWinners = currentRound.matches.filter((m)=>m.bracket === \"winners\" && m.loser && m.isCompleted).map((m)=>m.loser).filter((loser)=>eligibleLosers.some((t)=>t.id === loser.id));\n        // If this is the winner's bracket final, store the loser for later use\n        if (currentRound.matches.some((m)=>m.bracket === \"winners\" && winnersBracketTeams.length === 1 && m.loser && m.isCompleted)) {\n            const winnersFinalLoser = currentRound.matches.filter((m)=>m.bracket === \"winners\" && m.isCompleted && m.loser).map((m)=>m.loser).pop();\n            if (winnersFinalLoser) {\n                tournament.winnersBracketFinalLoser = winnersFinalLoser;\n            }\n        }\n        const existingLosers = eligibleLosers.filter((t)=>!justDroppedFromWinners.some((jd)=>jd.id === t.id));\n        const orderedLosers = [\n            ...justDroppedFromWinners,\n            ...existingLosers\n        ];\n        if (orderedLosers.length > 0) {\n            if (orderedLosers.length % 2 === 1) {\n                let teamWithBye = null;\n                if (justDroppedFromWinners.length > 0) {\n                    teamWithBye = justDroppedFromWinners[justDroppedFromWinners.length - 1];\n                    const byeIndex = orderedLosers.findIndex((t)=>t.id === teamWithBye.id);\n                    if (byeIndex !== -1) orderedLosers.splice(byeIndex, 1);\n                } else {\n                    teamWithBye = orderedLosers.shift();\n                }\n                nextRoundMatches.push(createMatch(\"L\".concat(nextRoundNumber, \"-1\"), nextRoundNumber, teamWithBye, null, true, \"losers\"));\n                for(let i = 0; i < orderedLosers.length; i += 2){\n                    const team1 = orderedLosers[i];\n                    var _orderedLosers_;\n                    const team2 = (_orderedLosers_ = orderedLosers[i + 1]) !== null && _orderedLosers_ !== void 0 ? _orderedLosers_ : null;\n                    nextRoundMatches.push(createMatch(\"L\".concat(nextRoundNumber, \"-\").concat(Math.floor(i / 2) + 2), nextRoundNumber, team1, team2, !team2, \"losers\"));\n                }\n            } else {\n                for(let i = 0; i < orderedLosers.length; i += 2){\n                    const team1 = orderedLosers[i];\n                    var _orderedLosers_1;\n                    const team2 = (_orderedLosers_1 = orderedLosers[i + 1]) !== null && _orderedLosers_1 !== void 0 ? _orderedLosers_1 : null;\n                    nextRoundMatches.push(createMatch(\"L\".concat(nextRoundNumber, \"-\").concat(Math.floor(i / 2) + 1), nextRoundNumber, team1, team2, !team2, \"losers\"));\n                }\n            }\n        }\n    }\n    // --- Winner detection logic ---\n    let winner = tournament.winner;\n    if (isChampionshipRound) {\n        const lastChampMatch = championshipMatches[0] || prevChampionshipMatches[prevChampionshipMatches.length - 1];\n        if (lastChampMatch && lastChampMatch.isCompleted && lastChampMatch.winner && lastChampMatch.loser) {\n            const winnersBracketTeam = lastChampMatch.team1;\n            const losersBracketTeam = lastChampMatch.team2;\n            const losersBracketTeamWon = losersBracketTeam && lastChampMatch.winner.id === losersBracketTeam.id;\n            if (losersBracketTeamWon && tournament.championshipMatchesPlayed === 1) {\n                winner = undefined;\n            } else {\n                winner = lastChampMatch.winner;\n            }\n        }\n    }\n    // --- INFINITE RECURSION GUARD ---\n    const noMoreMatches = isChampionshipRound && championshipMatches.length === 0 || !isChampionshipRound && nextRoundMatches.length === 0;\n    if (noMoreMatches) {\n        return {\n            ...tournament,\n            winner,\n            currentRound: tournament.currentRound\n        };\n    }\n    // --- Compose new tournament object ---\n    return {\n        ...tournament,\n        rounds: [\n            ...tournament.rounds,\n            {\n                roundNumber: nextRoundNumber,\n                matches: isChampionshipRound ? championshipMatches : nextRoundMatches,\n                isDoubleElimination: true,\n                isChampionshipRound\n            }\n        ],\n        currentRound: nextRoundNumber,\n        eliminatedTeams: [\n            ...tournament.eliminatedTeams,\n            ...newlyEliminated.filter((t)=>!tournament.eliminatedTeams.some((et)=>et.id === t.id))\n        ],\n        championshipMatchesPlayed: isChampionshipRound ? tournament.championshipMatchesPlayed + 1 : tournament.championshipMatchesPlayed,\n        winnersBracketFinalLoser: tournament.winnersBracketFinalLoser,\n        winner\n    };\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3R5cGVzL3RvdXJuYW1lbnQvbWF0Y2hlcy50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBbUNPLE1BQU1BLGNBQWMsU0FDekJDLElBQ0FDLGFBQ0FDLE9BQ0FDO1FBQ0FDLHlFQUFpQixPQUNqQkMsMkVBQWlELFdBQ2pEQyw0REFDQUM7UUFTZ0JMO1dBUkw7UUFDWEY7UUFDQUM7UUFDQUM7UUFDQUM7UUFDQUssYUFBYUo7UUFDYkE7UUFDQUM7UUFDQUksUUFBUUwsUUFBUUYsQ0FBQUEsT0FBQUEsa0JBQUFBLG1CQUFBQSxRQUFTQyxtQkFBVEQsa0JBQUFBLE9BQWtCUSxZQUFZQTtRQUM5Q0MsT0FBT1AsUUFBUU0sWUFBWUE7UUFDM0JFLE9BQU87WUFBRUMsWUFBWTtZQUFHQyxZQUFZO1FBQUU7UUFDdENSO1FBQ0FDO1FBQ0FRLGlCQUFpQkw7SUFDbkI7QUFBQSxFQUFHO0FBRUksTUFBTU0sc0JBQXNCLENBQUNDO0lBQ2xDLE1BQU1DLFdBQVdELE1BQU1FLE1BQU07SUFDN0IsTUFBTUMsVUFBbUIsRUFBRTtJQUMzQixNQUFNQyxZQUFZQyxLQUFLQyxJQUFJLENBQUNELEtBQUtFLElBQUksQ0FBQ047SUFFdEMsTUFBTU8sb0JBQW9CSCxLQUFLSSxHQUFHLENBQUMsR0FBR0wsWUFBWTtJQUNsRCxJQUFJTSxlQUFlO0lBRW5CLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJSCxtQkFBbUJHLElBQUs7UUFDMUMsTUFBTTFCLFFBQVFlLEtBQUssQ0FBQ1csSUFBSSxFQUFFLElBQUk7UUFDOUIsTUFBTXpCLFFBQVFjLEtBQUssQ0FBQ1csSUFBSSxJQUFJLEVBQUUsSUFBSTtRQUNsQyxNQUFNeEIsUUFBUSxDQUFDRixTQUFTLENBQUNDO1FBRXpCLE1BQU0wQixVQUFVLE1BQW1CLE9BQWJGO1FBQ3RCLE1BQU1yQixjQUFjLE1BQWtDLE9BQTVCZ0IsS0FBS0MsSUFBSSxDQUFDSSxlQUFlO1FBQ25ELE1BQU1wQixtQkFBbUIsTUFBa0MsT0FB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ckUsTUFBTSxDQUFDVCxFQUFFLEtBQUtnRixrQkFBa0JoRixFQUFFO1lBQ3hFLElBQUlvRyx3QkFBd0J6QyxXQUFXdkIseUJBQXlCLEtBQUssR0FBRztnQkFDdEUzQixTQUFTQztZQUNYLE9BQU87Z0JBQ0xELFNBQVNxRSxlQUFlckUsTUFBTTtZQUNoQztRQUNGO0lBQ0Y7SUFFQSxtQ0FBbUM7SUFDbkMsTUFBTTRGLGdCQUNKLHVCQUF3QjdCLG9CQUFvQnJELE1BQU0sS0FBSyxLQUN0RCxDQUFDYyx1QkFBdUJ3QyxpQkFBaUJ0RCxNQUFNLEtBQUs7SUFDdkQsSUFBSWtGLGVBQWU7UUFDakIsT0FBTztZQUNMLEdBQUcxQyxVQUFVO1lBQ2JsRDtZQUNBeUIsY0FBY3lCLFdBQVd6QixZQUFZO1FBQ3ZDO0lBQ0Y7SUFFQSx3Q0FBd0M7SUFDeEMsT0FBTztRQUNMLEdBQUd5QixVQUFVO1FBQ2I1QixRQUFRO2VBQ0g0QixXQUFXNUIsTUFBTTtZQUNwQjtnQkFDRTlCLGFBQWEyRDtnQkFDYnhDLFNBQVNhLHNCQUFzQnVDLHNCQUFzQkM7Z0JBQ3JEekMscUJBQXFCO2dCQUNyQkM7WUFDRjtTQUNEO1FBQ0RDLGNBQWMwQjtRQUNkekIsaUJBQWlCO2VBQ1p3QixXQUFXeEIsZUFBZTtlQUMxQitCLGdCQUFnQmxCLE1BQU0sQ0FDdkIsQ0FBQ29CLElBQU0sQ0FBQ1QsV0FBV3hCLGVBQWUsQ0FBQ2dDLElBQUksQ0FBQyxDQUFDbUMsS0FBT0EsR0FBR3RHLEVBQUUsS0FBS29FLEVBQUVwRSxFQUFFO1NBRWpFO1FBQ0RvQywyQkFBMkJILHNCQUN2QjBCLFdBQVd2Qix5QkFBeUIsR0FBRyxJQUN2Q3VCLFdBQVd2Qix5QkFBeUI7UUFDeEM4QywwQkFBMEJ2QixXQUFXdUIsd0JBQXdCO1FBQzdEekU7SUFDRjtBQUNGLEVBQUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vdHlwZXMvdG91cm5hbWVudC9tYXRjaGVzLnRzP2RhMjIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUgeyBUZWFtIH0gZnJvbSBcIi4vbWxiLXRlYW1zXCI7XG5cbmV4cG9ydCBpbnRlcmZhY2UgTWF0Y2gge1xuICBpZDogc3RyaW5nO1xuICByb3VuZE51bWJlcjogbnVtYmVyO1xuICB0ZWFtMTogVGVhbSB8IG51bGw7XG4gIHRlYW0yOiBUZWFtIHwgbnVsbDtcbiAgaXNDb21wbGV0ZWQ6IGJvb2xlYW47XG4gIGlzQnllPzogYm9vbGVhbjtcbiAgd2lubmVyPzogVGVhbTtcbiAgbG9zZXI/OiBUZWFtO1xuICBicmFja2V0OiBcIndpbm5lcnNcIiB8IFwibG9zZXJzXCIgfCBcImNoYW1waW9uc2hpcFwiO1xuICBzY29yZTogeyB0ZWFtMVNjb3JlOiBudW1iZXI7IHRlYW0yU2NvcmU6IG51bWJlciB9O1xuICBuZXh0TWF0Y2hJZD86IHN0cmluZztcbiAgbmV4dExvc2VyTWF0Y2hJZD86IHN0cmluZztcbiAgZWxpbWluYXRlZExhYmVsPzogc3RyaW5nOyAvLyBsYWJlbCBmb3IgZWxpbWluYXRlZCB0ZWFtcyBpbiBsb3NlcnMgYnJhY2tldFxuICByZXF1aXJlc1JlbWF0Y2g/OiBib29sZWFuOyAvLyBpbmRpY2F0ZXMgaWYgYSBjaGFtcGlvbnNoaXAgcmVtYXRjaCBpcyByZXF1aXJlZFxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFJvdW5kIHtcbiAgcm91bmROdW1iZXI6IG51bWJlcjtcbiAgbWF0Y2hlczogTWF0Y2hbXTtcbiAgaXNEb3VibGVFbGltaW5hdGlvbjogYm9vbGVhbjtcbiAgaXNDaGFtcGlvbnNoaXBSb3VuZDogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBUb3VybmFtZW50IHtcbiAgcm91bmRzOiBSb3VuZFtdO1xuICBjdXJyZW50Um91bmQ6IG51bWJlcjtcbiAgZWxpbWluYXRlZFRlYW1zOiBUZWFtW107XG4gIGNoYW1waW9uc2hpcE1hdGNoZXNQbGF5ZWQ6IG51bWJlcjtcbiAgd2lubmVyPzogVGVhbTtcbiAgd2lubmVyc0JyYWNrZXRGaW5hbExvc2VyPzogVGVhbTsgLy8gdHJhY2tzIHRoZSB3aW5uZXIncyBicmFja2V0IGZpbmFsIGxvc2VyIGZvciBjaGFtcGlvbnNoaXAgcmVtYXRjaCBsb2dpY1xufVxuXG5leHBvcnQgY29uc3QgY3JlYXRlTWF0Y2ggPSAoXG4gIGlkOiBzdHJpbmcsXG4gIHJvdW5kTnVtYmVyOiBudW1iZXIsXG4gIHRlYW0xOiBUZWFtIHwgbnVsbCxcbiAgdGVhbTI6IFRlYW0gfCBudWxsLFxuICBpc0J5ZTogYm9vbGVhbiA9IGZhbHNlLFxuICBicmFja2V0OiBcIndpbm5lcnNcIiB8IFwibG9zZXJzXCIgfCBcImNoYW1waW9uc2hpcFwiID0gXCJ3aW5uZXJzXCIsXG4gIG5leHRNYXRjaElkPzogc3RyaW5nLFxuICBuZXh0TG9zZXJNYXRjaElkPzogc3RyaW5nXG4pOiBNYXRjaCA9PiAoe1xuICBpZCxcbiAgcm91bmROdW1iZXIsXG4gIHRlYW0xLFxuICB0ZWFtMixcbiAgaXNDb21wbGV0ZWQ6IGlzQnllLFxuICBpc0J5ZSxcbiAgYnJhY2tldCxcbiAgd2lubmVyOiBpc0J5ZSA/IHRlYW0xID8/IHRlYW0yID8/IHVuZGVmaW5lZCA6IHVuZGVmaW5lZCxcbiAgbG9zZXI6IGlzQnllID8gdW5kZWZpbmVkIDogdW5kZWZpbmVkLFxuICBzY29yZTogeyB0ZWFtMVNjb3JlOiAwLCB0ZWFtMlNjb3JlOiAwIH0sXG4gIG5leHRNYXRjaElkLFxuICBuZXh0TG9zZXJNYXRjaElkLFxuICBlbGltaW5hdGVkTGFiZWw6IHVuZGVmaW5lZFxufSk7XG5cbmV4cG9ydCBjb25zdCBjcmVhdGVJbml0aWFsUm91bmRzID0gKHRlYW1zOiBUZWFtW10pOiBUb3VybmFtZW50ID0+IHtcbiAgY29uc3QgbnVtVGVhbXMgPSB0ZWFtcy5sZW5ndGg7XG4gIGNvbnN0IG1hdGNoZXM6IE1hdGNoW10gPSBbXTtcbiAgY29uc3QgbnVtUm91bmRzID0gTWF0aC5jZWlsKE1hdGgubG9nMihudW1UZWFtcykpO1xuXG4gIGNvbnN0IGZpcnN0Um91bmRNYXRjaGVzID0gTWF0aC5wb3coMiwgbnVtUm91bmRzIC0gMSk7XG4gIGxldCBtYXRjaENvdW50ZXIgPSAxO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZmlyc3RSb3VuZE1hdGNoZXM7IGkrKykge1xuICAgIGNvbnN0IHRlYW0xID0gdGVhbXNbaSAqIDJdIHx8IG51bGw7XG4gICAgY29uc3QgdGVhbTIgPSB0ZWFtc1tpICogMiArIDFdIHx8IG51bGw7XG4gICAgY29uc3QgaXNCeWUgPSAhdGVhbTEgfHwgIXRlYW0yO1xuXG4gICAgY29uc3QgbWF0Y2hJZCA9IGBXMS0ke21hdGNoQ291bnRlcn1gO1xuICAgIGNvbnN0IG5leHRNYXRjaElkID0gYFcyLSR7TWF0aC5jZWlsKG1hdGNoQ291bnRlciAvIDIpfWA7XG4gICAgY29uc3QgbmV4dExvc2VyTWF0Y2hJZCA9IGBMMS0ke01hdGguY2VpbChtYXRjaENvdW50ZXIgLyAyKX1gO1xuXG4gICAgbWF0Y2hlcy5wdXNoKFxuICAgICAgY3JlYXRlTWF0Y2goXG4gICAgICAgIG1hdGNoSWQsXG4gICAgICAgIDEsXG4gICAgICAgIHRlYW0xLFxuICAgICAgICB0ZWFtMixcbiAgICAgICAgaXNCeWUsXG4gICAgICAgIFwid2lubmVyc1wiLFxuICAgICAgICBuZXh0TWF0Y2hJZCxcbiAgICAgICAgbmV4dExvc2VyTWF0Y2hJZFxuICAgICAgKVxuICAgICk7XG4gICAgbWF0Y2hDb3VudGVyKys7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHJvdW5kczogW1xuICAgICAge1xuICAgICAgICByb3VuZE51bWJlcjogMSxcbiAgICAgICAgbWF0Y2hlcyxcbiAgICAgICAgaXNEb3VibGVFbGltaW5hdGlvbjogdHJ1ZSxcbiAgICAgICAgaXNDaGFtcGlvbnNoaXBSb3VuZDogZmFsc2VcbiAgICAgIH1cbiAgICBdLFxuICAgIGN1cnJlbnRSb3VuZDogMSxcbiAgICBlbGltaW5hdGVkVGVhbXM6IFtdLFxuICAgIGNoYW1waW9uc2hpcE1hdGNoZXNQbGF5ZWQ6IDBcbiAgfTtcbn07XG5cbmV4cG9ydCBjb25zdCB1cGRhdGVNYXRjaFNjb3JlID0gKFxuICBtYXRjaDogTWF0Y2gsXG4gIG5ld1Njb3JlOiB7IHRlYW0xU2NvcmU6IG51bWJlcjsgdGVhbTJTY29yZTogbnVtYmVyIH1cbik6IE1hdGNoID0+IHtcbiAgY29uc3QgaXNDb21wbGV0ZWQgPSBuZXdTY29yZS50ZWFtMVNjb3JlICE9PSBuZXdTY29yZS50ZWFtMlNjb3JlO1xuICBsZXQgd2lubmVyOiBUZWFtIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuICBsZXQgbG9zZXI6IFRlYW0gfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG4gIGlmIChpc0NvbXBsZXRlZCkge1xuICAgIGlmIChuZXdTY29yZS50ZWFtMVNjb3JlID4gbmV3U2NvcmUudGVhbTJTY29yZSkge1xuICAgICAgd2lubmVyID0gbWF0Y2gudGVhbTFcbiAgICAgICAgPyB7XG4gICAgICAgICAgICAuLi5tYXRjaC50ZWFtMSxcbiAgICAgICAgICAgIHdpbnM6IChtYXRjaC50ZWFtMS53aW5zID8/IDApICsgMSxcbiAgICAgICAgICAgIGxvc3NlczogbWF0Y2gudGVhbTEubG9zc2VzID8/IDBcbiAgICAgICAgICB9XG4gICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgbG9zZXIgPSBtYXRjaC50ZWFtMlxuICAgICAgICA/IHtcbiAgICAgICAgICAgIC4uLm1hdGNoLnRlYW0yLFxuICAgICAgICAgICAgd2luczogbWF0Y2gudGVhbTIud2lucyA/PyAwLFxuICAgICAgICAgICAgbG9zc2VzOiAobWF0Y2gudGVhbTIubG9zc2VzID8/IDApICsgMVxuICAgICAgICAgIH1cbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdpbm5lciA9IG1hdGNoLnRlYW0yXG4gICAgICAgID8ge1xuICAgICAgICAgICAgLi4ubWF0Y2gudGVhbTIsXG4gICAgICAgICAgICB3aW5zOiAobWF0Y2gudGVhbTIud2lucyA/PyAwKSArIDEsXG4gICAgICAgICAgICBsb3NzZXM6IG1hdGNoLnRlYW0yLmxvc3NlcyA/PyAwXG4gICAgICAgICAgfVxuICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgIGxvc2VyID0gbWF0Y2gudGVhbTFcbiAgICAgICAgPyB7XG4gICAgICAgICAgICAuLi5tYXRjaC50ZWFtMSxcbiAgICAgICAgICAgIHdpbnM6IG1hdGNoLnRlYW0xLndpbnMgPz8gMCxcbiAgICAgICAgICAgIGxvc3NlczogKG1hdGNoLnRlYW0xLmxvc3NlcyA/PyAwKSArIDFcbiAgICAgICAgICB9XG4gICAgICAgIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIC4uLm1hdGNoLFxuICAgIHNjb3JlOiBuZXdTY29yZSxcbiAgICBpc0NvbXBsZXRlZCxcbiAgICB3aW5uZXIsXG4gICAgbG9zZXJcbiAgfTtcbn07XG5cbi8vIEhlbHBlciB0byBjcmVhdGUgYSBUQkQgdGVhbVxuZnVuY3Rpb24gY3JlYXRlVEJEVGVhbShzbG90OiBzdHJpbmcpOiBUZWFtIHtcbiAgcmV0dXJuIHtcbiAgICBpZDogYHRiZC0ke3Nsb3R9YCxcbiAgICBuYW1lOiAnVEJEJyxcbiAgICB3aW5zOiAwLFxuICAgIGxvc3NlczogMFxuICB9IGFzIFRlYW07XG59XG5cbi8vIEhlbHBlciB0byBkZWR1cGxpY2F0ZSB0ZWFtcyBieSBJRFxuZnVuY3Rpb24gZGVkdXBlVGVhbXModGVhbXM6IFRlYW1bXSk6IFRlYW1bXSB7XG4gIGNvbnN0IHNlZW4gPSBuZXcgU2V0PHN0cmluZz4oKTtcbiAgcmV0dXJuIHRlYW1zLmZpbHRlcigodGVhbSkgPT4ge1xuICAgIGlmICghdGVhbSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChzZWVuLmhhcyh0ZWFtLmlkKSkgcmV0dXJuIGZhbHNlO1xuICAgIHNlZW4uYWRkKHRlYW0uaWQpO1xuICAgIHJldHVybiB0cnVlO1xuICB9KTtcbn1cblxuLy8gSGVscGVyOiBnZXQgYWxsIHRlYW1zIHdpdGggZXhhY3RseSBOIGxvc3Nlc1xuZnVuY3Rpb24gdGVhbXNXaXRoTG9zc2VzKFxuICBsb3NzQ291bnRzOiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+LFxuICBuOiBudW1iZXJcbik6IHN0cmluZ1tdIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKGxvc3NDb3VudHMpLmZpbHRlcigodGVhbUlkKSA9PiBsb3NzQ291bnRzW3RlYW1JZF0gPT09IG4pO1xufVxuXG5leHBvcnQgY29uc3QgYWR2YW5jZVRvTmV4dFJvdW5kID0gKHRvdXJuYW1lbnQ6IFRvdXJuYW1lbnQpOiBUb3VybmFtZW50ID0+IHtcbiAgY29uc3QgY3VycmVudFJvdW5kID0gdG91cm5hbWVudC5yb3VuZHNbdG91cm5hbWVudC5yb3VuZHMubGVuZ3RoIC0gMV07XG4gIGNvbnN0IG5leHRSb3VuZE51bWJlciA9IHRvdXJuYW1lbnQuY3VycmVudFJvdW5kICsgMTtcblxuICAvLyBUcmFjayBhbGwgbG9zc2VzIGFuZCB3aW5zIGFjcm9zcyB0aGUgdG91cm5hbWVudFxuICBjb25zdCBsb3NzQ291bnRzOiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+ID0ge307XG4gIGNvbnN0IHdpbnNDb3VudHM6IFJlY29yZDxzdHJpbmcsIG51bWJlcj4gPSB7fTtcbiAgdG91cm5hbWVudC5yb3VuZHMuZm9yRWFjaCgocm91bmQpID0+IHtcbiAgICByb3VuZC5tYXRjaGVzLmZvckVhY2goKG1hdGNoKSA9PiB7XG4gICAgICBpZiAobWF0Y2guaXNDb21wbGV0ZWQgJiYgbWF0Y2gubG9zZXIpIHtcbiAgICAgICAgbG9zc0NvdW50c1ttYXRjaC5sb3Nlci5pZF0gPSAobG9zc0NvdW50c1ttYXRjaC5sb3Nlci5pZF0gfHwgMCkgKyAxO1xuICAgICAgfVxuICAgICAgaWYgKG1hdGNoLmlzQ29tcGxldGVkICYmIG1hdGNoLndpbm5lcikge1xuICAgICAgICB3aW5zQ291bnRzW21hdGNoLndpbm5lci5pZF0gPSAod2luc0NvdW50c1ttYXRjaC53aW5uZXIuaWRdIHx8IDApICsgMTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG5cbiAgLy8gR2F0aGVyIGFsbCB0ZWFtcyBldmVyIGluIHRoZSB0b3VybmFtZW50LCBhdHRhY2hpbmcgd2lucy9sb3NzZXNcbiAgY29uc3QgYWxsVGVhbXM6IFRlYW1bXSA9IFtdO1xuICBjb25zdCB0ZWFtSWRzID0gbmV3IFNldDxzdHJpbmc+KCk7XG4gIGZvciAoY29uc3Qgcm91bmQgb2YgdG91cm5hbWVudC5yb3VuZHMpIHtcbiAgICBmb3IgKGNvbnN0IG1hdGNoIG9mIHJvdW5kLm1hdGNoZXMpIHtcbiAgICAgIGlmIChtYXRjaC50ZWFtMSAmJiAhdGVhbUlkcy5oYXMobWF0Y2gudGVhbTEuaWQpKSB7XG4gICAgICAgIGFsbFRlYW1zLnB1c2goe1xuICAgICAgICAgIC4uLm1hdGNoLnRlYW0xLFxuICAgICAgICAgIHdpbnM6IHdpbnNDb3VudHNbbWF0Y2gudGVhbTEuaWRdIHx8IDAsXG4gICAgICAgICAgbG9zc2VzOiBsb3NzQ291bnRzW21hdGNoLnRlYW0xLmlkXSB8fCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0ZWFtSWRzLmFkZChtYXRjaC50ZWFtMS5pZCk7XG4gICAgICB9XG4gICAgICBpZiAobWF0Y2gudGVhbTIgJiYgIXRlYW1JZHMuaGFzKG1hdGNoLnRlYW0yLmlkKSkge1xuICAgICAgICBhbGxUZWFtcy5wdXNoKHtcbiAgICAgICAgICAuLi5tYXRjaC50ZWFtMixcbiAgICAgICAgICB3aW5zOiB3aW5zQ291bnRzW21hdGNoLnRlYW0yLmlkXSB8fCAwLFxuICAgICAgICAgIGxvc3NlczogbG9zc0NvdW50c1ttYXRjaC50ZWFtMi5pZF0gfHwgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGVhbUlkcy5hZGQobWF0Y2gudGVhbTIuaWQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIElkZW50aWZ5IG5ld2x5IGVsaW1pbmF0ZWQgdGVhbXMgKDIgbG9zc2VzKVxuICBjb25zdCBuZXdseUVsaW1pbmF0ZWQ6IFRlYW1bXSA9IFtdO1xuICBmb3IgKGNvbnN0IHRlYW0gb2YgYWxsVGVhbXMpIHtcbiAgICBpZiAoXG4gICAgICAobG9zc0NvdW50c1t0ZWFtLmlkXSB8fCAwKSA+PSAyICYmXG4gICAgICAhdG91cm5hbWVudC5lbGltaW5hdGVkVGVhbXMuc29tZSgodCkgPT4gdC5pZCA9PT0gdGVhbS5pZClcbiAgICApIHtcbiAgICAgIG5ld2x5RWxpbWluYXRlZC5wdXNoKHRlYW0pO1xuICAgIH1cbiAgfVxuXG4gIC8vIFdpbm5lcnM6IHRlYW1zIHdpdGggMCBsb3NzZXMgYW5kIG5vdCBlbGltaW5hdGVkXG4gIGNvbnN0IHdpbm5lcnNCcmFja2V0VGVhbXMgPSBhbGxUZWFtc1xuICAgIC5maWx0ZXIoXG4gICAgICAodGVhbSkgPT5cbiAgICAgICAgKGxvc3NDb3VudHNbdGVhbS5pZF0gfHwgMCkgPT09IDAgJiZcbiAgICAgICAgIXRvdXJuYW1lbnQuZWxpbWluYXRlZFRlYW1zLnNvbWUoKHQpID0+IHQuaWQgPT09IHRlYW0uaWQpICYmXG4gICAgICAgICFuZXdseUVsaW1pbmF0ZWQuc29tZSgodCkgPT4gdC5pZCA9PT0gdGVhbS5pZClcbiAgICApXG4gICAgLm1hcCgodGVhbSkgPT4gKHtcbiAgICAgIC4uLnRlYW0sXG4gICAgICBsb3NzZXM6IGxvc3NDb3VudHNbdGVhbS5pZF0gfHwgMCxcbiAgICAgIHdpbnM6IHdpbnNDb3VudHNbdGVhbS5pZF0gfHwgMFxuICAgIH0pKTtcblxuICAvLyBMb3NlcnM6IHRlYW1zIHdpdGggMSBsb3NzIGFuZCBub3QgZWxpbWluYXRlZFxuICBjb25zdCBsb3NlcnNCcmFja2V0VGVhbXMgPSBhbGxUZWFtc1xuICAgIC5maWx0ZXIoXG4gICAgICAodGVhbSkgPT5cbiAgICAgICAgKGxvc3NDb3VudHNbdGVhbS5pZF0gfHwgMCkgPT09IDEgJiZcbiAgICAgICAgIXRvdXJuYW1lbnQuZWxpbWluYXRlZFRlYW1zLnNvbWUoKHQpID0+IHQuaWQgPT09IHRlYW0uaWQpICYmXG4gICAgICAgICFuZXdseUVsaW1pbmF0ZWQuc29tZSgodCkgPT4gdC5pZCA9PT0gdGVhbS5pZClcbiAgICApXG4gICAgLm1hcCgodGVhbSkgPT4gKHtcbiAgICAgIC4uLnRlYW0sXG4gICAgICBsb3NzZXM6IGxvc3NDb3VudHNbdGVhbS5pZF0gfHwgMCxcbiAgICAgIHdpbnM6IHdpbnNDb3VudHNbdGVhbS5pZF0gfHwgMFxuICAgIH0pKTtcblxuICBsZXQgaXNDaGFtcGlvbnNoaXBSb3VuZCA9IGZhbHNlO1xuICBsZXQgY2hhbXBpb25zaGlwTWF0Y2hlczogTWF0Y2hbXSA9IFtdO1xuICBsZXQgbmV4dFJvdW5kTWF0Y2hlczogTWF0Y2hbXSA9IFtdO1xuXG4gIGNvbnN0IHByZXZDaGFtcGlvbnNoaXBNYXRjaGVzID0gdG91cm5hbWVudC5yb3VuZHNcbiAgICAuZmlsdGVyKChyKSA9PiByLmlzQ2hhbXBpb25zaGlwUm91bmQpXG4gICAgLmZsYXRNYXAoKHIpID0+IHIubWF0Y2hlcylcbiAgICAuZmlsdGVyKChtKSA9PiBtLmJyYWNrZXQgPT09IFwiY2hhbXBpb25zaGlwXCIpO1xuXG4gIC8vIC0tLSBDSEFNUElPTlNISVAgTE9HSUMgLS0tXG4gIC8vIElmIGEgY2hhbXBpb25zaGlwIG1hdGNoIGhhcyBiZWVuIHBsYXllZCBhbmQgY29tcGxldGVkLCBjaGVjayBpZiByZXNldCBpcyBuZWVkZWRcbiAgaWYgKFxuICAgIHByZXZDaGFtcGlvbnNoaXBNYXRjaGVzLmxlbmd0aCA+PSAxICYmXG4gICAgcHJldkNoYW1waW9uc2hpcE1hdGNoZXNbcHJldkNoYW1waW9uc2hpcE1hdGNoZXMubGVuZ3RoIC0gMV0uaXNDb21wbGV0ZWRcbiAgKSB7XG4gICAgY29uc3QgbGFzdENoYW1wTWF0Y2ggPVxuICAgICAgcHJldkNoYW1waW9uc2hpcE1hdGNoZXNbcHJldkNoYW1waW9uc2hpcE1hdGNoZXMubGVuZ3RoIC0gMV07XG4gICAgY29uc3Qgd2lubmVyc0JyYWNrZXRUZWFtID0gbGFzdENoYW1wTWF0Y2gudGVhbTE7XG4gICAgY29uc3QgbG9zZXJzQnJhY2tldFRlYW0gPSBsYXN0Q2hhbXBNYXRjaC50ZWFtMjtcblxuICAgIC8vIElmIGxvc2VyJ3MgYnJhY2tldCB0ZWFtIHdvbiB0aGUgZmlyc3QgY2hhbXBpb25zaGlwIG1hdGNoLCBzY2hlZHVsZSBhIHJlc2V0XG4gICAgaWYgKFxuICAgICAgbGFzdENoYW1wTWF0Y2gud2lubmVyPy5pZCA9PT0gbG9zZXJzQnJhY2tldFRlYW0/LmlkICYmXG4gICAgICB0b3VybmFtZW50LmNoYW1waW9uc2hpcE1hdGNoZXNQbGF5ZWQgPT09IDFcbiAgICApIHtcbiAgICAgIGlzQ2hhbXBpb25zaGlwUm91bmQgPSB0cnVlO1xuICAgICAgY2hhbXBpb25zaGlwTWF0Y2hlcy5wdXNoKFxuICAgICAgICBjcmVhdGVNYXRjaChcbiAgICAgICAgICBgQyR7bmV4dFJvdW5kTnVtYmVyfS0yYCxcbiAgICAgICAgICBuZXh0Um91bmROdW1iZXIsXG4gICAgICAgICAgd2lubmVyc0JyYWNrZXRUZWFtLFxuICAgICAgICAgIGxvc2Vyc0JyYWNrZXRUZWFtLFxuICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgIFwiY2hhbXBpb25zaGlwXCJcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQ2hhbXBpb25zaGlwIGlzIG92ZXIsIHdpbm5lciB3aWxsIGJlIHNldCBiZWxvd1xuICAgICAgaXNDaGFtcGlvbnNoaXBSb3VuZCA9IHRydWU7XG4gICAgfVxuICB9XG4gIC8vIElmIHdlJ3JlIHJlYWR5IGZvciB0aGUgZmlyc3QgY2hhbXBpb25zaGlwIG1hdGNoIChvbmUgdGVhbSBpbiBlYWNoIGJyYWNrZXQsIGxvc2VyJ3MgYnJhY2tldCBmaW5hbCBjb21wbGV0ZSlcbiAgZWxzZSBpZiAoXG4gICAgd2lubmVyc0JyYWNrZXRUZWFtcy5sZW5ndGggPT09IDEgJiZcbiAgICBsb3NlcnNCcmFja2V0VGVhbXMubGVuZ3RoID09PSAxICYmXG4gICAgY3VycmVudFJvdW5kLm1hdGNoZXMuc29tZShcbiAgICAgIChtKSA9PlxuICAgICAgICAobS5icmFja2V0ID09PSBcImxvc2Vyc1wiIHx8IG0uaWQuaW5jbHVkZXMoXCJMb3NlcnNMYXN0XCIpKSAmJlxuICAgICAgICBtLmlzQ29tcGxldGVkICYmXG4gICAgICAgIG0ud2lubmVyICYmXG4gICAgICAgIGxvc2Vyc0JyYWNrZXRUZWFtcy5zb21lKCh0KSA9PiB0LmlkID09PSBtLndpbm5lciEuaWQpXG4gICAgKVxuICApIHtcbiAgICBpc0NoYW1waW9uc2hpcFJvdW5kID0gdHJ1ZTtcbiAgICBjaGFtcGlvbnNoaXBNYXRjaGVzLnB1c2goXG4gICAgICBjcmVhdGVNYXRjaChcbiAgICAgICAgYEMke25leHRSb3VuZE51bWJlcn0tMWAsXG4gICAgICAgIG5leHRSb3VuZE51bWJlcixcbiAgICAgICAgd2lubmVyc0JyYWNrZXRUZWFtc1swXSxcbiAgICAgICAgbG9zZXJzQnJhY2tldFRlYW1zWzBdLFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgXCJjaGFtcGlvbnNoaXBcIlxuICAgICAgKVxuICAgICk7XG4gIH0gZWxzZSBpZiAoXG4gICAgd2lubmVyc0JyYWNrZXRUZWFtcy5sZW5ndGggPT09IDEgJiZcbiAgICBsb3NlcnNCcmFja2V0VGVhbXMubGVuZ3RoID09PSAwICYmXG4gICAgLy8gVGhlIGxvc2VycyBicmFja2V0IGNoYW1waW9uIGlzIG5vdCB5ZXQgZGV0ZXJtaW5lZCwgYnV0IFdCIGNoYW1wIGlzIHdhaXRpbmdcbiAgICBjdXJyZW50Um91bmQubWF0Y2hlcy5zb21lKFxuICAgICAgKG0pID0+IG0uYnJhY2tldCA9PT0gXCJsb3NlcnNcIiAmJiAhbS5pc0NvbXBsZXRlZFxuICAgIClcbiAgKSB7XG4gICAgLy8gSW5zZXJ0IGEgVEJEIGNhcmQgZm9yIHRoZSBjaGFtcGlvbnNoaXAgb3Bwb25lbnRcbiAgICBpc0NoYW1waW9uc2hpcFJvdW5kID0gdHJ1ZTtcbiAgICBjaGFtcGlvbnNoaXBNYXRjaGVzLnB1c2goXG4gICAgICBjcmVhdGVNYXRjaChcbiAgICAgICAgYEMke25leHRSb3VuZE51bWJlcn0tdGJkYCxcbiAgICAgICAgbmV4dFJvdW5kTnVtYmVyLFxuICAgICAgICB3aW5uZXJzQnJhY2tldFRlYW1zWzBdLFxuICAgICAgICBjcmVhdGVUQkRUZWFtKGBjaGFtcGlvbnNoaXAtJHtuZXh0Um91bmROdW1iZXJ9YCksXG4gICAgICAgIHRydWUsXG4gICAgICAgIFwiY2hhbXBpb25zaGlwXCJcbiAgICAgIClcbiAgICApO1xuICB9XG4gIC8vIElmIHRoZSB3aW5uZXIncyBicmFja2V0IGZpbmFsIGxvc2VyIG5lZWRzIHRvIHBsYXkgdGhlIGxvc2VyJ3MgYnJhY2tldCB3aW5uZXJcbiAgZWxzZSBpZiAoXG4gICAgd2lubmVyc0JyYWNrZXRUZWFtcy5sZW5ndGggPT09IDEgJiZcbiAgICBsb3NlcnNCcmFja2V0VGVhbXMubGVuZ3RoID49IDEgJiZcbiAgICB0b3VybmFtZW50Lndpbm5lcnNCcmFja2V0RmluYWxMb3NlclxuICApIHtcbiAgICBjb25zdCBsb3NlcnNCcmFja2V0V2lubmVyID0gY3VycmVudFJvdW5kLm1hdGNoZXNcbiAgICAgIC5maWx0ZXIoKG0pID0+IG0uYnJhY2tldCA9PT0gXCJsb3NlcnNcIiAmJiBtLmlzQ29tcGxldGVkICYmIG0ud2lubmVyKVxuICAgICAgLm1hcCgobSkgPT4gbS53aW5uZXIhKVxuICAgICAgLmZpbmQoKHdpbm5lcikgPT4gbG9zZXJzQnJhY2tldFRlYW1zLnNvbWUoKHQpID0+IHQuaWQgPT09IHdpbm5lci5pZCkpO1xuXG4gICAgaWYgKFxuICAgICAgbG9zZXJzQnJhY2tldFdpbm5lciAmJlxuICAgICAgbG9zZXJzQnJhY2tldFdpbm5lci5pZCAhPT0gdG91cm5hbWVudC53aW5uZXJzQnJhY2tldEZpbmFsTG9zZXIuaWRcbiAgICApIHtcbiAgICAgIG5leHRSb3VuZE1hdGNoZXMucHVzaChcbiAgICAgICAgY3JlYXRlTWF0Y2goXG4gICAgICAgICAgYExvc2Vyc0xhc3QtJHtuZXh0Um91bmROdW1iZXJ9YCxcbiAgICAgICAgICBuZXh0Um91bmROdW1iZXIsXG4gICAgICAgICAgdG91cm5hbWVudC53aW5uZXJzQnJhY2tldEZpbmFsTG9zZXIsXG4gICAgICAgICAgbG9zZXJzQnJhY2tldFdpbm5lcixcbiAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICBcImxvc2Vyc1wiXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEluc2VydCBhIFRCRCBjYXJkIGZvciB0aGUgb3Bwb25lbnQgaWYgb25seSBvbmUgc2lkZSBpcyBrbm93biAodGhlIFdCIEZpbmFsIExvc2VyKVxuICAgICAgaWYgKHRvdXJuYW1lbnQud2lubmVyc0JyYWNrZXRGaW5hbExvc2VyICYmIGxvc2Vyc0JyYWNrZXRUZWFtcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgbmV4dFJvdW5kTWF0Y2hlcy5wdXNoKFxuICAgICAgICAgIGNyZWF0ZU1hdGNoKFxuICAgICAgICAgICAgYExvc2Vyc0xhc3QtJHtuZXh0Um91bmROdW1iZXJ9YCxcbiAgICAgICAgICAgIG5leHRSb3VuZE51bWJlcixcbiAgICAgICAgICAgIHRvdXJuYW1lbnQud2lubmVyc0JyYWNrZXRGaW5hbExvc2VyLFxuICAgICAgICAgICAgY3JlYXRlVEJEVGVhbShgbG9zZXJzLSR7bmV4dFJvdW5kTnVtYmVyfWApLFxuICAgICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAgIFwibG9zZXJzXCJcbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBjcmVhdGVTdGFuZGFyZEJyYWNrZXRNYXRjaGVzKCk7XG4gICAgfVxuICB9XG4gIC8vIElmIHRoaXMgaXMgdGhlIHdpbm5lcidzIGJyYWNrZXQgZmluYWwgKGV4YWN0bHkgMiB0ZWFtcyBpbiB3aW5uZXIncyBicmFja2V0KVxuICBlbHNlIGlmICh3aW5uZXJzQnJhY2tldFRlYW1zLmxlbmd0aCA9PT0gMiAmJiBsb3NlcnNCcmFja2V0VGVhbXMubGVuZ3RoID49IDEpIHtcbiAgICBuZXh0Um91bmRNYXRjaGVzLnB1c2goXG4gICAgICBjcmVhdGVNYXRjaChcbiAgICAgICAgYFcke25leHRSb3VuZE51bWJlcn0tMWAsXG4gICAgICAgIG5leHRSb3VuZE51bWJlcixcbiAgICAgICAgd2lubmVyc0JyYWNrZXRUZWFtc1swXSxcbiAgICAgICAgd2lubmVyc0JyYWNrZXRUZWFtc1sxXSxcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIFwid2lubmVyc1wiXG4gICAgICApXG4gICAgKTtcbiAgICBjcmVhdGVMb3NlcnNCcmFja2V0TWF0Y2hlcygpO1xuICB9XG4gIC8vIE90aGVyd2lzZSwgY29udGludWUgd2l0aCBzdGFuZGFyZCBicmFja2V0IHBsYXlcbiAgZWxzZSB7XG4gICAgY3JlYXRlU3RhbmRhcmRCcmFja2V0TWF0Y2hlcygpO1xuICB9XG5cbiAgLy8gLS0tIEhlbHBlcjogU3RhbmRhcmQgV2lubmVycyBCcmFja2V0IE1hdGNoZXMgLS0tXG4gIGZ1bmN0aW9uIGNyZWF0ZVN0YW5kYXJkQnJhY2tldE1hdGNoZXMoKSB7XG4gICAgbGV0IG1hdGNoQ291bnRlciA9IDE7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB3aW5uZXJzQnJhY2tldFRlYW1zLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICBjb25zdCB0ZWFtMSA9IHdpbm5lcnNCcmFja2V0VGVhbXNbaV07XG4gICAgICBjb25zdCB0ZWFtMiA9IHdpbm5lcnNCcmFja2V0VGVhbXNbaSArIDFdID8/IG51bGw7XG4gICAgICBjb25zdCBpc0J5ZSA9ICF0ZWFtMjtcbiAgICAgIG5leHRSb3VuZE1hdGNoZXMucHVzaChcbiAgICAgICAgY3JlYXRlTWF0Y2goXG4gICAgICAgICAgYFcke25leHRSb3VuZE51bWJlcn0tJHttYXRjaENvdW50ZXJ9YCxcbiAgICAgICAgICBuZXh0Um91bmROdW1iZXIsXG4gICAgICAgICAgdGVhbTEsXG4gICAgICAgICAgdGVhbTIsXG4gICAgICAgICAgaXNCeWUsXG4gICAgICAgICAgXCJ3aW5uZXJzXCJcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICAgIG1hdGNoQ291bnRlcisrO1xuICAgIH1cbiAgICBjcmVhdGVMb3NlcnNCcmFja2V0TWF0Y2hlcygpO1xuICB9XG5cbiAgLy8gLS0tIEhlbHBlcjogTG9zZXJzIEJyYWNrZXQgTWF0Y2hlcyAtLS1cbiAgZnVuY3Rpb24gY3JlYXRlTG9zZXJzQnJhY2tldE1hdGNoZXMoKSB7XG4gICAgY29uc3QgZWxpZ2libGVMb3NlcnMgPSBhbGxUZWFtcy5maWx0ZXIoXG4gICAgICAodGVhbSkgPT5cbiAgICAgICAgKGxvc3NDb3VudHNbdGVhbS5pZF0gfHwgMCkgPT09IDEgJiZcbiAgICAgICAgIXRvdXJuYW1lbnQuZWxpbWluYXRlZFRlYW1zLnNvbWUoKHQpID0+IHQuaWQgPT09IHRlYW0uaWQpICYmXG4gICAgICAgICFuZXdseUVsaW1pbmF0ZWQuc29tZSgodCkgPT4gdC5pZCA9PT0gdGVhbS5pZCkgJiZcbiAgICAgICAgISh0b3VybmFtZW50Lndpbm5lcnNCcmFja2V0RmluYWxMb3NlciAmJiB0b3VybmFtZW50Lndpbm5lcnNCcmFja2V0RmluYWxMb3Nlci5pZCA9PT0gdGVhbS5pZClcbiAgICApO1xuICAgIGNvbnN0IGp1c3REcm9wcGVkRnJvbVdpbm5lcnMgPSBjdXJyZW50Um91bmQubWF0Y2hlc1xuICAgICAgLmZpbHRlcigobSkgPT4gbS5icmFja2V0ID09PSBcIndpbm5lcnNcIiAmJiBtLmxvc2VyICYmIG0uaXNDb21wbGV0ZWQpXG4gICAgICAubWFwKChtKSA9PiBtLmxvc2VyISlcbiAgICAgIC5maWx0ZXIoKGxvc2VyKSA9PiBlbGlnaWJsZUxvc2Vycy5zb21lKCh0KSA9PiB0LmlkID09PSBsb3Nlci5pZCkpO1xuICAgIC8vIElmIHRoaXMgaXMgdGhlIHdpbm5lcidzIGJyYWNrZXQgZmluYWwsIHN0b3JlIHRoZSBsb3NlciBmb3IgbGF0ZXIgdXNlXG4gICAgaWYgKFxuICAgICAgY3VycmVudFJvdW5kLm1hdGNoZXMuc29tZShcbiAgICAgICAgKG0pID0+XG4gICAgICAgICAgbS5icmFja2V0ID09PSBcIndpbm5lcnNcIiAmJlxuICAgICAgICAgIHdpbm5lcnNCcmFja2V0VGVhbXMubGVuZ3RoID09PSAxICYmXG4gICAgICAgICAgbS5sb3NlciAmJlxuICAgICAgICAgIG0uaXNDb21wbGV0ZWRcbiAgICAgIClcbiAgICApIHtcbiAgICAgIGNvbnN0IHdpbm5lcnNGaW5hbExvc2VyID0gY3VycmVudFJvdW5kLm1hdGNoZXNcbiAgICAgICAgLmZpbHRlcigobSkgPT4gbS5icmFja2V0ID09PSBcIndpbm5lcnNcIiAmJiBtLmlzQ29tcGxldGVkICYmIG0ubG9zZXIpXG4gICAgICAgIC5tYXAoKG0pID0+IG0ubG9zZXIhKVxuICAgICAgICAucG9wKCk7XG4gICAgICBpZiAod2lubmVyc0ZpbmFsTG9zZXIpIHtcbiAgICAgICAgdG91cm5hbWVudC53aW5uZXJzQnJhY2tldEZpbmFsTG9zZXIgPSB3aW5uZXJzRmluYWxMb3NlcjtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZXhpc3RpbmdMb3NlcnMgPSBlbGlnaWJsZUxvc2Vycy5maWx0ZXIoXG4gICAgICAodCkgPT4gIWp1c3REcm9wcGVkRnJvbVdpbm5lcnMuc29tZSgoamQpID0+IGpkLmlkID09PSB0LmlkKVxuICAgICk7XG4gICAgY29uc3Qgb3JkZXJlZExvc2VycyA9IFsuLi5qdXN0RHJvcHBlZEZyb21XaW5uZXJzLCAuLi5leGlzdGluZ0xvc2Vyc107XG4gICAgaWYgKG9yZGVyZWRMb3NlcnMubGVuZ3RoID4gMCkge1xuICAgICAgaWYgKG9yZGVyZWRMb3NlcnMubGVuZ3RoICUgMiA9PT0gMSkge1xuICAgICAgICBsZXQgdGVhbVdpdGhCeWU6IFRlYW0gfCBudWxsID0gbnVsbDtcbiAgICAgICAgaWYgKGp1c3REcm9wcGVkRnJvbVdpbm5lcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHRlYW1XaXRoQnllID0ganVzdERyb3BwZWRGcm9tV2lubmVyc1tqdXN0RHJvcHBlZEZyb21XaW5uZXJzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgIGNvbnN0IGJ5ZUluZGV4ID0gb3JkZXJlZExvc2Vycy5maW5kSW5kZXgoKHQpID0+IHQuaWQgPT09IHRlYW1XaXRoQnllIS5pZCk7XG4gICAgICAgICAgaWYgKGJ5ZUluZGV4ICE9PSAtMSkgb3JkZXJlZExvc2Vycy5zcGxpY2UoYnllSW5kZXgsIDEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRlYW1XaXRoQnllID0gb3JkZXJlZExvc2Vycy5zaGlmdCgpITtcbiAgICAgICAgfVxuICAgICAgICBuZXh0Um91bmRNYXRjaGVzLnB1c2goXG4gICAgICAgICAgY3JlYXRlTWF0Y2goXG4gICAgICAgICAgICBgTCR7bmV4dFJvdW5kTnVtYmVyfS0xYCxcbiAgICAgICAgICAgIG5leHRSb3VuZE51bWJlcixcbiAgICAgICAgICAgIHRlYW1XaXRoQnllLFxuICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgIHRydWUsXG4gICAgICAgICAgICBcImxvc2Vyc1wiXG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9yZGVyZWRMb3NlcnMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICBjb25zdCB0ZWFtMSA9IG9yZGVyZWRMb3NlcnNbaV07XG4gICAgICAgICAgY29uc3QgdGVhbTIgPSBvcmRlcmVkTG9zZXJzW2kgKyAxXSA/PyBudWxsO1xuICAgICAgICAgIG5leHRSb3VuZE1hdGNoZXMucHVzaChcbiAgICAgICAgICAgIGNyZWF0ZU1hdGNoKFxuICAgICAgICAgICAgICBgTCR7bmV4dFJvdW5kTnVtYmVyfS0ke01hdGguZmxvb3IoaSAvIDIpICsgMn1gLFxuICAgICAgICAgICAgICBuZXh0Um91bmROdW1iZXIsXG4gICAgICAgICAgICAgIHRlYW0xLFxuICAgICAgICAgICAgICB0ZWFtMixcbiAgICAgICAgICAgICAgIXRlYW0yLFxuICAgICAgICAgICAgICBcImxvc2Vyc1wiXG4gICAgICAgICAgICApXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvcmRlcmVkTG9zZXJzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgY29uc3QgdGVhbTEgPSBvcmRlcmVkTG9zZXJzW2ldO1xuICAgICAgICAgIGNvbnN0IHRlYW0yID0gb3JkZXJlZExvc2Vyc1tpICsgMV0gPz8gbnVsbDtcbiAgICAgICAgICBuZXh0Um91bmRNYXRjaGVzLnB1c2goXG4gICAgICAgICAgICBjcmVhdGVNYXRjaChcbiAgICAgICAgICAgICAgYEwke25leHRSb3VuZE51bWJlcn0tJHtNYXRoLmZsb29yKGkgLyAyKSArIDF9YCxcbiAgICAgICAgICAgICAgbmV4dFJvdW5kTnVtYmVyLFxuICAgICAgICAgICAgICB0ZWFtMSxcbiAgICAgICAgICAgICAgdGVhbTIsXG4gICAgICAgICAgICAgICF0ZWFtMixcbiAgICAgICAgICAgICAgXCJsb3NlcnNcIlxuICAgICAgICAgICAgKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyAtLS0gV2lubmVyIGRldGVjdGlvbiBsb2dpYyAtLS1cbiAgbGV0IHdpbm5lcjogVGVhbSB8IHVuZGVmaW5lZCA9IHRvdXJuYW1lbnQud2lubmVyO1xuICBpZiAoaXNDaGFtcGlvbnNoaXBSb3VuZCkge1xuICAgIGNvbnN0IGxhc3RDaGFtcE1hdGNoID1cbiAgICAgIGNoYW1waW9uc2hpcE1hdGNoZXNbMF0gfHxcbiAgICAgIHByZXZDaGFtcGlvbnNoaXBNYXRjaGVzW3ByZXZDaGFtcGlvbnNoaXBNYXRjaGVzLmxlbmd0aCAtIDFdO1xuICAgIGlmIChcbiAgICAgIGxhc3RDaGFtcE1hdGNoICYmXG4gICAgICBsYXN0Q2hhbXBNYXRjaC5pc0NvbXBsZXRlZCAmJlxuICAgICAgbGFzdENoYW1wTWF0Y2gud2lubmVyICYmXG4gICAgICBsYXN0Q2hhbXBNYXRjaC5sb3NlclxuICAgICkge1xuICAgICAgY29uc3Qgd2lubmVyc0JyYWNrZXRUZWFtID0gbGFzdENoYW1wTWF0Y2gudGVhbTE7XG4gICAgICBjb25zdCBsb3NlcnNCcmFja2V0VGVhbSA9IGxhc3RDaGFtcE1hdGNoLnRlYW0yO1xuICAgICAgY29uc3QgbG9zZXJzQnJhY2tldFRlYW1Xb24gPVxuICAgICAgICBsb3NlcnNCcmFja2V0VGVhbSAmJiBsYXN0Q2hhbXBNYXRjaC53aW5uZXIuaWQgPT09IGxvc2Vyc0JyYWNrZXRUZWFtLmlkO1xuICAgICAgaWYgKGxvc2Vyc0JyYWNrZXRUZWFtV29uICYmIHRvdXJuYW1lbnQuY2hhbXBpb25zaGlwTWF0Y2hlc1BsYXllZCA9PT0gMSkge1xuICAgICAgICB3aW5uZXIgPSB1bmRlZmluZWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3aW5uZXIgPSBsYXN0Q2hhbXBNYXRjaC53aW5uZXI7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gLS0tIElORklOSVRFIFJFQ1VSU0lPTiBHVUFSRCAtLS1cbiAgY29uc3Qgbm9Nb3JlTWF0Y2hlcyA9XG4gICAgKGlzQ2hhbXBpb25zaGlwUm91bmQgJiYgY2hhbXBpb25zaGlwTWF0Y2hlcy5sZW5ndGggPT09IDApIHx8XG4gICAgKCFpc0NoYW1waW9uc2hpcFJvdW5kICYmIG5leHRSb3VuZE1hdGNoZXMubGVuZ3RoID09PSAwKTtcbiAgaWYgKG5vTW9yZU1hdGNoZXMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4udG91cm5hbWVudCxcbiAgICAgIHdpbm5lcixcbiAgICAgIGN1cnJlbnRSb3VuZDogdG91cm5hbWVudC5jdXJyZW50Um91bmRcbiAgICB9O1xuICB9XG5cbiAgLy8gLS0tIENvbXBvc2UgbmV3IHRvdXJuYW1lbnQgb2JqZWN0IC0tLVxuICByZXR1cm4ge1xuICAgIC4uLnRvdXJuYW1lbnQsXG4gICAgcm91bmRzOiBbXG4gICAgICAuLi50b3VybmFtZW50LnJvdW5kcyxcbiAgICAgIHtcbiAgICAgICAgcm91bmROdW1iZXI6IG5leHRSb3VuZE51bWJlcixcbiAgICAgICAgbWF0Y2hlczogaXNDaGFtcGlvbnNoaXBSb3VuZCA/IGNoYW1waW9uc2hpcE1hdGNoZXMgOiBuZXh0Um91bmRNYXRjaGVzLFxuICAgICAgICBpc0RvdWJsZUVsaW1pbmF0aW9uOiB0cnVlLFxuICAgICAgICBpc0NoYW1waW9uc2hpcFJvdW5kXG4gICAgICB9XG4gICAgXSxcbiAgICBjdXJyZW50Um91bmQ6IG5leHRSb3VuZE51bWJlcixcbiAgICBlbGltaW5hdGVkVGVhbXM6IFtcbiAgICAgIC4uLnRvdXJuYW1lbnQuZWxpbWluYXRlZFRlYW1zLFxuICAgICAgLi4ubmV3bHlFbGltaW5hdGVkLmZpbHRlcihcbiAgICAgICAgKHQpID0+ICF0b3VybmFtZW50LmVsaW1pbmF0ZWRUZWFtcy5zb21lKChldCkgPT4gZXQuaWQgPT09IHQuaWQpXG4gICAgICApXG4gICAgXSxcbiAgICBjaGFtcGlvbnNoaXBNYXRjaGVzUGxheWVkOiBpc0NoYW1waW9uc2hpcFJvdW5kXG4gICAgICA/IHRvdXJuYW1lbnQuY2hhbXBpb25zaGlwTWF0Y2hlc1BsYXllZCArIDFcbiAgICAgIDogdG91cm5hbWVudC5jaGFtcGlvbnNoaXBNYXRjaGVzUGxheWVkLFxuICAgIHdpbm5lcnNCcmFja2V0RmluYWxMb3NlcjogdG91cm5hbWVudC53aW5uZXJzQnJhY2tldEZpbmFsTG9zZXIsXG4gICAgd2lubmVyXG4gIH07XG59O1xuXG4iXSwibmFtZXMiOlsiY3JlYXRlTWF0Y2giLCJpZCIsInJvdW5kTnVtYmVyIiwidGVhbTEiLCJ0ZWFtMiIsImlzQnllIiwiYnJhY2tldCIsIm5leHRNYXRjaElkIiwibmV4dExvc2VyTWF0Y2hJZCIsImlzQ29tcGxldGVkIiwid2lubmVyIiwidW5kZWZpbmVkIiwibG9zZXIiLCJzY29yZSIsInRlYW0xU2NvcmUiLCJ0ZWFtMlNjb3JlIiwiZWxpbWluYXRlZExhYmVsIiwiY3JlYXRlSW5pdGlhbFJvdW5kcyIsInRlYW1zIiwibnVtVGVhbXMiLCJsZW5ndGgiLCJtYXRjaGVzIiwibnVtUm91bmRzIiwiTWF0aCIsImNlaWwiLCJsb2cyIiwiZmlyc3RSb3VuZE1hdGNoZXMiLCJwb3ciLCJtYXRjaENvdW50ZXIiLCJpIiwibWF0Y2hJZCIsInB1c2giLCJyb3VuZHMiLCJpc0RvdWJsZUVsaW1pbmF0aW9uIiwiaXNDaGFtcGlvbnNoaXBSb3VuZCIsImN1cnJlbnRSb3VuZCIsImVsaW1pbmF0ZWRUZWFtcyIsImNoYW1waW9uc2hpcE1hdGNoZXNQbGF5ZWQiLCJ1cGRhdGVNYXRjaFNjb3JlIiwibWF0Y2giLCJuZXdTY29yZSIsIndpbnMiLCJsb3NzZXMiLCJjcmVhdGVUQkRUZWFtIiwic2xvdCIsIm5hbWUiLCJkZWR1cGVUZWFtcyIsInNlZW4iLCJTZXQiLCJmaWx0ZXIiLCJ0ZWFtIiwiaGFzIiwiYWRkIiwidGVhbXNXaXRoTG9zc2VzIiwibG9zc0NvdW50cyIsIm4iLCJPYmplY3QiLCJrZXlzIiwidGVhbUlkIiwiYWR2YW5jZVRvTmV4dFJvdW5kIiwidG91cm5hbWVudCIsIm5leHRSb3VuZE51bWJlciIsIndpbnNDb3VudHMiLCJmb3JFYWNoIiwicm91bmQiLCJhbGxUZWFtcyIsInRlYW1JZHMiLCJuZXdseUVsaW1pbmF0ZWQiLCJzb21lIiwidCIsIndpbm5lcnNCcmFja2V0VGVhbXMiLCJtYXAiLCJsb3NlcnNCcmFja2V0VGVhbXMiLCJjaGFtcGlvbnNoaXBNYXRjaGVzIiwibmV4dFJvdW5kTWF0Y2hlcyIsInByZXZDaGFtcGlvbnNoaXBNYXRjaGVzIiwiciIsImZsYXRNYXAiLCJtIiwibGFzdENoYW1wTWF0Y2giLCJ3aW5uZXJzQnJhY2tldFRlYW0iLCJsb3NlcnNCcmFja2V0VGVhbSIsImluY2x1ZGVzIiwid2lubmVyc0JyYWNrZXRGaW5hbExvc2VyIiwibG9zZXJzQnJhY2tldFdpbm5lciIsImZpbmQiLCJjcmVhdGVTdGFuZGFyZEJyYWNrZXRNYXRjaGVzIiwiY3JlYXRlTG9zZXJzQnJhY2tldE1hdGNoZXMiLCJlbGlnaWJsZUxvc2VycyIsImp1c3REcm9wcGVkRnJvbVdpbm5lcnMiLCJ3aW5uZXJzRmluYWxMb3NlciIsInBvcCIsImV4aXN0aW5nTG9zZXJzIiwiamQiLCJvcmRlcmVkTG9zZXJzIiwidGVhbVdpdGhCeWUiLCJieWVJbmRleCIsImZpbmRJbmRleCIsInNwbGljZSIsInNoaWZ0IiwiZmxvb3IiLCJsb3NlcnNCcmFja2V0VGVhbVdvbiIsIm5vTW9yZU1hdGNoZXMiLCJldCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./types/tournament/matches.ts\n"));

/***/ })

});
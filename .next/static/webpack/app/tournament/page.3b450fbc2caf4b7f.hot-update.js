"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/tournament/page",{

/***/ "(app-pages-browser)/./types/tournament/matches.ts":
/*!*************************************!*\
  !*** ./types/tournament/matches.ts ***!
  \*************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createInitialRounds: function() { return /* binding */ createInitialRounds; },\n/* harmony export */   createMatch: function() { return /* binding */ createMatch; },\n/* harmony export */   updateMatchScore: function() { return /* binding */ updateMatchScore; }\n/* harmony export */ });\nconst createMatch = function(id, roundNumber, team1, team2) {\n    let isBye = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : false, bracket = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : \"winners\", nextMatchId = arguments.length > 6 ? arguments[6] : void 0, nextLoserMatchId = arguments.length > 7 ? arguments[7] : void 0;\n    var _ref;\n    return {\n        id,\n        roundNumber,\n        team1,\n        team2,\n        isCompleted: isBye,\n        isBye,\n        bracket,\n        winner: isBye ? (_ref = team1 !== null && team1 !== void 0 ? team1 : team2) !== null && _ref !== void 0 ? _ref : undefined : undefined,\n        loser: isBye ? undefined : undefined,\n        score: {\n            team1Score: 0,\n            team2Score: 0\n        },\n        nextMatchId,\n        nextLoserMatchId,\n        eliminatedLabel: undefined\n    };\n};\nconst createInitialRounds = (teams)=>{\n    const numTeams = teams.length;\n    const matches = [];\n    const numRounds = Math.ceil(Math.log2(numTeams));\n    const firstRoundMatches = Math.pow(2, numRounds - 1);\n    let matchCounter = 1;\n    for(let i = 0; i < firstRoundMatches; i++){\n        const team1 = teams[i * 2] || null;\n        const team2 = teams[i * 2 + 1] || null;\n        const isBye = !team1 || !team2;\n        const matchId = \"W1-\".concat(matchCounter);\n        const nextMatchId = \"W2-\".concat(Math.ceil(matchCounter / 2));\n        const nextLoserMatchId = \"L1-\".concat(Math.ceil(matchCounter / 2));\n        matches.push(createMatch(matchId, 1, team1, team2, isBye, \"winners\", nextMatchId, nextLoserMatchId));\n        matchCounter++;\n    }\n    return {\n        rounds: [\n            {\n                roundNumber: 1,\n                matches,\n                isDoubleElimination: true,\n                isChampionshipRound: false\n            }\n        ],\n        currentRound: 1,\n        eliminatedTeams: [],\n        championshipMatchesPlayed: 0\n    };\n};\nconst updateMatchScore = (match, newScore)=>{\n    const isCompleted = newScore.team1Score !== newScore.team2Score;\n    let winner = undefined;\n    let loser = undefined;\n    if (isCompleted) {\n        if (newScore.team1Score > newScore.team2Score) {\n            var _match_team1_wins, _match_team1_losses;\n            winner = match.team1 ? {\n                ...match.team1,\n                wins: ((_match_team1_wins = match.team1.wins) !== null && _match_team1_wins !== void 0 ? _match_team1_wins : 0) + 1,\n                losses: (_match_team1_losses = match.team1.losses) !== null && _match_team1_losses !== void 0 ? _match_team1_losses : 0\n            } : undefined;\n            var _match_team2_wins, _match_team2_losses;\n            loser = match.team2 ? {\n                ...match.team2,\n                wins: (_match_team2_wins = match.team2.wins) !== null && _match_team2_wins !== void 0 ? _match_team2_wins : 0,\n                losses: ((_match_team2_losses = match.team2.losses) !== null && _match_team2_losses !== void 0 ? _match_team2_losses : 0) + 1\n            } : undefined;\n        } else {\n            var _match_team2_wins1, _match_team2_losses1;\n            winner = match.team2 ? {\n                ...match.team2,\n                wins: ((_match_team2_wins1 = match.team2.wins) !== null && _match_team2_wins1 !== void 0 ? _match_team2_wins1 : 0) + 1,\n                losses: (_match_team2_losses1 = match.team2.losses) !== null && _match_team2_losses1 !== void 0 ? _match_team2_losses1 : 0\n            } : undefined;\n            var _match_team1_wins1, _match_team1_losses1;\n            loser = match.team1 ? {\n                ...match.team1,\n                wins: (_match_team1_wins1 = match.team1.wins) !== null && _match_team1_wins1 !== void 0 ? _match_team1_wins1 : 0,\n                losses: ((_match_team1_losses1 = match.team1.losses) !== null && _match_team1_losses1 !== void 0 ? _match_team1_losses1 : 0) + 1\n            } : undefined;\n        }\n    }\n    return {\n        ...match,\n        score: newScore,\n        isCompleted,\n        winner,\n        loser\n    };\n};\n// Helper to deduplicate teams by ID\nfunction dedupeTeams(teams) {\n    const seen = new Set();\n    return teams.filter((team)=>{\n        if (!team) return false;\n        if (seen.has(team.id)) return false;\n        seen.add(team.id);\n        return true;\n    });\n}\n// Helper: get all teams with exactly N losses\nfunction teamsWithLosses(lossCounts, n) {\n    return Object.keys(lossCounts).filter((teamId)=>lossCounts[teamId] === n);\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3R5cGVzL3RvdXJuYW1lbnQvbWF0Y2hlcy50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFtQ08sTUFBTUEsY0FBYyxTQUN6QkMsSUFDQUMsYUFDQUMsT0FDQUM7UUFDQUMseUVBQWlCLE9BQ2pCQywyRUFBaUQsV0FDakRDLDREQUNBQztRQVNnQkw7V0FSTDtRQUNYRjtRQUNBQztRQUNBQztRQUNBQztRQUNBSyxhQUFhSjtRQUNiQTtRQUNBQztRQUNBSSxRQUFRTCxRQUFRRixDQUFBQSxPQUFBQSxrQkFBQUEsbUJBQUFBLFFBQVNDLG1CQUFURCxrQkFBQUEsT0FBa0JRLFlBQVlBO1FBQzlDQyxPQUFPUCxRQUFRTSxZQUFZQTtRQUMzQkUsT0FBTztZQUFFQyxZQUFZO1lBQUdDLFlBQVk7UUFBRTtRQUN0Q1I7UUFDQUM7UUFDQVEsaUJBQWlCTDtJQUNuQjtBQUFBLEVBQUc7QUFFSSxNQUFNTSxzQkFBc0IsQ0FBQ0M7SUFDbEMsTUFBTUMsV0FBV0QsTUFBTUUsTUFBTTtJQUM3QixNQUFNQyxVQUFtQixFQUFFO0lBQzNCLE1BQU1DLFlBQVlDLEtBQUtDLElBQUksQ0FBQ0QsS0FBS0UsSUFBSSxDQUFDTjtJQUV0QyxNQUFNTyxvQkFBb0JILEtBQUtJLEdBQUcsQ0FBQyxHQUFHTCxZQUFZO0lBQ2xELElBQUlNLGVBQWU7SUFFbkIsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlILG1CQUFtQkcsSUFBSztRQUMxQyxNQUFNMUIsUUFBUWUsS0FBSyxDQUFDVyxJQUFJLEVBQUUsSUFBSTtRQUM5QixNQUFNekIsUUFBUWMsS0FBSyxDQUFDVyxJQUFJLElBQUksRUFBRSxJQUFJO1FBQ2xDLE1BQU14QixRQUFRLENBQUNGLFNBQVMsQ0FBQ0M7UUFFekIsTUFBTTBCLFVBQVUsTUFBbUIsT0FBYkY7UUFDdEIsTUFBTXJCLGNBQWMsTUFBa0MsT0FBNUJnQixLQUFLQyxJQUFJLENBQUNJLGVBQWU7UUFDbkQsTUFBTXBCLG1CQUFtQixNQUFrQyxPQUE1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LFlBQVlMLE1BQU0sQ0FBQyxDQUFDUyxTQUFXSixVQUFVLENBQUNJLE9BQU8sS0FBS0g7QUFDM0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vdHlwZXMvdG91cm5hbWVudC9tYXRjaGVzLnRzP2RhMjIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUgeyBUZWFtIH0gZnJvbSBcIi4vbWxiLXRlYW1zXCI7XG5cbmV4cG9ydCBpbnRlcmZhY2UgTWF0Y2gge1xuICBpZDogc3RyaW5nO1xuICByb3VuZE51bWJlcjogbnVtYmVyO1xuICB0ZWFtMTogVGVhbSB8IG51bGw7XG4gIHRlYW0yOiBUZWFtIHwgbnVsbDtcbiAgaXNDb21wbGV0ZWQ6IGJvb2xlYW47XG4gIGlzQnllPzogYm9vbGVhbjtcbiAgd2lubmVyPzogVGVhbTtcbiAgbG9zZXI/OiBUZWFtO1xuICBicmFja2V0OiBcIndpbm5lcnNcIiB8IFwibG9zZXJzXCIgfCBcImNoYW1waW9uc2hpcFwiO1xuICBzY29yZTogeyB0ZWFtMVNjb3JlOiBudW1iZXI7IHRlYW0yU2NvcmU6IG51bWJlciB9O1xuICBuZXh0TWF0Y2hJZD86IHN0cmluZztcbiAgbmV4dExvc2VyTWF0Y2hJZD86IHN0cmluZztcbiAgZWxpbWluYXRlZExhYmVsPzogc3RyaW5nOyAvLyBsYWJlbCBmb3IgZWxpbWluYXRlZCB0ZWFtcyBpbiBsb3NlcnMgYnJhY2tldFxuICByZXF1aXJlc1JlbWF0Y2g/OiBib29sZWFuOyAvLyBpbmRpY2F0ZXMgaWYgYSBjaGFtcGlvbnNoaXAgcmVtYXRjaCBpcyByZXF1aXJlZFxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFJvdW5kIHtcbiAgcm91bmROdW1iZXI6IG51bWJlcjtcbiAgbWF0Y2hlczogTWF0Y2hbXTtcbiAgaXNEb3VibGVFbGltaW5hdGlvbjogYm9vbGVhbjtcbiAgaXNDaGFtcGlvbnNoaXBSb3VuZDogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBUb3VybmFtZW50IHtcbiAgcm91bmRzOiBSb3VuZFtdO1xuICBjdXJyZW50Um91bmQ6IG51bWJlcjtcbiAgZWxpbWluYXRlZFRlYW1zOiBUZWFtW107XG4gIGNoYW1waW9uc2hpcE1hdGNoZXNQbGF5ZWQ6IG51bWJlcjtcbiAgd2lubmVyPzogVGVhbTtcbiAgd2lubmVyc0JyYWNrZXRGaW5hbExvc2VyPzogVGVhbTsgLy8gdHJhY2tzIHRoZSB3aW5uZXIncyBicmFja2V0IGZpbmFsIGxvc2VyIGZvciBjaGFtcGlvbnNoaXAgcmVtYXRjaCBsb2dpY1xufVxuXG5leHBvcnQgY29uc3QgY3JlYXRlTWF0Y2ggPSAoXG4gIGlkOiBzdHJpbmcsXG4gIHJvdW5kTnVtYmVyOiBudW1iZXIsXG4gIHRlYW0xOiBUZWFtIHwgbnVsbCxcbiAgdGVhbTI6IFRlYW0gfCBudWxsLFxuICBpc0J5ZTogYm9vbGVhbiA9IGZhbHNlLFxuICBicmFja2V0OiBcIndpbm5lcnNcIiB8IFwibG9zZXJzXCIgfCBcImNoYW1waW9uc2hpcFwiID0gXCJ3aW5uZXJzXCIsXG4gIG5leHRNYXRjaElkPzogc3RyaW5nLFxuICBuZXh0TG9zZXJNYXRjaElkPzogc3RyaW5nXG4pOiBNYXRjaCA9PiAoe1xuICBpZCxcbiAgcm91bmROdW1iZXIsXG4gIHRlYW0xLFxuICB0ZWFtMixcbiAgaXNDb21wbGV0ZWQ6IGlzQnllLFxuICBpc0J5ZSxcbiAgYnJhY2tldCxcbiAgd2lubmVyOiBpc0J5ZSA/IHRlYW0xID8/IHRlYW0yID8/IHVuZGVmaW5lZCA6IHVuZGVmaW5lZCxcbiAgbG9zZXI6IGlzQnllID8gdW5kZWZpbmVkIDogdW5kZWZpbmVkLFxuICBzY29yZTogeyB0ZWFtMVNjb3JlOiAwLCB0ZWFtMlNjb3JlOiAwIH0sXG4gIG5leHRNYXRjaElkLFxuICBuZXh0TG9zZXJNYXRjaElkLFxuICBlbGltaW5hdGVkTGFiZWw6IHVuZGVmaW5lZFxufSk7XG5cbmV4cG9ydCBjb25zdCBjcmVhdGVJbml0aWFsUm91bmRzID0gKHRlYW1zOiBUZWFtW10pOiBUb3VybmFtZW50ID0+IHtcbiAgY29uc3QgbnVtVGVhbXMgPSB0ZWFtcy5sZW5ndGg7XG4gIGNvbnN0IG1hdGNoZXM6IE1hdGNoW10gPSBbXTtcbiAgY29uc3QgbnVtUm91bmRzID0gTWF0aC5jZWlsKE1hdGgubG9nMihudW1UZWFtcykpO1xuXG4gIGNvbnN0IGZpcnN0Um91bmRNYXRjaGVzID0gTWF0aC5wb3coMiwgbnVtUm91bmRzIC0gMSk7XG4gIGxldCBtYXRjaENvdW50ZXIgPSAxO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZmlyc3RSb3VuZE1hdGNoZXM7IGkrKykge1xuICAgIGNvbnN0IHRlYW0xID0gdGVhbXNbaSAqIDJdIHx8IG51bGw7XG4gICAgY29uc3QgdGVhbTIgPSB0ZWFtc1tpICogMiArIDFdIHx8IG51bGw7XG4gICAgY29uc3QgaXNCeWUgPSAhdGVhbTEgfHwgIXRlYW0yO1xuXG4gICAgY29uc3QgbWF0Y2hJZCA9IGBXMS0ke21hdGNoQ291bnRlcn1gO1xuICAgIGNvbnN0IG5leHRNYXRjaElkID0gYFcyLSR7TWF0aC5jZWlsKG1hdGNoQ291bnRlciAvIDIpfWA7XG4gICAgY29uc3QgbmV4dExvc2VyTWF0Y2hJZCA9IGBMMS0ke01hdGguY2VpbChtYXRjaENvdW50ZXIgLyAyKX1gO1xuXG4gICAgbWF0Y2hlcy5wdXNoKFxuICAgICAgY3JlYXRlTWF0Y2goXG4gICAgICAgIG1hdGNoSWQsXG4gICAgICAgIDEsXG4gICAgICAgIHRlYW0xLFxuICAgICAgICB0ZWFtMixcbiAgICAgICAgaXNCeWUsXG4gICAgICAgIFwid2lubmVyc1wiLFxuICAgICAgICBuZXh0TWF0Y2hJZCxcbiAgICAgICAgbmV4dExvc2VyTWF0Y2hJZFxuICAgICAgKVxuICAgICk7XG4gICAgbWF0Y2hDb3VudGVyKys7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHJvdW5kczogW1xuICAgICAge1xuICAgICAgICByb3VuZE51bWJlcjogMSxcbiAgICAgICAgbWF0Y2hlcyxcbiAgICAgICAgaXNEb3VibGVFbGltaW5hdGlvbjogdHJ1ZSxcbiAgICAgICAgaXNDaGFtcGlvbnNoaXBSb3VuZDogZmFsc2VcbiAgICAgIH1cbiAgICBdLFxuICAgIGN1cnJlbnRSb3VuZDogMSxcbiAgICBlbGltaW5hdGVkVGVhbXM6IFtdLFxuICAgIGNoYW1waW9uc2hpcE1hdGNoZXNQbGF5ZWQ6IDBcbiAgfTtcbn07XG5cbmV4cG9ydCBjb25zdCB1cGRhdGVNYXRjaFNjb3JlID0gKFxuICBtYXRjaDogTWF0Y2gsXG4gIG5ld1Njb3JlOiB7IHRlYW0xU2NvcmU6IG51bWJlcjsgdGVhbTJTY29yZTogbnVtYmVyIH1cbik6IE1hdGNoID0+IHtcbiAgY29uc3QgaXNDb21wbGV0ZWQgPSBuZXdTY29yZS50ZWFtMVNjb3JlICE9PSBuZXdTY29yZS50ZWFtMlNjb3JlO1xuICBsZXQgd2lubmVyOiBUZWFtIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuICBsZXQgbG9zZXI6IFRlYW0gfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG4gIGlmIChpc0NvbXBsZXRlZCkge1xuICAgIGlmIChuZXdTY29yZS50ZWFtMVNjb3JlID4gbmV3U2NvcmUudGVhbTJTY29yZSkge1xuICAgICAgd2lubmVyID0gbWF0Y2gudGVhbTFcbiAgICAgICAgPyB7XG4gICAgICAgICAgICAuLi5tYXRjaC50ZWFtMSxcbiAgICAgICAgICAgIHdpbnM6IChtYXRjaC50ZWFtMS53aW5zID8/IDApICsgMSxcbiAgICAgICAgICAgIGxvc3NlczogbWF0Y2gudGVhbTEubG9zc2VzID8/IDBcbiAgICAgICAgICB9XG4gICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgbG9zZXIgPSBtYXRjaC50ZWFtMlxuICAgICAgICA/IHtcbiAgICAgICAgICAgIC4uLm1hdGNoLnRlYW0yLFxuICAgICAgICAgICAgd2luczogbWF0Y2gudGVhbTIud2lucyA/PyAwLFxuICAgICAgICAgICAgbG9zc2VzOiAobWF0Y2gudGVhbTIubG9zc2VzID8/IDApICsgMVxuICAgICAgICAgIH1cbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdpbm5lciA9IG1hdGNoLnRlYW0yXG4gICAgICAgID8ge1xuICAgICAgICAgICAgLi4ubWF0Y2gudGVhbTIsXG4gICAgICAgICAgICB3aW5zOiAobWF0Y2gudGVhbTIud2lucyA/PyAwKSArIDEsXG4gICAgICAgICAgICBsb3NzZXM6IG1hdGNoLnRlYW0yLmxvc3NlcyA/PyAwXG4gICAgICAgICAgfVxuICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgIGxvc2VyID0gbWF0Y2gudGVhbTFcbiAgICAgICAgPyB7XG4gICAgICAgICAgICAuLi5tYXRjaC50ZWFtMSxcbiAgICAgICAgICAgIHdpbnM6IG1hdGNoLnRlYW0xLndpbnMgPz8gMCxcbiAgICAgICAgICAgIGxvc3NlczogKG1hdGNoLnRlYW0xLmxvc3NlcyA/PyAwKSArIDFcbiAgICAgICAgICB9XG4gICAgICAgIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIC4uLm1hdGNoLFxuICAgIHNjb3JlOiBuZXdTY29yZSxcbiAgICBpc0NvbXBsZXRlZCxcbiAgICB3aW5uZXIsXG4gICAgbG9zZXJcbiAgfTtcbn07XG5cbi8vIEhlbHBlciB0byBkZWR1cGxpY2F0ZSB0ZWFtcyBieSBJRFxuZnVuY3Rpb24gZGVkdXBlVGVhbXModGVhbXM6IFRlYW1bXSk6IFRlYW1bXSB7XG4gIGNvbnN0IHNlZW4gPSBuZXcgU2V0PHN0cmluZz4oKTtcbiAgcmV0dXJuIHRlYW1zLmZpbHRlcigodGVhbSkgPT4ge1xuICAgIGlmICghdGVhbSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChzZWVuLmhhcyh0ZWFtLmlkKSkgcmV0dXJuIGZhbHNlO1xuICAgIHNlZW4uYWRkKHRlYW0uaWQpO1xuICAgIHJldHVybiB0cnVlO1xuICB9KTtcbn1cblxuLy8gSGVscGVyOiBnZXQgYWxsIHRlYW1zIHdpdGggZXhhY3RseSBOIGxvc3Nlc1xuZnVuY3Rpb24gdGVhbXNXaXRoTG9zc2VzKFxuICBsb3NzQ291bnRzOiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+LFxuICBuOiBudW1iZXJcbik6IHN0cmluZ1tdIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKGxvc3NDb3VudHMpLmZpbHRlcigodGVhbUlkKSA9PiBsb3NzQ291bnRzW3RlYW1JZF0gPT09IG4pO1xufVxuIl0sIm5hbWVzIjpbImNyZWF0ZU1hdGNoIiwiaWQiLCJyb3VuZE51bWJlciIsInRlYW0xIiwidGVhbTIiLCJpc0J5ZSIsImJyYWNrZXQiLCJuZXh0TWF0Y2hJZCIsIm5leHRMb3Nlck1hdGNoSWQiLCJpc0NvbXBsZXRlZCIsIndpbm5lciIsInVuZGVmaW5lZCIsImxvc2VyIiwic2NvcmUiLCJ0ZWFtMVNjb3JlIiwidGVhbTJTY29yZSIsImVsaW1pbmF0ZWRMYWJlbCIsImNyZWF0ZUluaXRpYWxSb3VuZHMiLCJ0ZWFtcyIsIm51bVRlYW1zIiwibGVuZ3RoIiwibWF0Y2hlcyIsIm51bVJvdW5kcyIsIk1hdGgiLCJjZWlsIiwibG9nMiIsImZpcnN0Um91bmRNYXRjaGVzIiwicG93IiwibWF0Y2hDb3VudGVyIiwiaSIsIm1hdGNoSWQiLCJwdXNoIiwicm91bmRzIiwiaXNEb3VibGVFbGltaW5hdGlvbiIsImlzQ2hhbXBpb25zaGlwUm91bmQiLCJjdXJyZW50Um91bmQiLCJlbGltaW5hdGVkVGVhbXMiLCJjaGFtcGlvbnNoaXBNYXRjaGVzUGxheWVkIiwidXBkYXRlTWF0Y2hTY29yZSIsIm1hdGNoIiwibmV3U2NvcmUiLCJ3aW5zIiwibG9zc2VzIiwiZGVkdXBlVGVhbXMiLCJzZWVuIiwiU2V0IiwiZmlsdGVyIiwidGVhbSIsImhhcyIsImFkZCIsInRlYW1zV2l0aExvc3NlcyIsImxvc3NDb3VudHMiLCJuIiwiT2JqZWN0Iiwia2V5cyIsInRlYW1JZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./types/tournament/matches.ts\n"));

/***/ })

});
"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/tournament/page",{

/***/ "(app-pages-browser)/./types/tournament/matches.ts":
/*!*************************************!*\
  !*** ./types/tournament/matches.ts ***!
  \*************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   advanceToNextRound: function() { return /* binding */ advanceToNextRound; },\n/* harmony export */   createInitialRounds: function() { return /* binding */ createInitialRounds; },\n/* harmony export */   createMatch: function() { return /* binding */ createMatch; },\n/* harmony export */   updateMatchScore: function() { return /* binding */ updateMatchScore; }\n/* harmony export */ });\n/* harmony import */ var _logTournamentState__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./logTournamentState */ \"(app-pages-browser)/./types/tournament/logTournamentState.ts\");\n\nconst createMatch = function(id, roundNumber, team1, team2) {\n    let isBye = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : false, bracket = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : \"winners\", nextMatchId = arguments.length > 6 ? arguments[6] : void 0, nextLoserMatchId = arguments.length > 7 ? arguments[7] : void 0;\n    var _ref;\n    return {\n        id,\n        roundNumber,\n        team1,\n        team2,\n        isCompleted: isBye,\n        isBye,\n        bracket,\n        winner: isBye ? (_ref = team1 !== null && team1 !== void 0 ? team1 : team2) !== null && _ref !== void 0 ? _ref : undefined : undefined,\n        loser: isBye ? undefined : undefined,\n        score: {\n            team1Score: 0,\n            team2Score: 0\n        },\n        nextMatchId,\n        nextLoserMatchId,\n        eliminatedLabel: undefined\n    };\n};\nconst createInitialRounds = (teams)=>{\n    const numTeams = teams.length;\n    const matches = [];\n    const numRounds = Math.ceil(Math.log2(numTeams));\n    const firstRoundMatches = Math.pow(2, numRounds - 1);\n    let matchCounter = 1;\n    for(let i = 0; i < firstRoundMatches; i++){\n        const team1 = teams[i * 2] || null;\n        const team2 = teams[i * 2 + 1] || null;\n        const isBye = !team1 || !team2;\n        const matchId = \"W1-\".concat(matchCounter);\n        const nextMatchId = \"W2-\".concat(Math.ceil(matchCounter / 2));\n        const nextLoserMatchId = \"L1-\".concat(Math.ceil(matchCounter / 2));\n        matches.push(createMatch(matchId, 1, team1, team2, isBye, \"winners\", nextMatchId, nextLoserMatchId));\n        matchCounter++;\n    }\n    return {\n        rounds: [\n            {\n                roundNumber: 1,\n                matches,\n                isDoubleElimination: true,\n                isChampionship: false\n            }\n        ],\n        currentRound: 1,\n        eliminatedTeams: [],\n        championshipMatchesPlayed: 0\n    };\n};\nconst updateMatchScore = (match, newScore)=>{\n    const isCompleted = newScore.team1Score !== newScore.team2Score;\n    let winner = undefined;\n    let loser = undefined;\n    if (isCompleted) {\n        if (newScore.team1Score > newScore.team2Score) {\n            var _match_team1_wins, _match_team1_losses;\n            winner = match.team1 ? {\n                ...match.team1,\n                wins: ((_match_team1_wins = match.team1.wins) !== null && _match_team1_wins !== void 0 ? _match_team1_wins : 0) + 1,\n                losses: (_match_team1_losses = match.team1.losses) !== null && _match_team1_losses !== void 0 ? _match_team1_losses : 0\n            } : undefined;\n            var _match_team2_wins, _match_team2_losses;\n            loser = match.team2 ? {\n                ...match.team2,\n                wins: (_match_team2_wins = match.team2.wins) !== null && _match_team2_wins !== void 0 ? _match_team2_wins : 0,\n                losses: ((_match_team2_losses = match.team2.losses) !== null && _match_team2_losses !== void 0 ? _match_team2_losses : 0) + 1\n            } : undefined;\n        } else {\n            var _match_team2_wins1, _match_team2_losses1;\n            winner = match.team2 ? {\n                ...match.team2,\n                wins: ((_match_team2_wins1 = match.team2.wins) !== null && _match_team2_wins1 !== void 0 ? _match_team2_wins1 : 0) + 1,\n                losses: (_match_team2_losses1 = match.team2.losses) !== null && _match_team2_losses1 !== void 0 ? _match_team2_losses1 : 0\n            } : undefined;\n            var _match_team1_wins1, _match_team1_losses1;\n            loser = match.team1 ? {\n                ...match.team1,\n                wins: (_match_team1_wins1 = match.team1.wins) !== null && _match_team1_wins1 !== void 0 ? _match_team1_wins1 : 0,\n                losses: ((_match_team1_losses1 = match.team1.losses) !== null && _match_team1_losses1 !== void 0 ? _match_team1_losses1 : 0) + 1\n            } : undefined;\n        }\n    }\n    return {\n        ...match,\n        score: newScore,\n        isCompleted,\n        winner,\n        loser\n    };\n};\n// Helper to deduplicate teams by ID\nfunction dedupeTeams(teams) {\n    const seen = new Set();\n    return teams.filter((team)=>{\n        if (!team) return false;\n        if (seen.has(team.id)) return false;\n        seen.add(team.id);\n        return true;\n    });\n}\n// Helper: get all teams with exactly N losses\nfunction teamsWithLosses(lossCounts, n) {\n    return Object.keys(lossCounts).filter((teamId)=>lossCounts[teamId] === n);\n}\nconst advanceToNextRound = (tournament)=>{\n    const currentRound = tournament.rounds[tournament.rounds.length - 1];\n    const nextRoundNumber = tournament.currentRound + 1;\n    // Tally losses and wins\n    const lossCounts = {};\n    const winsCounts = {};\n    tournament.rounds.forEach((round)=>{\n        round.matches.forEach((match)=>{\n            if (match.isCompleted && match.loser) {\n                lossCounts[match.loser.id] = (lossCounts[match.loser.id] || 0) + 1;\n            }\n            if (match.isCompleted && match.winner) {\n                winsCounts[match.winner.id] = (winsCounts[match.winner.id] || 0) + 1;\n            }\n        });\n    });\n    // If winner already determined, stop\n    if (tournament.winner) {\n        return {\n            ...tournament,\n            currentRound: tournament.currentRound\n        };\n    }\n    // Build all teams\n    const allTeams = [];\n    const teamIds = new Set();\n    for (const round of tournament.rounds){\n        for (const match of round.matches){\n            if (match.team1 && !teamIds.has(match.team1.id)) {\n                allTeams.push({\n                    ...match.team1,\n                    wins: winsCounts[match.team1.id] || 0,\n                    losses: lossCounts[match.team1.id] || 0\n                });\n                teamIds.add(match.team1.id);\n            }\n            if (match.team2 && !teamIds.has(match.team2.id)) {\n                allTeams.push({\n                    ...match.team2,\n                    wins: winsCounts[match.team2.id] || 0,\n                    losses: lossCounts[match.team2.id] || 0\n                });\n                teamIds.add(match.team2.id);\n            }\n        }\n    }\n    // Find newly eliminated\n    const newlyEliminated = [];\n    for (const team of allTeams){\n        if ((lossCounts[team.id] || 0) >= 2 && !tournament.eliminatedTeams.some((t)=>t.id === team.id)) {\n            newlyEliminated.push(team);\n        }\n    }\n    // Winners bracket: 0 losses\n    const winnersBracketTeams = allTeams.filter((team)=>(lossCounts[team.id] || 0) === 0 && !tournament.eliminatedTeams.some((t)=>t.id === team.id) && !newlyEliminated.some((t)=>t.id === team.id) && !team.id.startsWith(\"tbd-\"));\n    // Losers bracket: 1 loss\n    const losersBracketTeams = allTeams.filter((team)=>(lossCounts[team.id] || 0) === 1 && !tournament.eliminatedTeams.some((t)=>t.id === team.id) && !newlyEliminated.some((t)=>t.id === team.id));\n    let nextRoundMatches = [];\n    let isChampionship = false;\n    let championshipMatchesPlayed = tournament.championshipMatchesPlayed || 0;\n    let winner = undefined;\n    // --- CHAMPIONSHIP LOGIC ---\n    // If only two teams remain and one has no losses, one has one loss, it's time for championship\n    if (winnersBracketTeams.length === 1 && losersBracketTeams.length === 1) {\n        const WB = winnersBracketTeams[0];\n        const LB = losersBracketTeams[0];\n        // Find previous championship matches\n        const prevChamp = tournament.rounds.filter((r)=>r.isChampionship).flatMap((r)=>r.matches);\n        const lastChamp = prevChamp.length > 0 ? prevChamp[prevChamp.length - 1] : undefined;\n        if (!lastChamp || lastChamp && lastChamp.isCompleted && lastChamp.winner && championshipMatchesPlayed < 2 && lastChamp.winner.id === LB.id) {\n            // Schedule a championship match if:\n            // - No championship match yet\n            // - OR LB won the first, so need a second\n            nextRoundMatches.push(createMatch(\"C\".concat(nextRoundNumber, \"-\").concat(championshipMatchesPlayed + 1), nextRoundNumber, WB, LB, false, \"championship\"));\n            isChampionship = true;\n            championshipMatchesPlayed += 1;\n        } else if (lastChamp && lastChamp.isCompleted && lastChamp.winner) {\n            // If WB wins any championship, they win. If LB wins two, they win.\n            winner = lastChamp.winner;\n        }\n    }\n    // If more than 2 teams remain, continue with normal bracket play\n    // Prevent creating a round if only waiting cards (TBD/null) would be scheduled\n    if (nextRoundMatches.length > 0 && nextRoundMatches.every((m)=>!m.team2 || m.team2.id.startsWith(\"tbd\") || m.team2 === null)) {\n        // All matches are waiting cards, do not create a new round\n        return {\n            ...tournament,\n            currentRound: tournament.currentRound\n        };\n    } else if (winnersBracketTeams.length === 1 && tournament.winnersBracketFinalLoser) {\n        if (losersBracketTeams.length === 1) {\n            // Prevent duplicate losers bracket final: check all previous rounds for this match\n            let alreadyPlayed = false;\n            for (let round of tournament.rounds){\n                if (!round.matches) continue;\n                for (let m of round.matches){\n                    var _m_team1, _m_team2;\n                    const ids = [\n                        (_m_team1 = m.team1) === null || _m_team1 === void 0 ? void 0 : _m_team1.id,\n                        (_m_team2 = m.team2) === null || _m_team2 === void 0 ? void 0 : _m_team2.id\n                    ].filter(Boolean).sort();\n                    const currIds = [\n                        tournament.winnersBracketFinalLoser.id,\n                        losersBracketTeams[0].id\n                    ].sort();\n                    if (ids.length === 2 && ids[0] === currIds[0] && ids[1] === currIds[1]) {\n                        alreadyPlayed = true;\n                        break;\n                    }\n                }\n                if (alreadyPlayed) break;\n            }\n            if (!alreadyPlayed) {\n                // Only now schedule WBFL vs LBL\n                nextRoundMatches.push(createMatch(\"LosersLast-\".concat(nextRoundNumber), nextRoundNumber, tournament.winnersBracketFinalLoser, losersBracketTeams[0], false, \"losers\"));\n                return {\n                    ...tournament,\n                    rounds: [\n                        ...tournament.rounds,\n                        {\n                            roundNumber: nextRoundNumber,\n                            matches: nextRoundMatches,\n                            isDoubleElimination: true,\n                            isChampionship: false\n                        }\n                    ],\n                    currentRound: nextRoundNumber,\n                    eliminatedTeams: [\n                        ...tournament.eliminatedTeams,\n                        ...newlyEliminated.filter((t)=>!tournament.eliminatedTeams.some((et)=>et.id === t.id))\n                    ],\n                    championshipMatchesPlayed: tournament.championshipMatchesPlayed,\n                    winnersBracketFinalLoser: tournament.winnersBracketFinalLoser,\n                    winner: undefined\n                };\n            }\n        // If match already played, do not schedule again; championship logic will handle next step\n        } else if (losersBracketTeams.length === 2) {\n            // Schedule the match between the last two losers bracket teams\n            nextRoundMatches.push(createMatch(\"L\".concat(nextRoundNumber, \"-1\"), nextRoundNumber, losersBracketTeams[0], losersBracketTeams[1], false, \"losers\"));\n            // WBFL is waiting for the winner\n            nextRoundMatches.push(createMatch(\"WinnersFinalLoser-waiting-\".concat(nextRoundNumber), nextRoundNumber, tournament.winnersBracketFinalLoser, null, true, \"losers\"));\n        } else if (losersBracketTeams.length > 2) {\n            // More than 2 teams: pair off as usual, WBFL waits\n            for(let i = 0; i < losersBracketTeams.length; i += 2){\n                const team1 = losersBracketTeams[i];\n                var _losersBracketTeams_;\n                const team2 = (_losersBracketTeams_ = losersBracketTeams[i + 1]) !== null && _losersBracketTeams_ !== void 0 ? _losersBracketTeams_ : null;\n                nextRoundMatches.push(createMatch(\"L\".concat(nextRoundNumber, \"-\").concat(Math.floor(i / 2) + 1), nextRoundNumber, team1, team2, !team2, \"losers\"));\n            }\n            nextRoundMatches.push(createMatch(\"WinnersFinalLoser-waiting-\".concat(nextRoundNumber), nextRoundNumber, tournament.winnersBracketFinalLoser, null, true, \"losers\"));\n        } else {\n            // WBFL is waiting for the losers bracket to resolve\n            nextRoundMatches.push(createMatch(\"WinnersFinalLoser-waiting-\".concat(nextRoundNumber), nextRoundNumber, tournament.winnersBracketFinalLoser, null, true, \"losers\"));\n        }\n        // Always show a waiting card for the winners bracket champion if not in championship\n        nextRoundMatches.push(createMatch(\"WinnersBracketChampion-waiting-\".concat(nextRoundNumber), nextRoundNumber, winnersBracketTeams[0], null, true, \"winners\"));\n    } else if (winnersBracketTeams.length === 2) {\n        // Create the winner's bracket final match\n        nextRoundMatches.push(createMatch(\"W\".concat(nextRoundNumber, \"-1\"), nextRoundNumber, winnersBracketTeams[0], winnersBracketTeams[1], false, \"winners\"));\n        // Continue with losers bracket matches separately\n        createLosersBracketMatches();\n    } else {\n        createStandardBracketMatches();\n    }\n    // Helper function to create standard bracket matches\n    function createStandardBracketMatches() {\n        // --- Winners Bracket Matches ---\n        let matchCounter = 1;\n        for(let i = 0; i < winnersBracketTeams.length; i += 2){\n            const team1 = winnersBracketTeams[i];\n            var _winnersBracketTeams_;\n            const team2 = (_winnersBracketTeams_ = winnersBracketTeams[i + 1]) !== null && _winnersBracketTeams_ !== void 0 ? _winnersBracketTeams_ : null;\n            const isBye = !team2;\n            nextRoundMatches.push(createMatch(\"W\".concat(nextRoundNumber, \"-\").concat(matchCounter), nextRoundNumber, team1, team2, isBye, \"winners\"));\n            matchCounter++;\n        }\n        // Create losers bracket matches separately\n        createLosersBracketMatches();\n    }\n    // Helper function to create losers bracket matches\n    function createLosersBracketMatches() {\n        // --- Losers Bracket Matches ---\n        const eligibleLosers = allTeams.filter((team)=>(lossCounts[team.id] || 0) === 1 && !tournament.eliminatedTeams.some((t)=>t.id === team.id) && !newlyEliminated.some((t)=>t.id === team.id) && // Exclude winner's bracket final loser if it exists\n            !(tournament.winnersBracketFinalLoser && tournament.winnersBracketFinalLoser.id === team.id));\n        // Find teams recently dropped from winners bracket\n        const justDroppedFromWinners = currentRound.matches.filter((m)=>m.bracket === \"winners\" && m.loser && m.isCompleted).map((m)=>m.loser).filter((loser)=>eligibleLosers.some((t)=>t.id === loser.id));\n        // If this is the winner's bracket final, store the loser for later use\n        if (currentRound.matches.some((m)=>m.bracket === \"winners\" && winnersBracketTeams.length === 1 && m.loser && m.isCompleted)) {\n            // This is a special case - we found the winner's bracket final loser\n            const winnersFinalLoser = currentRound.matches.filter((m)=>m.bracket === \"winners\" && m.isCompleted && m.loser).map((m)=>m.loser).pop();\n            if (winnersFinalLoser && !tournament.eliminatedTeams.some((t)=>t.id === winnersFinalLoser.id)) {\n                tournament.winnersBracketFinalLoser = winnersFinalLoser;\n            }\n        }\n        // Existing losers bracket teams\n        const existingLosers = eligibleLosers.filter((t)=>!justDroppedFromWinners.some((jd)=>jd.id === t.id));\n        // Order: most recent drop(s) first\n        const orderedLosers = [\n            ...justDroppedFromWinners,\n            ...existingLosers\n        ];\n        if (orderedLosers.length > 0) {\n            if (orderedLosers.length % 2 === 1) {\n                // Odd: bye goes to the most recent team dropped from winners bracket\n                let teamWithBye = null;\n                if (justDroppedFromWinners.length > 0) {\n                    teamWithBye = justDroppedFromWinners[justDroppedFromWinners.length - 1];\n                    // Remove the bye team from orderedLosers\n                    const byeIndex = orderedLosers.findIndex((t)=>t.id === teamWithBye.id);\n                    if (byeIndex !== -1) orderedLosers.splice(byeIndex, 1);\n                } else {\n                    // Defensive: fallback to first team if no recent drop\n                    teamWithBye = orderedLosers.shift();\n                }\n                nextRoundMatches.push(createMatch(\"L\".concat(nextRoundNumber, \"-1\"), nextRoundNumber, teamWithBye, null, true, \"losers\"));\n                // Pair the rest\n                for(let i = 0; i < orderedLosers.length; i += 2){\n                    const team1 = orderedLosers[i];\n                    var _orderedLosers_;\n                    const team2 = (_orderedLosers_ = orderedLosers[i + 1]) !== null && _orderedLosers_ !== void 0 ? _orderedLosers_ : null;\n                    nextRoundMatches.push(createMatch(\"L\".concat(nextRoundNumber, \"-\").concat(Math.floor(i / 2) + 1), nextRoundNumber, team1, team2, !team2, \"losers\"));\n                }\n            } else {\n                // Even number: pair all\n                for(let i = 0; i < orderedLosers.length; i += 2){\n                    const team1 = orderedLosers[i];\n                    var _orderedLosers_1;\n                    const team2 = (_orderedLosers_1 = orderedLosers[i + 1]) !== null && _orderedLosers_1 !== void 0 ? _orderedLosers_1 : null;\n                    nextRoundMatches.push(createMatch(\"L\".concat(nextRoundNumber, \"-\").concat(Math.floor(i / 2) + 1), nextRoundNumber, team1, team2, !team2, \"losers\"));\n                }\n            }\n        }\n    }\n    // --- Winner detection logic ---\n    // winner already declared above; do not redeclare here\n    if (isChampionship) {\n        // Find the last championship match played\n        const lastChampMatch = championshipMatches[0] || prevChampionshipMatches[prevChampionshipMatches.length - 1];\n        if (lastChampMatch && lastChampMatch.isCompleted && lastChampMatch.winner && lastChampMatch.loser) {\n            const winnersBracketTeam = lastChampMatch.team1;\n            const losersBracketTeam = lastChampMatch.team2;\n            const losersBracketTeamWon = losersBracketTeam && lastChampMatch.winner.id === losersBracketTeam.id;\n            // If loser's bracket team won first championship match, winner's bracket team gets another chance\n            if (losersBracketTeamWon && tournament.championshipMatchesPlayed === 1) {\n                winner = undefined; // No winner yet, need reset match\n            } else {\n                // Either winner's bracket team won first match, or this was the reset match\n                winner = lastChampMatch.winner;\n            }\n        }\n    }\n    // If a winner has been found after championship logic, DO NOT CREATE MORE ROUNDS\n    if (winner) {\n        return {\n            ...tournament,\n            winner,\n            currentRound: tournament.currentRound\n        };\n    }\n    // --- INFINITE RECURSION GUARD ---\n    const noMoreMatches = isChampionship && championshipMatches.length === 0 || !isChampionship && nextRoundMatches.length === 0;\n    if (noMoreMatches) {\n        // Tournament is over, do not advance further\n        return {\n            ...tournament,\n            winner,\n            currentRound: tournament.currentRound\n        };\n    }\n    // Debug log before returning the new tournament object\n    (0,_logTournamentState__WEBPACK_IMPORTED_MODULE_0__.logTournamentState)({\n        roundNumber: nextRoundNumber,\n        winnersBracketTeams,\n        losersBracketTeams,\n        matches: nextRoundMatches,\n        winnersBracketFinalLoser: tournament.winnersBracketFinalLoser\n    });\n    // The following logic should be outside of the logTournamentState object\n    // (move this to the correct procedural location in your round/match generation logic)\n    // nextRoundMatches.push(\n    //   createMatch(\n    //     `W${nextRoundNumber}-${matchCounter}`,\n    //     nextRoundNumber,\n    //     team1,\n    //     team2,\n    //     isBye,\n    //     \"winners\"\n    //   )\n    // );\n    // matchCounter++;\n    // Helper function to create losers bracket matches\n    function createLosersBracketMatches() {\n        // --- Losers Bracket Matches ---\n        // 1. Schedule Losers Bracket Final if exactly two teams left and WBF loser known\n        if (losersBracketTeams.length === 2 && tournament.winnersBracketFinalLoser && !currentRound.matches.some((m)=>m.bracket === \"losers\" && m.roundNumber === nextRoundNumber && m.isCompleted !== false)) {\n            nextRoundMatches.push(createMatch(\"L\".concat(nextRoundNumber, \"-F\"), nextRoundNumber, losersBracketTeams[0], losersBracketTeams[1], false, \"losers\"));\n            return; // Only schedule the final, nothing else this round\n        }\n        // 2. Schedule Championship if losers bracket final just completed\n        if (tournament.winnersBracketFinalLoser && currentRound.matches.some((m)=>{\n            var _losersBracketTeams_, _losersBracketTeams_1, _m_team1, _losersBracketTeams_2, _losersBracketTeams_3, _m_team2;\n            return m.bracket === \"losers\" && [\n                (_losersBracketTeams_ = losersBracketTeams[0]) === null || _losersBracketTeams_ === void 0 ? void 0 : _losersBracketTeams_.id,\n                (_losersBracketTeams_1 = losersBracketTeams[1]) === null || _losersBracketTeams_1 === void 0 ? void 0 : _losersBracketTeams_1.id\n            ].includes((_m_team1 = m.team1) === null || _m_team1 === void 0 ? void 0 : _m_team1.id) && [\n                (_losersBracketTeams_2 = losersBracketTeams[0]) === null || _losersBracketTeams_2 === void 0 ? void 0 : _losersBracketTeams_2.id,\n                (_losersBracketTeams_3 = losersBracketTeams[1]) === null || _losersBracketTeams_3 === void 0 ? void 0 : _losersBracketTeams_3.id\n            ].includes((_m_team2 = m.team2) === null || _m_team2 === void 0 ? void 0 : _m_team2.id) && m.isCompleted && m.winner;\n        })) {\n            const losersBracketWinner = currentRound.matches.filter((m)=>{\n                var _losersBracketTeams_, _losersBracketTeams_1, _m_team1, _losersBracketTeams_2, _losersBracketTeams_3, _m_team2;\n                return m.bracket === \"losers\" && [\n                    (_losersBracketTeams_ = losersBracketTeams[0]) === null || _losersBracketTeams_ === void 0 ? void 0 : _losersBracketTeams_.id,\n                    (_losersBracketTeams_1 = losersBracketTeams[1]) === null || _losersBracketTeams_1 === void 0 ? void 0 : _losersBracketTeams_1.id\n                ].includes((_m_team1 = m.team1) === null || _m_team1 === void 0 ? void 0 : _m_team1.id) && [\n                    (_losersBracketTeams_2 = losersBracketTeams[0]) === null || _losersBracketTeams_2 === void 0 ? void 0 : _losersBracketTeams_2.id,\n                    (_losersBracketTeams_3 = losersBracketTeams[1]) === null || _losersBracketTeams_3 === void 0 ? void 0 : _losersBracketTeams_3.id\n                ].includes((_m_team2 = m.team2) === null || _m_team2 === void 0 ? void 0 : _m_team2.id) && m.isCompleted && m.winner;\n            }).map((m)=>m.winner).pop();\n            if (losersBracketWinner && winnersBracketTeams.length > 0) {\n                nextRoundMatches.push(createMatch(\"C\".concat(nextRoundNumber, \"-1\"), nextRoundNumber, winnersBracketTeams[0], losersBracketWinner, false, \"championship\"));\n                isChampionship = true;\n            }\n            return;\n        }\n        // 3. Otherwise, schedule normal losers bracket matches\n        const eligibleLosers = allTeams.filter((team)=>(lossCounts[team.id] || 0) === 1 && !tournament.eliminatedTeams.some((t)=>t.id === team.id) && !newlyEliminated.some((t)=>t.id === team.id) && // Exclude winner's bracket final loser if it exists\n            !(tournament.winnersBracketFinalLoser && tournament.winnersBracketFinalLoser.id === team.id));\n        // Find teams recently dropped from winners bracket\n        const justDroppedFromWinners = currentRound.matches.filter((m)=>m.bracket === \"winners\" && m.loser && m.isCompleted).map((m)=>m.loser).filter((loser)=>eligibleLosers.some((t)=>t.id === loser.id));\n    // Schedule matches for eligible losers as needed (implement your pairing logic here)\n    // ...\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3R5cGVzL3RvdXJuYW1lbnQvbWF0Y2hlcy50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUMwRDtBQW1DbkQsTUFBTUMsY0FBYyxTQUN6QkMsSUFDQUMsYUFDQUMsT0FDQUM7UUFDQUMseUVBQWlCLE9BQ2pCQywyRUFBaUQsV0FDakRDLDREQUNBQztRQVNpQkw7V0FSTjtRQUNYRjtRQUNBQztRQUNBQztRQUNBQztRQUNBSyxhQUFhSjtRQUNiQTtRQUNBQztRQUNBSSxRQUFRTCxRQUFTRixDQUFBQSxPQUFBQSxrQkFBQUEsbUJBQUFBLFFBQVNDLG1CQUFURCxrQkFBQUEsT0FBa0JRLFlBQWFBO1FBQ2hEQyxPQUFPUCxRQUFRTSxZQUFZQTtRQUMzQkUsT0FBTztZQUFFQyxZQUFZO1lBQUdDLFlBQVk7UUFBRTtRQUN0Q1I7UUFDQUM7UUFDQVEsaUJBQWlCTDtJQUNuQjtBQUFBLEVBQUc7QUFFSSxNQUFNTSxzQkFBc0IsQ0FBQ0M7SUFDbEMsTUFBTUMsV0FBV0QsTUFBTUUsTUFBTTtJQUM3QixNQUFNQyxVQUFtQixFQUFFO0lBQzNCLE1BQU1DLFlBQVlDLEtBQUtDLElBQUksQ0FBQ0QsS0FBS0UsSUFBSSxDQUFDTjtJQUV0QyxNQUFNTyxvQkFBb0JILEtBQUtJLEdBQUcsQ0FBQyxHQUFHTCxZQUFZO0lBQ2xELElBQUlNLGVBQWU7SUFFbkIsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlILG1CQUFtQkcsSUFBSztRQUMxQyxNQUFNMUIsUUFBUWUsS0FBSyxDQUFDVyxJQUFJLEVBQUUsSUFBSTtRQUM5QixNQUFNekIsUUFBUWMsS0FBSyxDQUFDVyxJQUFJLElBQUksRUFBRSxJQUFJO1FBQ2xDLE1BQU14QixRQUFRLENBQUNGLFNBQVMsQ0FBQ0M7UUFFekIsTUFBTTBCLFVBQVUsTUFBbUIsT0FBYkY7UUFDdEIsTUFBTXJCLGNBQWMsTUFBa0MsT0FBNUJnQixLQUFLQyxJQUFJLENBQUNJLGVBQWU7UUFDbkQsTUFBTXBCLG1CQUFtQixN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QkFBZ0IsT0FDcEJBLGlCQUNBUyxtQkFBbUIsQ0FBQyxFQUFFLEVBQ3RCMkMscUJBQ0EsT0FDQTtnQkFHSjVFLGlCQUFpQjtZQUNuQjtZQUNBO1FBQ0Y7UUFFQSx1REFBdUQ7UUFDdkQsTUFBTXVELGlCQUFpQjNCLFNBQVNoQixNQUFNLENBQ3BDLENBQUNDLE9BQ0MsQ0FBQ0ksVUFBVSxDQUFDSixLQUFLOUMsRUFBRSxDQUFDLElBQUksT0FBTyxLQUMvQixDQUFDd0QsV0FBV3JCLGVBQWUsQ0FBQzZCLElBQUksQ0FBQyxDQUFDQyxJQUFNQSxFQUFFakUsRUFBRSxLQUFLOEMsS0FBSzlDLEVBQUUsS0FDeEQsQ0FBQytELGdCQUFnQkMsSUFBSSxDQUFDLENBQUNDLElBQU1BLEVBQUVqRSxFQUFFLEtBQUs4QyxLQUFLOUMsRUFBRSxLQUM3QyxvREFBb0Q7WUFDcEQsQ0FDRXdELENBQUFBLFdBQVdzQix3QkFBd0IsSUFDbkN0QixXQUFXc0Isd0JBQXdCLENBQUM5RSxFQUFFLEtBQUs4QyxLQUFLOUMsRUFBRTtRQUl4RCxtREFBbUQ7UUFDbkQsTUFBTXlGLHlCQUF5QnZELGFBQWFkLE9BQU8sQ0FDaER5QixNQUFNLENBQUMsQ0FBQ2dDLElBQU1BLEVBQUV4RSxPQUFPLEtBQUssYUFBYXdFLEVBQUVsRSxLQUFLLElBQUlrRSxFQUFFckUsV0FBVyxFQUNqRWtGLEdBQUcsQ0FBQyxDQUFDYixJQUFNQSxFQUFFbEUsS0FBSyxFQUNsQmtDLE1BQU0sQ0FBQyxDQUFDbEMsUUFBVTZFLGVBQWV4QixJQUFJLENBQUMsQ0FBQ0MsSUFBTUEsRUFBRWpFLEVBQUUsS0FBS1csTUFBTVgsRUFBRTtJQUVqRSxxRkFBcUY7SUFDckYsTUFBTTtJQUNSO0FBQ0EsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi90eXBlcy90b3VybmFtZW50L21hdGNoZXMudHM/ZGEyMiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7IFRlYW0gfSBmcm9tIFwiLi9tbGItdGVhbXNcIjtcbmltcG9ydCB7IGxvZ1RvdXJuYW1lbnRTdGF0ZSB9IGZyb20gXCIuL2xvZ1RvdXJuYW1lbnRTdGF0ZVwiO1xuXG5leHBvcnQgaW50ZXJmYWNlIE1hdGNoIHtcbiAgaWQ6IHN0cmluZztcbiAgcm91bmROdW1iZXI6IG51bWJlcjtcbiAgdGVhbTE6IFRlYW0gfCBudWxsO1xuICB0ZWFtMjogVGVhbSB8IG51bGw7XG4gIGlzQ29tcGxldGVkOiBib29sZWFuO1xuICBpc0J5ZT86IGJvb2xlYW47XG4gIHdpbm5lcj86IFRlYW07XG4gIGxvc2VyPzogVGVhbTtcbiAgYnJhY2tldDogXCJ3aW5uZXJzXCIgfCBcImxvc2Vyc1wiIHwgXCJjaGFtcGlvbnNoaXBcIjtcbiAgc2NvcmU6IHsgdGVhbTFTY29yZTogbnVtYmVyOyB0ZWFtMlNjb3JlOiBudW1iZXIgfTtcbiAgbmV4dE1hdGNoSWQ/OiBzdHJpbmc7XG4gIG5leHRMb3Nlck1hdGNoSWQ/OiBzdHJpbmc7XG4gIGVsaW1pbmF0ZWRMYWJlbD86IHN0cmluZzsgLy8gbGFiZWwgZm9yIGVsaW1pbmF0ZWQgdGVhbXMgaW4gbG9zZXJzIGJyYWNrZXRcbiAgcmVxdWlyZXNSZW1hdGNoPzogYm9vbGVhbjsgLy8gaW5kaWNhdGVzIGlmIGEgY2hhbXBpb25zaGlwIHJlbWF0Y2ggaXMgcmVxdWlyZWRcbn1cblxuZXhwb3J0IGludGVyZmFjZSBSb3VuZCB7XG4gIHJvdW5kTnVtYmVyOiBudW1iZXI7XG4gIG1hdGNoZXM6IE1hdGNoW107XG4gIGlzRG91YmxlRWxpbWluYXRpb246IGJvb2xlYW47XG4gIGlzQ2hhbXBpb25zaGlwOiBib29sZWFuO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFRvdXJuYW1lbnQge1xuICByb3VuZHM6IFJvdW5kW107XG4gIGN1cnJlbnRSb3VuZDogbnVtYmVyO1xuICBlbGltaW5hdGVkVGVhbXM6IFRlYW1bXTtcbiAgY2hhbXBpb25zaGlwTWF0Y2hlc1BsYXllZDogbnVtYmVyO1xuICB3aW5uZXI/OiBUZWFtO1xuICB3aW5uZXJzQnJhY2tldEZpbmFsTG9zZXI/OiBUZWFtOyAvLyB0cmFja3MgdGhlIHdpbm5lcidzIGJyYWNrZXQgZmluYWwgbG9zZXIgZm9yIGNoYW1waW9uc2hpcCByZW1hdGNoIGxvZ2ljXG59XG5cbmV4cG9ydCBjb25zdCBjcmVhdGVNYXRjaCA9IChcbiAgaWQ6IHN0cmluZyxcbiAgcm91bmROdW1iZXI6IG51bWJlcixcbiAgdGVhbTE6IFRlYW0gfCBudWxsLFxuICB0ZWFtMjogVGVhbSB8IG51bGwsXG4gIGlzQnllOiBib29sZWFuID0gZmFsc2UsXG4gIGJyYWNrZXQ6IFwid2lubmVyc1wiIHwgXCJsb3NlcnNcIiB8IFwiY2hhbXBpb25zaGlwXCIgPSBcIndpbm5lcnNcIixcbiAgbmV4dE1hdGNoSWQ/OiBzdHJpbmcsXG4gIG5leHRMb3Nlck1hdGNoSWQ/OiBzdHJpbmdcbik6IE1hdGNoID0+ICh7XG4gIGlkLFxuICByb3VuZE51bWJlcixcbiAgdGVhbTEsXG4gIHRlYW0yLFxuICBpc0NvbXBsZXRlZDogaXNCeWUsXG4gIGlzQnllLFxuICBicmFja2V0LFxuICB3aW5uZXI6IGlzQnllID8gKHRlYW0xID8/IHRlYW0yID8/IHVuZGVmaW5lZCkgOiB1bmRlZmluZWQsXG4gIGxvc2VyOiBpc0J5ZSA/IHVuZGVmaW5lZCA6IHVuZGVmaW5lZCxcbiAgc2NvcmU6IHsgdGVhbTFTY29yZTogMCwgdGVhbTJTY29yZTogMCB9LFxuICBuZXh0TWF0Y2hJZCxcbiAgbmV4dExvc2VyTWF0Y2hJZCxcbiAgZWxpbWluYXRlZExhYmVsOiB1bmRlZmluZWRcbn0pO1xuXG5leHBvcnQgY29uc3QgY3JlYXRlSW5pdGlhbFJvdW5kcyA9ICh0ZWFtczogVGVhbVtdKTogVG91cm5hbWVudCA9PiB7XG4gIGNvbnN0IG51bVRlYW1zID0gdGVhbXMubGVuZ3RoO1xuICBjb25zdCBtYXRjaGVzOiBNYXRjaFtdID0gW107XG4gIGNvbnN0IG51bVJvdW5kcyA9IE1hdGguY2VpbChNYXRoLmxvZzIobnVtVGVhbXMpKTtcblxuICBjb25zdCBmaXJzdFJvdW5kTWF0Y2hlcyA9IE1hdGgucG93KDIsIG51bVJvdW5kcyAtIDEpO1xuICBsZXQgbWF0Y2hDb3VudGVyID0gMTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGZpcnN0Um91bmRNYXRjaGVzOyBpKyspIHtcbiAgICBjb25zdCB0ZWFtMSA9IHRlYW1zW2kgKiAyXSB8fCBudWxsO1xuICAgIGNvbnN0IHRlYW0yID0gdGVhbXNbaSAqIDIgKyAxXSB8fCBudWxsO1xuICAgIGNvbnN0IGlzQnllID0gIXRlYW0xIHx8ICF0ZWFtMjtcblxuICAgIGNvbnN0IG1hdGNoSWQgPSBgVzEtJHttYXRjaENvdW50ZXJ9YDtcbiAgICBjb25zdCBuZXh0TWF0Y2hJZCA9IGBXMi0ke01hdGguY2VpbChtYXRjaENvdW50ZXIgLyAyKX1gO1xuICAgIGNvbnN0IG5leHRMb3Nlck1hdGNoSWQgPSBgTDEtJHtNYXRoLmNlaWwobWF0Y2hDb3VudGVyIC8gMil9YDtcblxuICAgIG1hdGNoZXMucHVzaChcbiAgICAgIGNyZWF0ZU1hdGNoKFxuICAgICAgICBtYXRjaElkLFxuICAgICAgICAxLFxuICAgICAgICB0ZWFtMSxcbiAgICAgICAgdGVhbTIsXG4gICAgICAgIGlzQnllLFxuICAgICAgICBcIndpbm5lcnNcIixcbiAgICAgICAgbmV4dE1hdGNoSWQsXG4gICAgICAgIG5leHRMb3Nlck1hdGNoSWRcbiAgICAgIClcbiAgICApO1xuICAgIG1hdGNoQ291bnRlcisrO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICByb3VuZHM6IFtcbiAgICAgIHtcbiAgICAgICAgcm91bmROdW1iZXI6IDEsXG4gICAgICAgIG1hdGNoZXMsXG4gICAgICAgIGlzRG91YmxlRWxpbWluYXRpb246IHRydWUsXG4gICAgICAgIGlzQ2hhbXBpb25zaGlwOiBmYWxzZVxuICAgICAgfVxuICAgIF0sXG4gICAgY3VycmVudFJvdW5kOiAxLFxuICAgIGVsaW1pbmF0ZWRUZWFtczogW10sXG4gICAgY2hhbXBpb25zaGlwTWF0Y2hlc1BsYXllZDogMFxuICB9O1xufTtcblxuZXhwb3J0IGNvbnN0IHVwZGF0ZU1hdGNoU2NvcmUgPSAoXG4gIG1hdGNoOiBNYXRjaCxcbiAgbmV3U2NvcmU6IHsgdGVhbTFTY29yZTogbnVtYmVyOyB0ZWFtMlNjb3JlOiBudW1iZXIgfVxuKTogTWF0Y2ggPT4ge1xuICBjb25zdCBpc0NvbXBsZXRlZCA9IG5ld1Njb3JlLnRlYW0xU2NvcmUgIT09IG5ld1Njb3JlLnRlYW0yU2NvcmU7XG4gIGxldCB3aW5uZXI6IFRlYW0gfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG4gIGxldCBsb3NlcjogVGVhbSB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcbiAgaWYgKGlzQ29tcGxldGVkKSB7XG4gICAgaWYgKG5ld1Njb3JlLnRlYW0xU2NvcmUgPiBuZXdTY29yZS50ZWFtMlNjb3JlKSB7XG4gICAgICB3aW5uZXIgPSBtYXRjaC50ZWFtMSA/IHsgLi4ubWF0Y2gudGVhbTEsIHdpbnM6IChtYXRjaC50ZWFtMS53aW5zID8/IDApICsgMSwgbG9zc2VzOiBtYXRjaC50ZWFtMS5sb3NzZXMgPz8gMCB9IDogdW5kZWZpbmVkO1xuICAgICAgbG9zZXIgPSBtYXRjaC50ZWFtMiA/IHsgLi4ubWF0Y2gudGVhbTIsIHdpbnM6IG1hdGNoLnRlYW0yLndpbnMgPz8gMCwgbG9zc2VzOiAobWF0Y2gudGVhbTIubG9zc2VzID8/IDApICsgMSB9IDogdW5kZWZpbmVkO1xuICAgIH0gZWxzZSB7XG4gICAgICB3aW5uZXIgPSBtYXRjaC50ZWFtMiA/IHsgLi4ubWF0Y2gudGVhbTIsIHdpbnM6IChtYXRjaC50ZWFtMi53aW5zID8/IDApICsgMSwgbG9zc2VzOiBtYXRjaC50ZWFtMi5sb3NzZXMgPz8gMCB9IDogdW5kZWZpbmVkO1xuICAgICAgbG9zZXIgPSBtYXRjaC50ZWFtMSA/IHsgLi4ubWF0Y2gudGVhbTEsIHdpbnM6IG1hdGNoLnRlYW0xLndpbnMgPz8gMCwgbG9zc2VzOiAobWF0Y2gudGVhbTEubG9zc2VzID8/IDApICsgMSB9IDogdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIC4uLm1hdGNoLFxuICAgIHNjb3JlOiBuZXdTY29yZSxcbiAgICBpc0NvbXBsZXRlZCxcbiAgICB3aW5uZXIsXG4gICAgbG9zZXJcbiAgfTtcbn07XG5cbi8vIEhlbHBlciB0byBkZWR1cGxpY2F0ZSB0ZWFtcyBieSBJRFxuZnVuY3Rpb24gZGVkdXBlVGVhbXModGVhbXM6IFRlYW1bXSk6IFRlYW1bXSB7XG4gIGNvbnN0IHNlZW4gPSBuZXcgU2V0PHN0cmluZz4oKTtcbiAgcmV0dXJuIHRlYW1zLmZpbHRlcih0ZWFtID0+IHtcbiAgICBpZiAoIXRlYW0pIHJldHVybiBmYWxzZTtcbiAgICBpZiAoc2Vlbi5oYXModGVhbS5pZCkpIHJldHVybiBmYWxzZTtcbiAgICBzZWVuLmFkZCh0ZWFtLmlkKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSk7XG59XG5cbi8vIEhlbHBlcjogZ2V0IGFsbCB0ZWFtcyB3aXRoIGV4YWN0bHkgTiBsb3NzZXNcbmZ1bmN0aW9uIHRlYW1zV2l0aExvc3Nlcyhsb3NzQ291bnRzOiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+LCBuOiBudW1iZXIpOiBzdHJpbmdbXSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyhsb3NzQ291bnRzKS5maWx0ZXIodGVhbUlkID0+IGxvc3NDb3VudHNbdGVhbUlkXSA9PT0gbik7XG59XG5cbmV4cG9ydCBjb25zdCBhZHZhbmNlVG9OZXh0Um91bmQgPSAodG91cm5hbWVudDogVG91cm5hbWVudCk6IFRvdXJuYW1lbnQgPT4ge1xuICBjb25zdCBjdXJyZW50Um91bmQgPSB0b3VybmFtZW50LnJvdW5kc1t0b3VybmFtZW50LnJvdW5kcy5sZW5ndGggLSAxXTtcbiAgY29uc3QgbmV4dFJvdW5kTnVtYmVyID0gdG91cm5hbWVudC5jdXJyZW50Um91bmQgKyAxO1xuXG4gIC8vIFRhbGx5IGxvc3NlcyBhbmQgd2luc1xuICBjb25zdCBsb3NzQ291bnRzOiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+ID0ge307XG4gIGNvbnN0IHdpbnNDb3VudHM6IFJlY29yZDxzdHJpbmcsIG51bWJlcj4gPSB7fTtcbiAgdG91cm5hbWVudC5yb3VuZHMuZm9yRWFjaCgocm91bmQpID0+IHtcbiAgICByb3VuZC5tYXRjaGVzLmZvckVhY2goKG1hdGNoKSA9PiB7XG4gICAgICBpZiAobWF0Y2guaXNDb21wbGV0ZWQgJiYgbWF0Y2gubG9zZXIpIHtcbiAgICAgICAgbG9zc0NvdW50c1ttYXRjaC5sb3Nlci5pZF0gPSAobG9zc0NvdW50c1ttYXRjaC5sb3Nlci5pZF0gfHwgMCkgKyAxO1xuICAgICAgfVxuICAgICAgaWYgKG1hdGNoLmlzQ29tcGxldGVkICYmIG1hdGNoLndpbm5lcikge1xuICAgICAgICB3aW5zQ291bnRzW21hdGNoLndpbm5lci5pZF0gPSAod2luc0NvdW50c1ttYXRjaC53aW5uZXIuaWRdIHx8IDApICsgMTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG5cbiAgLy8gSWYgd2lubmVyIGFscmVhZHkgZGV0ZXJtaW5lZCwgc3RvcFxuICBpZiAodG91cm5hbWVudC53aW5uZXIpIHtcbiAgICByZXR1cm4geyAuLi50b3VybmFtZW50LCBjdXJyZW50Um91bmQ6IHRvdXJuYW1lbnQuY3VycmVudFJvdW5kIH07XG4gIH1cblxuICAvLyBCdWlsZCBhbGwgdGVhbXNcbiAgY29uc3QgYWxsVGVhbXM6IFRlYW1bXSA9IFtdO1xuICBjb25zdCB0ZWFtSWRzID0gbmV3IFNldDxzdHJpbmc+KCk7XG4gIGZvciAoY29uc3Qgcm91bmQgb2YgdG91cm5hbWVudC5yb3VuZHMpIHtcbiAgICBmb3IgKGNvbnN0IG1hdGNoIG9mIHJvdW5kLm1hdGNoZXMpIHtcbiAgICAgIGlmIChtYXRjaC50ZWFtMSAmJiAhdGVhbUlkcy5oYXMobWF0Y2gudGVhbTEuaWQpKSB7XG4gICAgICAgIGFsbFRlYW1zLnB1c2goe1xuICAgICAgICAgIC4uLm1hdGNoLnRlYW0xLFxuICAgICAgICAgIHdpbnM6IHdpbnNDb3VudHNbbWF0Y2gudGVhbTEuaWRdIHx8IDAsXG4gICAgICAgICAgbG9zc2VzOiBsb3NzQ291bnRzW21hdGNoLnRlYW0xLmlkXSB8fCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0ZWFtSWRzLmFkZChtYXRjaC50ZWFtMS5pZCk7XG4gICAgICB9XG4gICAgICBpZiAobWF0Y2gudGVhbTIgJiYgIXRlYW1JZHMuaGFzKG1hdGNoLnRlYW0yLmlkKSkge1xuICAgICAgICBhbGxUZWFtcy5wdXNoKHtcbiAgICAgICAgICAuLi5tYXRjaC50ZWFtMixcbiAgICAgICAgICB3aW5zOiB3aW5zQ291bnRzW21hdGNoLnRlYW0yLmlkXSB8fCAwLFxuICAgICAgICAgIGxvc3NlczogbG9zc0NvdW50c1ttYXRjaC50ZWFtMi5pZF0gfHwgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGVhbUlkcy5hZGQobWF0Y2gudGVhbTIuaWQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIEZpbmQgbmV3bHkgZWxpbWluYXRlZFxuICBjb25zdCBuZXdseUVsaW1pbmF0ZWQ6IFRlYW1bXSA9IFtdO1xuICBmb3IgKGNvbnN0IHRlYW0gb2YgYWxsVGVhbXMpIHtcbiAgICBpZiAoKGxvc3NDb3VudHNbdGVhbS5pZF0gfHwgMCkgPj0gMiAmJiAhdG91cm5hbWVudC5lbGltaW5hdGVkVGVhbXMuc29tZSgodCkgPT4gdC5pZCA9PT0gdGVhbS5pZCkpIHtcbiAgICAgIG5ld2x5RWxpbWluYXRlZC5wdXNoKHRlYW0pO1xuICAgIH1cbiAgfVxuXG4gIC8vIFdpbm5lcnMgYnJhY2tldDogMCBsb3NzZXNcbiAgY29uc3Qgd2lubmVyc0JyYWNrZXRUZWFtcyA9IGFsbFRlYW1zLmZpbHRlcihcbiAgICAodGVhbSkgPT4gKGxvc3NDb3VudHNbdGVhbS5pZF0gfHwgMCkgPT09IDAgJiZcbiAgICAgICF0b3VybmFtZW50LmVsaW1pbmF0ZWRUZWFtcy5zb21lKCh0KSA9PiB0LmlkID09PSB0ZWFtLmlkKSAmJlxuICAgICAgIW5ld2x5RWxpbWluYXRlZC5zb21lKCh0KSA9PiB0LmlkID09PSB0ZWFtLmlkKSAmJlxuICAgICAgIXRlYW0uaWQuc3RhcnRzV2l0aChcInRiZC1cIilcbiAgKTtcbiAgLy8gTG9zZXJzIGJyYWNrZXQ6IDEgbG9zc1xuICBjb25zdCBsb3NlcnNCcmFja2V0VGVhbXMgPSBhbGxUZWFtcy5maWx0ZXIoXG4gICAgKHRlYW0pID0+IChsb3NzQ291bnRzW3RlYW0uaWRdIHx8IDApID09PSAxICYmXG4gICAgICAhdG91cm5hbWVudC5lbGltaW5hdGVkVGVhbXMuc29tZSgodCkgPT4gdC5pZCA9PT0gdGVhbS5pZCkgJiZcbiAgICAgICFuZXdseUVsaW1pbmF0ZWQuc29tZSgodCkgPT4gdC5pZCA9PT0gdGVhbS5pZClcbiAgKTtcblxuICBsZXQgbmV4dFJvdW5kTWF0Y2hlczogTWF0Y2hbXSA9IFtdO1xuICBsZXQgaXNDaGFtcGlvbnNoaXAgPSBmYWxzZTtcbiAgbGV0IGNoYW1waW9uc2hpcE1hdGNoZXNQbGF5ZWQgPSB0b3VybmFtZW50LmNoYW1waW9uc2hpcE1hdGNoZXNQbGF5ZWQgfHwgMDtcbiAgbGV0IHdpbm5lcjogVGVhbSB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcblxuICAvLyAtLS0gQ0hBTVBJT05TSElQIExPR0lDIC0tLVxuICAvLyBJZiBvbmx5IHR3byB0ZWFtcyByZW1haW4gYW5kIG9uZSBoYXMgbm8gbG9zc2VzLCBvbmUgaGFzIG9uZSBsb3NzLCBpdCdzIHRpbWUgZm9yIGNoYW1waW9uc2hpcFxuICBpZiAod2lubmVyc0JyYWNrZXRUZWFtcy5sZW5ndGggPT09IDEgJiYgbG9zZXJzQnJhY2tldFRlYW1zLmxlbmd0aCA9PT0gMSkge1xuICAgIGNvbnN0IFdCID0gd2lubmVyc0JyYWNrZXRUZWFtc1swXTtcbiAgICBjb25zdCBMQiA9IGxvc2Vyc0JyYWNrZXRUZWFtc1swXTtcbiAgICAvLyBGaW5kIHByZXZpb3VzIGNoYW1waW9uc2hpcCBtYXRjaGVzXG4gICAgY29uc3QgcHJldkNoYW1wID0gdG91cm5hbWVudC5yb3VuZHMuZmlsdGVyKHIgPT4gci5pc0NoYW1waW9uc2hpcCkuZmxhdE1hcChyID0+IHIubWF0Y2hlcyk7XG4gICAgY29uc3QgbGFzdENoYW1wID0gcHJldkNoYW1wLmxlbmd0aCA+IDAgPyBwcmV2Q2hhbXBbcHJldkNoYW1wLmxlbmd0aCAtIDFdIDogdW5kZWZpbmVkO1xuICAgIGlmICghbGFzdENoYW1wIHx8IChsYXN0Q2hhbXAgJiYgbGFzdENoYW1wLmlzQ29tcGxldGVkICYmIGxhc3RDaGFtcC53aW5uZXIgJiYgY2hhbXBpb25zaGlwTWF0Y2hlc1BsYXllZCA8IDIgJiYgbGFzdENoYW1wLndpbm5lci5pZCA9PT0gTEIuaWQpKSB7XG4gICAgICAvLyBTY2hlZHVsZSBhIGNoYW1waW9uc2hpcCBtYXRjaCBpZjpcbiAgICAgIC8vIC0gTm8gY2hhbXBpb25zaGlwIG1hdGNoIHlldFxuICAgICAgLy8gLSBPUiBMQiB3b24gdGhlIGZpcnN0LCBzbyBuZWVkIGEgc2Vjb25kXG4gICAgICBuZXh0Um91bmRNYXRjaGVzLnB1c2goY3JlYXRlTWF0Y2goYEMke25leHRSb3VuZE51bWJlcn0tJHtjaGFtcGlvbnNoaXBNYXRjaGVzUGxheWVkKzF9YCwgbmV4dFJvdW5kTnVtYmVyLCBXQiwgTEIsIGZhbHNlLCBcImNoYW1waW9uc2hpcFwiKSk7XG4gICAgICBpc0NoYW1waW9uc2hpcCA9IHRydWU7XG4gICAgICBjaGFtcGlvbnNoaXBNYXRjaGVzUGxheWVkICs9IDE7XG4gICAgfSBlbHNlIGlmIChsYXN0Q2hhbXAgJiYgbGFzdENoYW1wLmlzQ29tcGxldGVkICYmIGxhc3RDaGFtcC53aW5uZXIpIHtcbiAgICAgIC8vIElmIFdCIHdpbnMgYW55IGNoYW1waW9uc2hpcCwgdGhleSB3aW4uIElmIExCIHdpbnMgdHdvLCB0aGV5IHdpbi5cbiAgICAgIHdpbm5lciA9IGxhc3RDaGFtcC53aW5uZXI7XG4gICAgfVxuICB9XG4vLyBJZiBtb3JlIHRoYW4gMiB0ZWFtcyByZW1haW4sIGNvbnRpbnVlIHdpdGggbm9ybWFsIGJyYWNrZXQgcGxheVxuXG4gIC8vIFByZXZlbnQgY3JlYXRpbmcgYSByb3VuZCBpZiBvbmx5IHdhaXRpbmcgY2FyZHMgKFRCRC9udWxsKSB3b3VsZCBiZSBzY2hlZHVsZWRcbiAgaWYgKFxuICAgIG5leHRSb3VuZE1hdGNoZXMubGVuZ3RoID4gMCAmJlxuICAgIG5leHRSb3VuZE1hdGNoZXMuZXZlcnkoXG4gICAgICAobSkgPT4gIW0udGVhbTIgfHwgbS50ZWFtMi5pZC5zdGFydHNXaXRoKCd0YmQnKSB8fCBtLnRlYW0yID09PSBudWxsXG4gICAgKVxuICApIHtcbiAgICAvLyBBbGwgbWF0Y2hlcyBhcmUgd2FpdGluZyBjYXJkcywgZG8gbm90IGNyZWF0ZSBhIG5ldyByb3VuZFxuICAgIHJldHVybiB7XG4gICAgICAuLi50b3VybmFtZW50LFxuICAgICAgY3VycmVudFJvdW5kOiB0b3VybmFtZW50LmN1cnJlbnRSb3VuZFxuICAgIH07XG4gIH1cbiAgLy8gQ2hlY2sgaWYgd2UgbmVlZCB0byBjcmVhdGUgdGhlIGZpbmFsIGxvc2VycyBicmFja2V0IG1hdGNoICh3aW5uZXJzIGJyYWNrZXQgZmluYWwgbG9zZXIgdnMgbG9zZXJzIGJyYWNrZXQgd2lubmVyKVxuICBlbHNlIGlmIChcbiAgICB3aW5uZXJzQnJhY2tldFRlYW1zLmxlbmd0aCA9PT0gMSAmJlxuICAgIHRvdXJuYW1lbnQud2lubmVyc0JyYWNrZXRGaW5hbExvc2VyXG4gICkge1xuICAgIGlmIChsb3NlcnNCcmFja2V0VGVhbXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAvLyBQcmV2ZW50IGR1cGxpY2F0ZSBsb3NlcnMgYnJhY2tldCBmaW5hbDogY2hlY2sgYWxsIHByZXZpb3VzIHJvdW5kcyBmb3IgdGhpcyBtYXRjaFxuICAgICAgbGV0IGFscmVhZHlQbGF5ZWQgPSBmYWxzZTtcbiAgICAgIGZvciAobGV0IHJvdW5kIG9mIHRvdXJuYW1lbnQucm91bmRzKSB7XG4gICAgICAgIGlmICghcm91bmQubWF0Y2hlcykgY29udGludWU7XG4gICAgICAgIGZvciAobGV0IG0gb2Ygcm91bmQubWF0Y2hlcykge1xuICAgICAgICAgIGNvbnN0IGlkcyA9IFttLnRlYW0xPy5pZCwgbS50ZWFtMj8uaWRdLmZpbHRlcihCb29sZWFuKS5zb3J0KCk7XG4gICAgICAgICAgY29uc3QgY3VycklkcyA9IFt0b3VybmFtZW50Lndpbm5lcnNCcmFja2V0RmluYWxMb3Nlci5pZCwgbG9zZXJzQnJhY2tldFRlYW1zWzBdLmlkXS5zb3J0KCk7XG4gICAgICAgICAgaWYgKGlkcy5sZW5ndGggPT09IDIgJiYgaWRzWzBdID09PSBjdXJySWRzWzBdICYmIGlkc1sxXSA9PT0gY3Vycklkc1sxXSkge1xuICAgICAgICAgICAgYWxyZWFkeVBsYXllZCA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFscmVhZHlQbGF5ZWQpIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKCFhbHJlYWR5UGxheWVkKSB7XG4gICAgICAgIC8vIE9ubHkgbm93IHNjaGVkdWxlIFdCRkwgdnMgTEJMXG4gICAgICAgIG5leHRSb3VuZE1hdGNoZXMucHVzaChcbiAgICAgICAgICBjcmVhdGVNYXRjaChcbiAgICAgICAgICAgIGBMb3NlcnNMYXN0LSR7bmV4dFJvdW5kTnVtYmVyfWAsXG4gICAgICAgICAgICBuZXh0Um91bmROdW1iZXIsXG4gICAgICAgICAgICB0b3VybmFtZW50Lndpbm5lcnNCcmFja2V0RmluYWxMb3NlciEsXG4gICAgICAgICAgICBsb3NlcnNCcmFja2V0VGVhbXNbMF0sXG4gICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgIFwibG9zZXJzXCJcbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgLi4udG91cm5hbWVudCxcbiAgICAgICAgICByb3VuZHM6IFtcbiAgICAgICAgICAgIC4uLnRvdXJuYW1lbnQucm91bmRzLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICByb3VuZE51bWJlcjogbmV4dFJvdW5kTnVtYmVyLFxuICAgICAgICAgICAgICBtYXRjaGVzOiBuZXh0Um91bmRNYXRjaGVzLFxuICAgICAgICAgICAgICBpc0RvdWJsZUVsaW1pbmF0aW9uOiB0cnVlLFxuICAgICAgICAgICAgICBpc0NoYW1waW9uc2hpcDogZmFsc2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBdLFxuICAgICAgICAgIGN1cnJlbnRSb3VuZDogbmV4dFJvdW5kTnVtYmVyLFxuICAgICAgICAgIGVsaW1pbmF0ZWRUZWFtczogW1xuICAgICAgICAgICAgLi4udG91cm5hbWVudC5lbGltaW5hdGVkVGVhbXMsXG4gICAgICAgICAgICAuLi5uZXdseUVsaW1pbmF0ZWQuZmlsdGVyKFxuICAgICAgICAgICAgICAodCkgPT4gIXRvdXJuYW1lbnQuZWxpbWluYXRlZFRlYW1zLnNvbWUoKGV0KSA9PiBldC5pZCA9PT0gdC5pZClcbiAgICAgICAgICAgIClcbiAgICAgICAgICBdLFxuICAgICAgICAgIGNoYW1waW9uc2hpcE1hdGNoZXNQbGF5ZWQ6IHRvdXJuYW1lbnQuY2hhbXBpb25zaGlwTWF0Y2hlc1BsYXllZCxcbiAgICAgICAgICB3aW5uZXJzQnJhY2tldEZpbmFsTG9zZXI6IHRvdXJuYW1lbnQud2lubmVyc0JyYWNrZXRGaW5hbExvc2VyLFxuICAgICAgICAgIHdpbm5lcjogdW5kZWZpbmVkXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICAvLyBJZiBtYXRjaCBhbHJlYWR5IHBsYXllZCwgZG8gbm90IHNjaGVkdWxlIGFnYWluOyBjaGFtcGlvbnNoaXAgbG9naWMgd2lsbCBoYW5kbGUgbmV4dCBzdGVwXG4gICAgfSBlbHNlIGlmIChsb3NlcnNCcmFja2V0VGVhbXMubGVuZ3RoID09PSAyKSB7XG4gICAgICAvLyBTY2hlZHVsZSB0aGUgbWF0Y2ggYmV0d2VlbiB0aGUgbGFzdCB0d28gbG9zZXJzIGJyYWNrZXQgdGVhbXNcbiAgICAgIG5leHRSb3VuZE1hdGNoZXMucHVzaChcbiAgICAgICAgY3JlYXRlTWF0Y2goXG4gICAgICAgICAgYEwke25leHRSb3VuZE51bWJlcn0tMWAsXG4gICAgICAgICAgbmV4dFJvdW5kTnVtYmVyLFxuICAgICAgICAgIGxvc2Vyc0JyYWNrZXRUZWFtc1swXSxcbiAgICAgICAgICBsb3NlcnNCcmFja2V0VGVhbXNbMV0sXG4gICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgXCJsb3NlcnNcIlxuICAgICAgICApXG4gICAgICApO1xuICAgICAgLy8gV0JGTCBpcyB3YWl0aW5nIGZvciB0aGUgd2lubmVyXG4gICAgICBuZXh0Um91bmRNYXRjaGVzLnB1c2goXG4gICAgICAgIGNyZWF0ZU1hdGNoKFxuICAgICAgICAgIGBXaW5uZXJzRmluYWxMb3Nlci13YWl0aW5nLSR7bmV4dFJvdW5kTnVtYmVyfWAsXG4gICAgICAgICAgbmV4dFJvdW5kTnVtYmVyLFxuICAgICAgICAgIHRvdXJuYW1lbnQud2lubmVyc0JyYWNrZXRGaW5hbExvc2VyLFxuICAgICAgICAgIG51bGwsXG4gICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICBcImxvc2Vyc1wiXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfSBlbHNlIGlmIChsb3NlcnNCcmFja2V0VGVhbXMubGVuZ3RoID4gMikge1xuICAgICAgLy8gTW9yZSB0aGFuIDIgdGVhbXM6IHBhaXIgb2ZmIGFzIHVzdWFsLCBXQkZMIHdhaXRzXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxvc2Vyc0JyYWNrZXRUZWFtcy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICBjb25zdCB0ZWFtMSA9IGxvc2Vyc0JyYWNrZXRUZWFtc1tpXTtcbiAgICAgICAgY29uc3QgdGVhbTIgPSBsb3NlcnNCcmFja2V0VGVhbXNbaSArIDFdID8/IG51bGw7XG4gICAgICAgIG5leHRSb3VuZE1hdGNoZXMucHVzaChcbiAgICAgICAgICBjcmVhdGVNYXRjaChcbiAgICAgICAgICAgIGBMJHtuZXh0Um91bmROdW1iZXJ9LSR7TWF0aC5mbG9vcihpIC8gMikgKyAxfWAsXG4gICAgICAgICAgICBuZXh0Um91bmROdW1iZXIsXG4gICAgICAgICAgICB0ZWFtMSxcbiAgICAgICAgICAgIHRlYW0yLFxuICAgICAgICAgICAgIXRlYW0yLFxuICAgICAgICAgICAgXCJsb3NlcnNcIlxuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIG5leHRSb3VuZE1hdGNoZXMucHVzaChcbiAgICAgICAgY3JlYXRlTWF0Y2goXG4gICAgICAgICAgYFdpbm5lcnNGaW5hbExvc2VyLXdhaXRpbmctJHtuZXh0Um91bmROdW1iZXJ9YCxcbiAgICAgICAgICBuZXh0Um91bmROdW1iZXIsXG4gICAgICAgICAgdG91cm5hbWVudC53aW5uZXJzQnJhY2tldEZpbmFsTG9zZXIsXG4gICAgICAgICAgbnVsbCxcbiAgICAgICAgICB0cnVlLFxuICAgICAgICAgIFwibG9zZXJzXCJcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gV0JGTCBpcyB3YWl0aW5nIGZvciB0aGUgbG9zZXJzIGJyYWNrZXQgdG8gcmVzb2x2ZVxuICAgICAgbmV4dFJvdW5kTWF0Y2hlcy5wdXNoKFxuICAgICAgICBjcmVhdGVNYXRjaChcbiAgICAgICAgICBgV2lubmVyc0ZpbmFsTG9zZXItd2FpdGluZy0ke25leHRSb3VuZE51bWJlcn1gLFxuICAgICAgICAgIG5leHRSb3VuZE51bWJlcixcbiAgICAgICAgICB0b3VybmFtZW50Lndpbm5lcnNCcmFja2V0RmluYWxMb3NlcixcbiAgICAgICAgICBudWxsLFxuICAgICAgICAgIHRydWUsXG4gICAgICAgICAgXCJsb3NlcnNcIlxuICAgICAgICApXG4gICAgICApO1xuICAgIH1cbiAgICAvLyBBbHdheXMgc2hvdyBhIHdhaXRpbmcgY2FyZCBmb3IgdGhlIHdpbm5lcnMgYnJhY2tldCBjaGFtcGlvbiBpZiBub3QgaW4gY2hhbXBpb25zaGlwXG4gICAgbmV4dFJvdW5kTWF0Y2hlcy5wdXNoKFxuICAgICAgY3JlYXRlTWF0Y2goXG4gICAgICAgIGBXaW5uZXJzQnJhY2tldENoYW1waW9uLXdhaXRpbmctJHtuZXh0Um91bmROdW1iZXJ9YCxcbiAgICAgICAgbmV4dFJvdW5kTnVtYmVyLFxuICAgICAgICB3aW5uZXJzQnJhY2tldFRlYW1zWzBdLFxuICAgICAgICBudWxsLFxuICAgICAgICB0cnVlLFxuICAgICAgICBcIndpbm5lcnNcIlxuICAgICAgKVxuICAgICk7XG4gIH1cbiAgLy8gQ2hlY2sgaWYgdGhpcyBpcyB0aGUgd2lubmVyJ3MgYnJhY2tldCBmaW5hbCAoZXhhY3RseSAyIHRlYW1zIGluIHdpbm5lcidzIGJyYWNrZXQpXG4gIGVsc2UgaWYgKHdpbm5lcnNCcmFja2V0VGVhbXMubGVuZ3RoID09PSAyKSB7XG4gICAgLy8gQ3JlYXRlIHRoZSB3aW5uZXIncyBicmFja2V0IGZpbmFsIG1hdGNoXG4gICAgbmV4dFJvdW5kTWF0Y2hlcy5wdXNoKFxuICAgICAgY3JlYXRlTWF0Y2goXG4gICAgICAgIGBXJHtuZXh0Um91bmROdW1iZXJ9LTFgLFxuICAgICAgICBuZXh0Um91bmROdW1iZXIsXG4gICAgICAgIHdpbm5lcnNCcmFja2V0VGVhbXNbMF0sXG4gICAgICAgIHdpbm5lcnNCcmFja2V0VGVhbXNbMV0sXG4gICAgICAgIGZhbHNlLFxuICAgICAgICBcIndpbm5lcnNcIlxuICAgICAgKVxuICAgICk7XG5cbiAgICAvLyBDb250aW51ZSB3aXRoIGxvc2VycyBicmFja2V0IG1hdGNoZXMgc2VwYXJhdGVseVxuICAgIGNyZWF0ZUxvc2Vyc0JyYWNrZXRNYXRjaGVzKCk7XG4gIH1cbiAgLy8gT3RoZXJ3aXNlLCBjb250aW51ZSB3aXRoIG5vcm1hbCBicmFja2V0IHBsYXlcbiAgZWxzZSB7XG4gICAgY3JlYXRlU3RhbmRhcmRCcmFja2V0TWF0Y2hlcygpO1xuICB9XG5cbiAgLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGNyZWF0ZSBzdGFuZGFyZCBicmFja2V0IG1hdGNoZXNcbiAgZnVuY3Rpb24gY3JlYXRlU3RhbmRhcmRCcmFja2V0TWF0Y2hlcygpIHtcbiAgICAvLyAtLS0gV2lubmVycyBCcmFja2V0IE1hdGNoZXMgLS0tXG4gICAgbGV0IG1hdGNoQ291bnRlciA9IDE7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB3aW5uZXJzQnJhY2tldFRlYW1zLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICBjb25zdCB0ZWFtMSA9IHdpbm5lcnNCcmFja2V0VGVhbXNbaV07XG4gICAgICBjb25zdCB0ZWFtMiA9IHdpbm5lcnNCcmFja2V0VGVhbXNbaSArIDFdID8/IG51bGw7XG4gICAgICBjb25zdCBpc0J5ZSA9ICF0ZWFtMjtcbiAgICAgIG5leHRSb3VuZE1hdGNoZXMucHVzaChcbiAgICAgICAgY3JlYXRlTWF0Y2goXG4gICAgICAgICAgYFcke25leHRSb3VuZE51bWJlcn0tJHttYXRjaENvdW50ZXJ9YCxcbiAgICAgICAgICBuZXh0Um91bmROdW1iZXIsXG4gICAgICAgICAgdGVhbTEsXG4gICAgICAgICAgdGVhbTIsXG4gICAgICAgICAgaXNCeWUsXG4gICAgICAgICAgXCJ3aW5uZXJzXCJcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICAgIG1hdGNoQ291bnRlcisrO1xuICAgIH1cblxuICAgIC8vIENyZWF0ZSBsb3NlcnMgYnJhY2tldCBtYXRjaGVzIHNlcGFyYXRlbHlcbiAgICBjcmVhdGVMb3NlcnNCcmFja2V0TWF0Y2hlcygpO1xuICB9XG5cbiAgLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGNyZWF0ZSBsb3NlcnMgYnJhY2tldCBtYXRjaGVzXG4gIGZ1bmN0aW9uIGNyZWF0ZUxvc2Vyc0JyYWNrZXRNYXRjaGVzKCkge1xuICAgIC8vIC0tLSBMb3NlcnMgQnJhY2tldCBNYXRjaGVzIC0tLVxuICAgIGNvbnN0IGVsaWdpYmxlTG9zZXJzID0gYWxsVGVhbXMuZmlsdGVyKFxuICAgICAgKHRlYW0pID0+XG4gICAgICAgIChsb3NzQ291bnRzW3RlYW0uaWRdIHx8IDApID09PSAxICYmXG4gICAgICAgICF0b3VybmFtZW50LmVsaW1pbmF0ZWRUZWFtcy5zb21lKCh0KSA9PiB0LmlkID09PSB0ZWFtLmlkKSAmJlxuICAgICAgICAhbmV3bHlFbGltaW5hdGVkLnNvbWUoKHQpID0+IHQuaWQgPT09IHRlYW0uaWQpICYmXG4gICAgICAgIC8vIEV4Y2x1ZGUgd2lubmVyJ3MgYnJhY2tldCBmaW5hbCBsb3NlciBpZiBpdCBleGlzdHNcbiAgICAgICAgIShcbiAgICAgICAgICB0b3VybmFtZW50Lndpbm5lcnNCcmFja2V0RmluYWxMb3NlciAmJlxuICAgICAgICAgIHRvdXJuYW1lbnQud2lubmVyc0JyYWNrZXRGaW5hbExvc2VyLmlkID09PSB0ZWFtLmlkXG4gICAgICAgIClcbiAgICApO1xuXG4gICAgLy8gRmluZCB0ZWFtcyByZWNlbnRseSBkcm9wcGVkIGZyb20gd2lubmVycyBicmFja2V0XG4gICAgY29uc3QganVzdERyb3BwZWRGcm9tV2lubmVycyA9IGN1cnJlbnRSb3VuZC5tYXRjaGVzXG4gICAgICAuZmlsdGVyKChtKSA9PiBtLmJyYWNrZXQgPT09IFwid2lubmVyc1wiICYmIG0ubG9zZXIgJiYgbS5pc0NvbXBsZXRlZClcbiAgICAgIC5tYXAoKG0pID0+IG0ubG9zZXIhKVxuICAgICAgLmZpbHRlcigobG9zZXIpID0+IGVsaWdpYmxlTG9zZXJzLnNvbWUoKHQpID0+IHQuaWQgPT09IGxvc2VyLmlkKSk7XG5cbiAgICAvLyBJZiB0aGlzIGlzIHRoZSB3aW5uZXIncyBicmFja2V0IGZpbmFsLCBzdG9yZSB0aGUgbG9zZXIgZm9yIGxhdGVyIHVzZVxuICAgIGlmIChcbiAgICAgIGN1cnJlbnRSb3VuZC5tYXRjaGVzLnNvbWUoXG4gICAgICAgIChtKSA9PlxuICAgICAgICAgIG0uYnJhY2tldCA9PT0gXCJ3aW5uZXJzXCIgJiZcbiAgICAgICAgICB3aW5uZXJzQnJhY2tldFRlYW1zLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgICAgIG0ubG9zZXIgJiZcbiAgICAgICAgICBtLmlzQ29tcGxldGVkXG4gICAgICApXG4gICAgKSB7XG4gICAgICAvLyBUaGlzIGlzIGEgc3BlY2lhbCBjYXNlIC0gd2UgZm91bmQgdGhlIHdpbm5lcidzIGJyYWNrZXQgZmluYWwgbG9zZXJcbiAgICAgIGNvbnN0IHdpbm5lcnNGaW5hbExvc2VyID0gY3VycmVudFJvdW5kLm1hdGNoZXNcbiAgICAgICAgLmZpbHRlcigobSkgPT4gbS5icmFja2V0ID09PSBcIndpbm5lcnNcIiAmJiBtLmlzQ29tcGxldGVkICYmIG0ubG9zZXIpXG4gICAgICAgIC5tYXAoKG0pID0+IG0ubG9zZXIhKVxuICAgICAgICAucG9wKCk7XG5cbiAgICAgIGlmIChcbiAgICAgICAgd2lubmVyc0ZpbmFsTG9zZXIgJiZcbiAgICAgICAgIXRvdXJuYW1lbnQuZWxpbWluYXRlZFRlYW1zLnNvbWUoKHQpID0+IHQuaWQgPT09IHdpbm5lcnNGaW5hbExvc2VyLmlkKVxuICAgICAgKSB7XG4gICAgICAgIHRvdXJuYW1lbnQud2lubmVyc0JyYWNrZXRGaW5hbExvc2VyID0gd2lubmVyc0ZpbmFsTG9zZXI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gRXhpc3RpbmcgbG9zZXJzIGJyYWNrZXQgdGVhbXNcbiAgICBjb25zdCBleGlzdGluZ0xvc2VycyA9IGVsaWdpYmxlTG9zZXJzLmZpbHRlcihcbiAgICAgICh0KSA9PiAhanVzdERyb3BwZWRGcm9tV2lubmVycy5zb21lKChqZCkgPT4gamQuaWQgPT09IHQuaWQpXG4gICAgKTtcblxuICAgIC8vIE9yZGVyOiBtb3N0IHJlY2VudCBkcm9wKHMpIGZpcnN0XG4gICAgY29uc3Qgb3JkZXJlZExvc2VycyA9IFsuLi5qdXN0RHJvcHBlZEZyb21XaW5uZXJzLCAuLi5leGlzdGluZ0xvc2Vyc107XG5cbiAgICBpZiAob3JkZXJlZExvc2Vycy5sZW5ndGggPiAwKSB7XG4gICAgICBpZiAob3JkZXJlZExvc2Vycy5sZW5ndGggJSAyID09PSAxKSB7XG4gICAgICAgIC8vIE9kZDogYnllIGdvZXMgdG8gdGhlIG1vc3QgcmVjZW50IHRlYW0gZHJvcHBlZCBmcm9tIHdpbm5lcnMgYnJhY2tldFxuICAgICAgICBsZXQgdGVhbVdpdGhCeWU6IFRlYW0gfCBudWxsID0gbnVsbDtcbiAgICAgICAgaWYgKGp1c3REcm9wcGVkRnJvbVdpbm5lcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHRlYW1XaXRoQnllID1cbiAgICAgICAgICAgIGp1c3REcm9wcGVkRnJvbVdpbm5lcnNbanVzdERyb3BwZWRGcm9tV2lubmVycy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAvLyBSZW1vdmUgdGhlIGJ5ZSB0ZWFtIGZyb20gb3JkZXJlZExvc2Vyc1xuICAgICAgICAgIGNvbnN0IGJ5ZUluZGV4ID0gb3JkZXJlZExvc2Vycy5maW5kSW5kZXgoXG4gICAgICAgICAgICAodCkgPT4gdC5pZCA9PT0gdGVhbVdpdGhCeWUhLmlkXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpZiAoYnllSW5kZXggIT09IC0xKSBvcmRlcmVkTG9zZXJzLnNwbGljZShieWVJbmRleCwgMSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gRGVmZW5zaXZlOiBmYWxsYmFjayB0byBmaXJzdCB0ZWFtIGlmIG5vIHJlY2VudCBkcm9wXG4gICAgICAgICAgdGVhbVdpdGhCeWUgPSBvcmRlcmVkTG9zZXJzLnNoaWZ0KCkhO1xuICAgICAgICB9XG4gICAgICAgIG5leHRSb3VuZE1hdGNoZXMucHVzaChcbiAgICAgICAgICBjcmVhdGVNYXRjaChcbiAgICAgICAgICAgIGBMJHtuZXh0Um91bmROdW1iZXJ9LTFgLFxuICAgICAgICAgICAgbmV4dFJvdW5kTnVtYmVyLFxuICAgICAgICAgICAgdGVhbVdpdGhCeWUsXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAgIFwibG9zZXJzXCJcbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICAgIC8vIFBhaXIgdGhlIHJlc3RcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvcmRlcmVkTG9zZXJzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgY29uc3QgdGVhbTEgPSBvcmRlcmVkTG9zZXJzW2ldO1xuICAgICAgICAgIGNvbnN0IHRlYW0yID0gb3JkZXJlZExvc2Vyc1tpICsgMV0gPz8gbnVsbDtcbiAgICAgICAgICBuZXh0Um91bmRNYXRjaGVzLnB1c2goXG4gICAgICAgICAgICBjcmVhdGVNYXRjaChcbiAgICAgICAgICAgICAgYEwke25leHRSb3VuZE51bWJlcn0tJHtNYXRoLmZsb29yKGkgLyAyKSArIDF9YCxcbiAgICAgICAgICAgICAgbmV4dFJvdW5kTnVtYmVyLFxuICAgICAgICAgICAgICB0ZWFtMSxcbiAgICAgICAgICAgICAgdGVhbTIsXG4gICAgICAgICAgICAgICF0ZWFtMixcbiAgICAgICAgICAgICAgXCJsb3NlcnNcIlxuICAgICAgICAgICAgKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEV2ZW4gbnVtYmVyOiBwYWlyIGFsbFxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9yZGVyZWRMb3NlcnMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICBjb25zdCB0ZWFtMSA9IG9yZGVyZWRMb3NlcnNbaV07XG4gICAgICAgICAgY29uc3QgdGVhbTIgPSBvcmRlcmVkTG9zZXJzW2kgKyAxXSA/PyBudWxsO1xuICAgICAgICAgIG5leHRSb3VuZE1hdGNoZXMucHVzaChcbiAgICAgICAgICAgIGNyZWF0ZU1hdGNoKFxuICAgICAgICAgICAgICBgTCR7bmV4dFJvdW5kTnVtYmVyfS0ke01hdGguZmxvb3IoaSAvIDIpICsgMX1gLFxuICAgICAgICAgICAgICBuZXh0Um91bmROdW1iZXIsXG4gICAgICAgICAgICAgIHRlYW0xLFxuICAgICAgICAgICAgICB0ZWFtMixcbiAgICAgICAgICAgICAgIXRlYW0yLFxuICAgICAgICAgICAgICBcImxvc2Vyc1wiXG4gICAgICAgICAgICApXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIC0tLSBXaW5uZXIgZGV0ZWN0aW9uIGxvZ2ljIC0tLVxuICAvLyB3aW5uZXIgYWxyZWFkeSBkZWNsYXJlZCBhYm92ZTsgZG8gbm90IHJlZGVjbGFyZSBoZXJlXG5cbiAgaWYgKGlzQ2hhbXBpb25zaGlwKSB7XG4gICAgLy8gRmluZCB0aGUgbGFzdCBjaGFtcGlvbnNoaXAgbWF0Y2ggcGxheWVkXG4gICAgY29uc3QgbGFzdENoYW1wTWF0Y2ggPVxuICAgICAgY2hhbXBpb25zaGlwTWF0Y2hlc1swXSB8fFxuICAgICAgcHJldkNoYW1waW9uc2hpcE1hdGNoZXNbcHJldkNoYW1waW9uc2hpcE1hdGNoZXMubGVuZ3RoIC0gMV07XG5cbiAgICBpZiAoXG4gICAgICBsYXN0Q2hhbXBNYXRjaCAmJlxuICAgICAgbGFzdENoYW1wTWF0Y2guaXNDb21wbGV0ZWQgJiZcbiAgICAgIGxhc3RDaGFtcE1hdGNoLndpbm5lciAmJlxuICAgICAgbGFzdENoYW1wTWF0Y2gubG9zZXJcbiAgICApIHtcbiAgICAgIGNvbnN0IHdpbm5lcnNCcmFja2V0VGVhbSA9IGxhc3RDaGFtcE1hdGNoLnRlYW0xO1xuICAgICAgY29uc3QgbG9zZXJzQnJhY2tldFRlYW0gPSBsYXN0Q2hhbXBNYXRjaC50ZWFtMjtcbiAgICAgIGNvbnN0IGxvc2Vyc0JyYWNrZXRUZWFtV29uID1cbiAgICAgICAgbG9zZXJzQnJhY2tldFRlYW0gJiYgbGFzdENoYW1wTWF0Y2gud2lubmVyLmlkID09PSBsb3NlcnNCcmFja2V0VGVhbS5pZDtcblxuICAgICAgLy8gSWYgbG9zZXIncyBicmFja2V0IHRlYW0gd29uIGZpcnN0IGNoYW1waW9uc2hpcCBtYXRjaCwgd2lubmVyJ3MgYnJhY2tldCB0ZWFtIGdldHMgYW5vdGhlciBjaGFuY2VcbiAgICAgIGlmIChsb3NlcnNCcmFja2V0VGVhbVdvbiAmJiB0b3VybmFtZW50LmNoYW1waW9uc2hpcE1hdGNoZXNQbGF5ZWQgPT09IDEpIHtcbiAgICAgICAgd2lubmVyID0gdW5kZWZpbmVkOyAvLyBObyB3aW5uZXIgeWV0LCBuZWVkIHJlc2V0IG1hdGNoXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBFaXRoZXIgd2lubmVyJ3MgYnJhY2tldCB0ZWFtIHdvbiBmaXJzdCBtYXRjaCwgb3IgdGhpcyB3YXMgdGhlIHJlc2V0IG1hdGNoXG4gICAgICAgIHdpbm5lciA9IGxhc3RDaGFtcE1hdGNoLndpbm5lcjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBJZiBhIHdpbm5lciBoYXMgYmVlbiBmb3VuZCBhZnRlciBjaGFtcGlvbnNoaXAgbG9naWMsIERPIE5PVCBDUkVBVEUgTU9SRSBST1VORFNcbiAgaWYgKHdpbm5lcikge1xuICAgIHJldHVybiB7XG4gICAgICAuLi50b3VybmFtZW50LFxuICAgICAgd2lubmVyLFxuICAgICAgY3VycmVudFJvdW5kOiB0b3VybmFtZW50LmN1cnJlbnRSb3VuZFxuICAgIH07XG4gIH1cblxuICAvLyAtLS0gSU5GSU5JVEUgUkVDVVJTSU9OIEdVQVJEIC0tLVxuICBjb25zdCBub01vcmVNYXRjaGVzID1cbiAgICAoaXNDaGFtcGlvbnNoaXAgJiYgY2hhbXBpb25zaGlwTWF0Y2hlcy5sZW5ndGggPT09IDApIHx8XG4gICAgKCFpc0NoYW1waW9uc2hpcCAmJiBuZXh0Um91bmRNYXRjaGVzLmxlbmd0aCA9PT0gMCk7XG5cbiAgaWYgKG5vTW9yZU1hdGNoZXMpIHtcbiAgICAvLyBUb3VybmFtZW50IGlzIG92ZXIsIGRvIG5vdCBhZHZhbmNlIGZ1cnRoZXJcbiAgICByZXR1cm4ge1xuICAgICAgLi4udG91cm5hbWVudCxcbiAgICAgIHdpbm5lcixcbiAgICAgIGN1cnJlbnRSb3VuZDogdG91cm5hbWVudC5jdXJyZW50Um91bmRcbiAgICB9O1xuICB9XG5cbiAgLy8gRGVidWcgbG9nIGJlZm9yZSByZXR1cm5pbmcgdGhlIG5ldyB0b3VybmFtZW50IG9iamVjdFxuICBsb2dUb3VybmFtZW50U3RhdGUoe1xuICAgIHJvdW5kTnVtYmVyOiBuZXh0Um91bmROdW1iZXIsXG4gICAgd2lubmVyc0JyYWNrZXRUZWFtcyxcbiAgICBsb3NlcnNCcmFja2V0VGVhbXMsXG4gICAgbWF0Y2hlczogbmV4dFJvdW5kTWF0Y2hlcyxcbiAgICB3aW5uZXJzQnJhY2tldEZpbmFsTG9zZXI6IHRvdXJuYW1lbnQud2lubmVyc0JyYWNrZXRGaW5hbExvc2VyXG4gIH0pO1xuXG4gIC8vIFRoZSBmb2xsb3dpbmcgbG9naWMgc2hvdWxkIGJlIG91dHNpZGUgb2YgdGhlIGxvZ1RvdXJuYW1lbnRTdGF0ZSBvYmplY3RcbiAgLy8gKG1vdmUgdGhpcyB0byB0aGUgY29ycmVjdCBwcm9jZWR1cmFsIGxvY2F0aW9uIGluIHlvdXIgcm91bmQvbWF0Y2ggZ2VuZXJhdGlvbiBsb2dpYylcbiAgLy8gbmV4dFJvdW5kTWF0Y2hlcy5wdXNoKFxuICAvLyAgIGNyZWF0ZU1hdGNoKFxuICAvLyAgICAgYFcke25leHRSb3VuZE51bWJlcn0tJHttYXRjaENvdW50ZXJ9YCxcbiAgLy8gICAgIG5leHRSb3VuZE51bWJlcixcbiAgLy8gICAgIHRlYW0xLFxuICAvLyAgICAgdGVhbTIsXG4gIC8vICAgICBpc0J5ZSxcbiAgLy8gICAgIFwid2lubmVyc1wiXG4gIC8vICAgKVxuICAvLyApO1xuICAvLyBtYXRjaENvdW50ZXIrKztcblxuLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGNyZWF0ZSBsb3NlcnMgYnJhY2tldCBtYXRjaGVzXG5mdW5jdGlvbiBjcmVhdGVMb3NlcnNCcmFja2V0TWF0Y2hlcygpIHtcbiAgLy8gLS0tIExvc2VycyBCcmFja2V0IE1hdGNoZXMgLS0tXG4gIC8vIDEuIFNjaGVkdWxlIExvc2VycyBCcmFja2V0IEZpbmFsIGlmIGV4YWN0bHkgdHdvIHRlYW1zIGxlZnQgYW5kIFdCRiBsb3NlciBrbm93blxuICBpZiAoXG4gICAgbG9zZXJzQnJhY2tldFRlYW1zLmxlbmd0aCA9PT0gMiAmJlxuICAgIHRvdXJuYW1lbnQud2lubmVyc0JyYWNrZXRGaW5hbExvc2VyICYmXG4gICAgIWN1cnJlbnRSb3VuZC5tYXRjaGVzLnNvbWUoXG4gICAgICAobSkgPT4gbS5icmFja2V0ID09PSBcImxvc2Vyc1wiICYmIG0ucm91bmROdW1iZXIgPT09IG5leHRSb3VuZE51bWJlciAmJiBtLmlzQ29tcGxldGVkICE9PSBmYWxzZVxuICAgIClcbiAgKSB7XG4gICAgbmV4dFJvdW5kTWF0Y2hlcy5wdXNoKFxuICAgICAgY3JlYXRlTWF0Y2goXG4gICAgICAgIGBMJHtuZXh0Um91bmROdW1iZXJ9LUZgLFxuICAgICAgICBuZXh0Um91bmROdW1iZXIsXG4gICAgICAgIGxvc2Vyc0JyYWNrZXRUZWFtc1swXSxcbiAgICAgICAgbG9zZXJzQnJhY2tldFRlYW1zWzFdLFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgXCJsb3NlcnNcIlxuICAgICAgKVxuICAgICk7XG4gICAgcmV0dXJuOyAvLyBPbmx5IHNjaGVkdWxlIHRoZSBmaW5hbCwgbm90aGluZyBlbHNlIHRoaXMgcm91bmRcbiAgfVxuXG4gIC8vIDIuIFNjaGVkdWxlIENoYW1waW9uc2hpcCBpZiBsb3NlcnMgYnJhY2tldCBmaW5hbCBqdXN0IGNvbXBsZXRlZFxuICBpZiAoXG4gICAgdG91cm5hbWVudC53aW5uZXJzQnJhY2tldEZpbmFsTG9zZXIgJiZcbiAgICBjdXJyZW50Um91bmQubWF0Y2hlcy5zb21lKFxuICAgICAgKG0pID0+XG4gICAgICAgIG0uYnJhY2tldCA9PT0gXCJsb3NlcnNcIiAmJlxuICAgICAgICBbbG9zZXJzQnJhY2tldFRlYW1zWzBdPy5pZCwgbG9zZXJzQnJhY2tldFRlYW1zWzFdPy5pZF0uaW5jbHVkZXMobS50ZWFtMT8uaWQpICYmXG4gICAgICAgIFtsb3NlcnNCcmFja2V0VGVhbXNbMF0/LmlkLCBsb3NlcnNCcmFja2V0VGVhbXNbMV0/LmlkXS5pbmNsdWRlcyhtLnRlYW0yPy5pZCkgJiZcbiAgICAgICAgbS5pc0NvbXBsZXRlZCAmJlxuICAgICAgICBtLndpbm5lclxuICAgIClcbiAgKSB7XG4gICAgY29uc3QgbG9zZXJzQnJhY2tldFdpbm5lciA9IGN1cnJlbnRSb3VuZC5tYXRjaGVzXG4gICAgICAuZmlsdGVyKFxuICAgICAgICAobSkgPT5cbiAgICAgICAgICBtLmJyYWNrZXQgPT09IFwibG9zZXJzXCIgJiZcbiAgICAgICAgICBbbG9zZXJzQnJhY2tldFRlYW1zWzBdPy5pZCwgbG9zZXJzQnJhY2tldFRlYW1zWzFdPy5pZF0uaW5jbHVkZXMobS50ZWFtMT8uaWQpICYmXG4gICAgICAgICAgW2xvc2Vyc0JyYWNrZXRUZWFtc1swXT8uaWQsIGxvc2Vyc0JyYWNrZXRUZWFtc1sxXT8uaWRdLmluY2x1ZGVzKG0udGVhbTI/LmlkKSAmJlxuICAgICAgICAgIG0uaXNDb21wbGV0ZWQgJiZcbiAgICAgICAgICBtLndpbm5lclxuICAgICAgKVxuICAgICAgLm1hcCgobSkgPT4gbS53aW5uZXIhKVxuICAgICAgLnBvcCgpO1xuICAgIGlmIChsb3NlcnNCcmFja2V0V2lubmVyICYmIHdpbm5lcnNCcmFja2V0VGVhbXMubGVuZ3RoID4gMCkge1xuICAgICAgbmV4dFJvdW5kTWF0Y2hlcy5wdXNoKFxuICAgICAgICBjcmVhdGVNYXRjaChcbiAgICAgICAgICBgQyR7bmV4dFJvdW5kTnVtYmVyfS0xYCxcbiAgICAgICAgICBuZXh0Um91bmROdW1iZXIsXG4gICAgICAgICAgd2lubmVyc0JyYWNrZXRUZWFtc1swXSxcbiAgICAgICAgICBsb3NlcnNCcmFja2V0V2lubmVyLFxuICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgIFwiY2hhbXBpb25zaGlwXCJcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICAgIGlzQ2hhbXBpb25zaGlwID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gMy4gT3RoZXJ3aXNlLCBzY2hlZHVsZSBub3JtYWwgbG9zZXJzIGJyYWNrZXQgbWF0Y2hlc1xuICBjb25zdCBlbGlnaWJsZUxvc2VycyA9IGFsbFRlYW1zLmZpbHRlcihcbiAgICAodGVhbSkgPT5cbiAgICAgIChsb3NzQ291bnRzW3RlYW0uaWRdIHx8IDApID09PSAxICYmXG4gICAgICAhdG91cm5hbWVudC5lbGltaW5hdGVkVGVhbXMuc29tZSgodCkgPT4gdC5pZCA9PT0gdGVhbS5pZCkgJiZcbiAgICAgICFuZXdseUVsaW1pbmF0ZWQuc29tZSgodCkgPT4gdC5pZCA9PT0gdGVhbS5pZCkgJiZcbiAgICAgIC8vIEV4Y2x1ZGUgd2lubmVyJ3MgYnJhY2tldCBmaW5hbCBsb3NlciBpZiBpdCBleGlzdHNcbiAgICAgICEoXG4gICAgICAgIHRvdXJuYW1lbnQud2lubmVyc0JyYWNrZXRGaW5hbExvc2VyICYmXG4gICAgICAgIHRvdXJuYW1lbnQud2lubmVyc0JyYWNrZXRGaW5hbExvc2VyLmlkID09PSB0ZWFtLmlkXG4gICAgICApXG4gICk7XG5cbiAgLy8gRmluZCB0ZWFtcyByZWNlbnRseSBkcm9wcGVkIGZyb20gd2lubmVycyBicmFja2V0XG4gIGNvbnN0IGp1c3REcm9wcGVkRnJvbVdpbm5lcnMgPSBjdXJyZW50Um91bmQubWF0Y2hlc1xuICAgIC5maWx0ZXIoKG0pID0+IG0uYnJhY2tldCA9PT0gXCJ3aW5uZXJzXCIgJiYgbS5sb3NlciAmJiBtLmlzQ29tcGxldGVkKVxuICAgIC5tYXAoKG0pID0+IG0ubG9zZXIhKVxuICAgIC5maWx0ZXIoKGxvc2VyKSA9PiBlbGlnaWJsZUxvc2Vycy5zb21lKCh0KSA9PiB0LmlkID09PSBsb3Nlci5pZCkpO1xuXG4gIC8vIFNjaGVkdWxlIG1hdGNoZXMgZm9yIGVsaWdpYmxlIGxvc2VycyBhcyBuZWVkZWQgKGltcGxlbWVudCB5b3VyIHBhaXJpbmcgbG9naWMgaGVyZSlcbiAgLy8gLi4uXG59XG59XG4iXSwibmFtZXMiOlsibG9nVG91cm5hbWVudFN0YXRlIiwiY3JlYXRlTWF0Y2giLCJpZCIsInJvdW5kTnVtYmVyIiwidGVhbTEiLCJ0ZWFtMiIsImlzQnllIiwiYnJhY2tldCIsIm5leHRNYXRjaElkIiwibmV4dExvc2VyTWF0Y2hJZCIsImlzQ29tcGxldGVkIiwid2lubmVyIiwidW5kZWZpbmVkIiwibG9zZXIiLCJzY29yZSIsInRlYW0xU2NvcmUiLCJ0ZWFtMlNjb3JlIiwiZWxpbWluYXRlZExhYmVsIiwiY3JlYXRlSW5pdGlhbFJvdW5kcyIsInRlYW1zIiwibnVtVGVhbXMiLCJsZW5ndGgiLCJtYXRjaGVzIiwibnVtUm91bmRzIiwiTWF0aCIsImNlaWwiLCJsb2cyIiwiZmlyc3RSb3VuZE1hdGNoZXMiLCJwb3ciLCJtYXRjaENvdW50ZXIiLCJpIiwibWF0Y2hJZCIsInB1c2giLCJyb3VuZHMiLCJpc0RvdWJsZUVsaW1pbmF0aW9uIiwiaXNDaGFtcGlvbnNoaXAiLCJjdXJyZW50Um91bmQiLCJlbGltaW5hdGVkVGVhbXMiLCJjaGFtcGlvbnNoaXBNYXRjaGVzUGxheWVkIiwidXBkYXRlTWF0Y2hTY29yZSIsIm1hdGNoIiwibmV3U2NvcmUiLCJ3aW5zIiwibG9zc2VzIiwiZGVkdXBlVGVhbXMiLCJzZWVuIiwiU2V0IiwiZmlsdGVyIiwidGVhbSIsImhhcyIsImFkZCIsInRlYW1zV2l0aExvc3NlcyIsImxvc3NDb3VudHMiLCJuIiwiT2JqZWN0Iiwia2V5cyIsInRlYW1JZCIsImFkdmFuY2VUb05leHRSb3VuZCIsInRvdXJuYW1lbnQiLCJuZXh0Um91bmROdW1iZXIiLCJ3aW5zQ291bnRzIiwiZm9yRWFjaCIsInJvdW5kIiwiYWxsVGVhbXMiLCJ0ZWFtSWRzIiwibmV3bHlFbGltaW5hdGVkIiwic29tZSIsInQiLCJ3aW5uZXJzQnJhY2tldFRlYW1zIiwic3RhcnRzV2l0aCIsImxvc2Vyc0JyYWNrZXRUZWFtcyIsIm5leHRSb3VuZE1hdGNoZXMiLCJXQiIsIkxCIiwicHJldkNoYW1wIiwiciIsImZsYXRNYXAiLCJsYXN0Q2hhbXAiLCJldmVyeSIsIm0iLCJ3aW5uZXJzQnJhY2tldEZpbmFsTG9zZXIiLCJhbHJlYWR5UGxheWVkIiwiaWRzIiwiQm9vbGVhbiIsInNvcnQiLCJjdXJySWRzIiwiZXQiLCJmbG9vciIsImNyZWF0ZUxvc2Vyc0JyYWNrZXRNYXRjaGVzIiwiY3JlYXRlU3RhbmRhcmRCcmFja2V0TWF0Y2hlcyIsImVsaWdpYmxlTG9zZXJzIiwianVzdERyb3BwZWRGcm9tV2lubmVycyIsIm1hcCIsIndpbm5lcnNGaW5hbExvc2VyIiwicG9wIiwiZXhpc3RpbmdMb3NlcnMiLCJqZCIsIm9yZGVyZWRMb3NlcnMiLCJ0ZWFtV2l0aEJ5ZSIsImJ5ZUluZGV4IiwiZmluZEluZGV4Iiwic3BsaWNlIiwic2hpZnQiLCJsYXN0Q2hhbXBNYXRjaCIsImNoYW1waW9uc2hpcE1hdGNoZXMiLCJwcmV2Q2hhbXBpb25zaGlwTWF0Y2hlcyIsIndpbm5lcnNCcmFja2V0VGVhbSIsImxvc2Vyc0JyYWNrZXRUZWFtIiwibG9zZXJzQnJhY2tldFRlYW1Xb24iLCJub01vcmVNYXRjaGVzIiwiaW5jbHVkZXMiLCJsb3NlcnNCcmFja2V0V2lubmVyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./types/tournament/matches.ts\n"));

/***/ })

});
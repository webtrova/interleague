"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/tournament/page",{

/***/ "(app-pages-browser)/./types/tournament/matches.ts":
/*!*************************************!*\
  !*** ./types/tournament/matches.ts ***!
  \*************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   advanceToNextRound: function() { return /* binding */ advanceToNextRound; },\n/* harmony export */   createInitialRounds: function() { return /* binding */ createInitialRounds; },\n/* harmony export */   createMatch: function() { return /* binding */ createMatch; },\n/* harmony export */   updateMatchScore: function() { return /* binding */ updateMatchScore; }\n/* harmony export */ });\n/* harmony import */ var _logTournamentState__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./logTournamentState */ \"(app-pages-browser)/./types/tournament/logTournamentState.ts\");\n\nconst createMatch = function(id, roundNumber, team1, team2) {\n    let isBye = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : false, bracket = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : \"winners\", nextMatchId = arguments.length > 6 ? arguments[6] : void 0, nextLoserMatchId = arguments.length > 7 ? arguments[7] : void 0;\n    var _ref;\n    return {\n        id,\n        roundNumber,\n        team1,\n        team2,\n        isCompleted: isBye,\n        isBye,\n        bracket,\n        winner: isBye ? (_ref = team1 !== null && team1 !== void 0 ? team1 : team2) !== null && _ref !== void 0 ? _ref : undefined : undefined,\n        loser: isBye ? undefined : undefined,\n        score: {\n            team1Score: 0,\n            team2Score: 0\n        },\n        nextMatchId,\n        nextLoserMatchId,\n        eliminatedLabel: undefined\n    };\n};\nconst createInitialRounds = (teams)=>{\n    const numTeams = teams.length;\n    const matches = [];\n    const numRounds = Math.ceil(Math.log2(numTeams));\n    const firstRoundMatches = Math.pow(2, numRounds - 1);\n    let matchCounter = 1;\n    for(let i = 0; i < firstRoundMatches; i++){\n        const team1 = teams[i * 2] || null;\n        const team2 = teams[i * 2 + 1] || null;\n        const isBye = !team1 || !team2;\n        const matchId = \"W1-\".concat(matchCounter);\n        const nextMatchId = \"W2-\".concat(Math.ceil(matchCounter / 2));\n        const nextLoserMatchId = \"L1-\".concat(Math.ceil(matchCounter / 2));\n        matches.push(createMatch(matchId, 1, team1, team2, isBye, \"winners\", nextMatchId, nextLoserMatchId));\n        matchCounter++;\n    }\n    return {\n        rounds: [\n            {\n                roundNumber: 1,\n                matches,\n                isDoubleElimination: true,\n                isChampionshipRound: false\n            }\n        ],\n        currentRound: 1,\n        eliminatedTeams: [],\n        championshipMatchesPlayed: 0\n    };\n};\nconst updateMatchScore = (match, newScore)=>{\n    const isCompleted = newScore.team1Score !== newScore.team2Score;\n    let winner = undefined;\n    let loser = undefined;\n    if (isCompleted) {\n        if (newScore.team1Score > newScore.team2Score) {\n            var _match_team1_wins, _match_team1_losses;\n            winner = match.team1 ? {\n                ...match.team1,\n                wins: ((_match_team1_wins = match.team1.wins) !== null && _match_team1_wins !== void 0 ? _match_team1_wins : 0) + 1,\n                losses: (_match_team1_losses = match.team1.losses) !== null && _match_team1_losses !== void 0 ? _match_team1_losses : 0\n            } : undefined;\n            var _match_team2_wins, _match_team2_losses;\n            loser = match.team2 ? {\n                ...match.team2,\n                wins: (_match_team2_wins = match.team2.wins) !== null && _match_team2_wins !== void 0 ? _match_team2_wins : 0,\n                losses: ((_match_team2_losses = match.team2.losses) !== null && _match_team2_losses !== void 0 ? _match_team2_losses : 0) + 1\n            } : undefined;\n        } else {\n            var _match_team2_wins1, _match_team2_losses1;\n            winner = match.team2 ? {\n                ...match.team2,\n                wins: ((_match_team2_wins1 = match.team2.wins) !== null && _match_team2_wins1 !== void 0 ? _match_team2_wins1 : 0) + 1,\n                losses: (_match_team2_losses1 = match.team2.losses) !== null && _match_team2_losses1 !== void 0 ? _match_team2_losses1 : 0\n            } : undefined;\n            var _match_team1_wins1, _match_team1_losses1;\n            loser = match.team1 ? {\n                ...match.team1,\n                wins: (_match_team1_wins1 = match.team1.wins) !== null && _match_team1_wins1 !== void 0 ? _match_team1_wins1 : 0,\n                losses: ((_match_team1_losses1 = match.team1.losses) !== null && _match_team1_losses1 !== void 0 ? _match_team1_losses1 : 0) + 1\n            } : undefined;\n        }\n    }\n    return {\n        ...match,\n        score: newScore,\n        isCompleted,\n        winner,\n        loser\n    };\n};\n// Helper to deduplicate teams by ID\nfunction dedupeTeams(teams) {\n    const seen = new Set();\n    return teams.filter((team)=>{\n        if (!team) return false;\n        if (seen.has(team.id)) return false;\n        seen.add(team.id);\n        return true;\n    });\n}\n// Helper: get all teams with exactly N losses\nfunction teamsWithLosses(lossCounts, n) {\n    return Object.keys(lossCounts).filter((teamId)=>lossCounts[teamId] === n);\n}\nconst advanceToNextRound = (tournament)=>{\n    const currentRound = tournament.rounds[tournament.rounds.length - 1];\n    const nextRoundNumber = tournament.currentRound + 1;\n    // Track all losses and wins across the tournament\n    const lossCounts = {};\n    const winsCounts = {};\n    tournament.rounds.forEach((round)=>{\n        round.matches.forEach((match)=>{\n            if (match.isCompleted && match.loser) {\n                lossCounts[match.loser.id] = (lossCounts[match.loser.id] || 0) + 1;\n            }\n            if (match.isCompleted && match.winner) {\n                winsCounts[match.winner.id] = (winsCounts[match.winner.id] || 0) + 1;\n            }\n        });\n    });\n    // Gather all teams ever in the tournament, attaching wins\n    const allTeams = [];\n    const teamIds = new Set();\n    for (const round of tournament.rounds){\n        for (const match of round.matches){\n            if (match.team1 && !teamIds.has(match.team1.id)) {\n                allTeams.push({\n                    ...match.team1,\n                    wins: winsCounts[match.team1.id] || 0,\n                    losses: lossCounts[match.team1.id] || 0\n                });\n                teamIds.add(match.team1.id);\n            }\n            if (match.team2 && !teamIds.has(match.team2.id)) {\n                allTeams.push({\n                    ...match.team2,\n                    wins: winsCounts[match.team2.id] || 0,\n                    losses: lossCounts[match.team2.id] || 0\n                });\n                teamIds.add(match.team2.id);\n            }\n        }\n    }\n    // Identify newly eliminated teams (2 losses)\n    const newlyEliminated = [];\n    for (const team of allTeams){\n        if ((lossCounts[team.id] || 0) >= 2 && !tournament.eliminatedTeams.some((t)=>t.id === team.id)) {\n            newlyEliminated.push(team);\n        }\n    }\n    // Winners: teams with 0 losses and not eliminated\n    const winnersBracketTeams = allTeams.filter((team)=>(lossCounts[team.id] || 0) === 0 && !tournament.eliminatedTeams.some((t)=>t.id === team.id) && !newlyEliminated.some((t)=>t.id === team.id) && !team.id.startsWith(\"tbd-\") // Exclude phantom TBD teams\n    ).map((team)=>({\n            ...team,\n            losses: lossCounts[team.id] || 0,\n            wins: winsCounts[team.id] || 0\n        }));\n    // Losers: teams with 1 loss and not eliminated\n    const losersBracketTeams = allTeams.filter((team)=>(lossCounts[team.id] || 0) === 1 && !tournament.eliminatedTeams.some((t)=>t.id === team.id) && !newlyEliminated.some((t)=>t.id === team.id) && // Don't include the winners bracket final loser in regular losers bracket teams\n        !(tournament.winnersBracketFinalLoser && tournament.winnersBracketFinalLoser.id === team.id)).map((team)=>({\n            ...team,\n            losses: lossCounts[team.id] || 0,\n            wins: winsCounts[team.id] || 0\n        }));\n    let isChampionshipRound = false;\n    let championshipMatches = [];\n    let nextRoundMatches = [];\n    const prevChampionshipMatches = tournament.rounds.filter((r)=>r.isChampionshipRound).flatMap((r)=>r.matches).filter((m)=>m.bracket === \"championship\");\n    // --- CHAMPIONSHIP LOGIC ---\n    // Check if a championship match already happened and was completed\n    if (prevChampionshipMatches.length >= 1 && prevChampionshipMatches[prevChampionshipMatches.length - 1].isCompleted) {\n        var _lastChampMatch_winner;\n        const lastChampMatch = prevChampionshipMatches[prevChampionshipMatches.length - 1];\n        const winnersBracketTeam = lastChampMatch.team1;\n        const losersBracketTeam = lastChampMatch.team2;\n        // If loser's bracket team won the first championship match, winner's bracket team gets another chance\n        if (((_lastChampMatch_winner = lastChampMatch.winner) === null || _lastChampMatch_winner === void 0 ? void 0 : _lastChampMatch_winner.id) === (losersBracketTeam === null || losersBracketTeam === void 0 ? void 0 : losersBracketTeam.id) && tournament.championshipMatchesPlayed === 1) {\n            isChampionshipRound = true;\n            // Create the \"reset\" match\n            championshipMatches.push(createMatch(\"C\".concat(nextRoundNumber, \"-1\"), nextRoundNumber, winnersBracketTeam, losersBracketTeam, false, \"championship\"));\n        } else {\n            // Either winner's bracket team won first match, or this was the reset match\n            isChampionshipRound = true;\n        // No new matches, winner will be determined in winner detection logic\n        }\n    } else if (winnersBracketTeams.length === 1 && losersBracketTeams.length === 1 && currentRound.matches.some((m)=>(m.bracket === \"losers\" || m.id.includes(\"LosersLast\")) && m.isCompleted && m.winner && (losersBracketTeams.some((t)=>t.id === m.winner.id) || tournament.winnersBracketFinalLoser && m.winner.id === tournament.winnersBracketFinalLoser.id))) {\n        // Find the winner of the losers bracket final\n        const losersBracketWinner = currentRound.matches.filter((m)=>(m.bracket === \"losers\" || m.id.includes(\"LosersLast\")) && m.isCompleted && m.winner).map((m)=>m.winner).pop();\n        if (losersBracketWinner) {\n            // Only schedule the championship if there is no winnersBracketFinalLoser waiting to play\n            if (!tournament.winnersBracketFinalLoser) {\n                isChampionshipRound = true;\n                championshipMatches.push(createMatch(\"C\".concat(nextRoundNumber, \"-1\"), nextRoundNumber, winnersBracketTeams[0], losersBracketWinner, false, \"championship\"));\n            } else {\n                // Instead, schedule the losers bracket final (LLWB vs LWLB), and show the winners bracket champion as waiting\n                nextRoundMatches.push(createMatch(\"LosersLast-\".concat(nextRoundNumber), nextRoundNumber, tournament.winnersBracketFinalLoser, losersBracketTeams[0], false, \"losers\"));\n                nextRoundMatches.push(createMatch(\"WinnersBracketChampion-waiting-\".concat(nextRoundNumber), nextRoundNumber, winnersBracketTeams[0], null, true, \"winners\"));\n            }\n        }\n    } else if (winnersBracketTeams.length === 1 && tournament.winnersBracketFinalLoser) {\n        if (losersBracketTeams.length === 1) {\n            var _tournament_rounds_;\n            // Prevent duplicate losers bracket final: check if previous round already had this match\n            const previousRoundMatches = ((_tournament_rounds_ = tournament.rounds[nextRoundNumber - 2]) === null || _tournament_rounds_ === void 0 ? void 0 : _tournament_rounds_.matches) || [];\n            const prevHadSameMatch = previousRoundMatches.some((m)=>{\n                var _m_team1, _m_team2;\n                const ids = [\n                    (_m_team1 = m.team1) === null || _m_team1 === void 0 ? void 0 : _m_team1.id,\n                    (_m_team2 = m.team2) === null || _m_team2 === void 0 ? void 0 : _m_team2.id\n                ].filter(Boolean).sort();\n                const currIds = [\n                    tournament.winnersBracketFinalLoser.id,\n                    losersBracketTeams[0].id\n                ].sort();\n                return ids.length === 2 && ids[0] === currIds[0] && ids[1] === currIds[1];\n            });\n            if (!prevHadSameMatch) {\n                // Only now schedule WBFL vs LBL\n                nextRoundMatches.push(createMatch(\"LosersLast-\".concat(nextRoundNumber), nextRoundNumber, tournament.winnersBracketFinalLoser, losersBracketTeams[0], false, \"losers\"));\n            }\n        // If match already played, do not schedule again; championship logic will handle next step\n        } else if (losersBracketTeams.length === 2) {\n            // Schedule the match between the last two losers bracket teams\n            nextRoundMatches.push(createMatch(\"L\".concat(nextRoundNumber, \"-1\"), nextRoundNumber, losersBracketTeams[0], losersBracketTeams[1], false, \"losers\"));\n            // WBFL is waiting for the winner\n            nextRoundMatches.push(createMatch(\"WinnersFinalLoser-waiting-\".concat(nextRoundNumber), nextRoundNumber, tournament.winnersBracketFinalLoser, null, true, \"losers\"));\n        } else if (losersBracketTeams.length > 2) {\n            // More than 2 teams: pair off as usual, WBFL waits\n            for(let i = 0; i < losersBracketTeams.length; i += 2){\n                const team1 = losersBracketTeams[i];\n                var _losersBracketTeams_;\n                const team2 = (_losersBracketTeams_ = losersBracketTeams[i + 1]) !== null && _losersBracketTeams_ !== void 0 ? _losersBracketTeams_ : null;\n                nextRoundMatches.push(createMatch(\"L\".concat(nextRoundNumber, \"-\").concat(Math.floor(i / 2) + 1), nextRoundNumber, team1, team2, !team2, \"losers\"));\n            }\n            nextRoundMatches.push(createMatch(\"WinnersFinalLoser-waiting-\".concat(nextRoundNumber), nextRoundNumber, tournament.winnersBracketFinalLoser, null, true, \"losers\"));\n        } else {\n            // WBFL is waiting for the losers bracket to resolve\n            nextRoundMatches.push(createMatch(\"WinnersFinalLoser-waiting-\".concat(nextRoundNumber), nextRoundNumber, tournament.winnersBracketFinalLoser, null, true, \"losers\"));\n        }\n        // Always show a waiting card for the winners bracket champion if not in championship\n        nextRoundMatches.push(createMatch(\"WinnersBracketChampion-waiting-\".concat(nextRoundNumber), nextRoundNumber, winnersBracketTeams[0], null, true, \"winners\"));\n    } else if (winnersBracketTeams.length === 2) {\n        // Create the winner's bracket final match\n        nextRoundMatches.push(createMatch(\"W\".concat(nextRoundNumber, \"-1\"), nextRoundNumber, winnersBracketTeams[0], winnersBracketTeams[1], false, \"winners\"));\n        // Continue with losers bracket matches separately\n        createLosersBracketMatches();\n    } else {\n        createStandardBracketMatches();\n    }\n    // Helper function to create standard bracket matches\n    function createStandardBracketMatches() {\n        // --- Winners Bracket Matches ---\n        let matchCounter = 1;\n        for(let i = 0; i < winnersBracketTeams.length; i += 2){\n            const team1 = winnersBracketTeams[i];\n            var _winnersBracketTeams_;\n            const team2 = (_winnersBracketTeams_ = winnersBracketTeams[i + 1]) !== null && _winnersBracketTeams_ !== void 0 ? _winnersBracketTeams_ : null;\n            const isBye = !team2;\n            nextRoundMatches.push(createMatch(\"W\".concat(nextRoundNumber, \"-\").concat(matchCounter), nextRoundNumber, team1, team2, isBye, \"winners\"));\n            matchCounter++;\n        }\n        // Create losers bracket matches separately\n        createLosersBracketMatches();\n    }\n    // Helper function to create losers bracket matches\n    function createLosersBracketMatches() {\n        // --- Losers Bracket Matches ---\n        const eligibleLosers = allTeams.filter((team)=>(lossCounts[team.id] || 0) === 1 && !tournament.eliminatedTeams.some((t)=>t.id === team.id) && !newlyEliminated.some((t)=>t.id === team.id) && // Exclude winner's bracket final loser if it exists\n            !(tournament.winnersBracketFinalLoser && tournament.winnersBracketFinalLoser.id === team.id));\n        // Find teams recently dropped from winners bracket\n        const justDroppedFromWinners = currentRound.matches.filter((m)=>m.bracket === \"winners\" && m.loser && m.isCompleted).map((m)=>m.loser).filter((loser)=>eligibleLosers.some((t)=>t.id === loser.id));\n        // If this is the winner's bracket final, store the loser for later use\n        if (currentRound.matches.some((m)=>m.bracket === \"winners\" && winnersBracketTeams.length === 1 && m.loser && m.isCompleted)) {\n            // This is a special case - we found the winner's bracket final loser\n            const winnersFinalLoser = currentRound.matches.filter((m)=>m.bracket === \"winners\" && m.isCompleted && m.loser).map((m)=>m.loser).pop();\n            if (winnersFinalLoser && !tournament.eliminatedTeams.some((t)=>t.id === winnersFinalLoser.id)) {\n                tournament.winnersBracketFinalLoser = winnersFinalLoser;\n            }\n        }\n        // Existing losers bracket teams\n        const existingLosers = eligibleLosers.filter((t)=>!justDroppedFromWinners.some((jd)=>jd.id === t.id));\n        // Order: most recent drop(s) first\n        const orderedLosers = [\n            ...justDroppedFromWinners,\n            ...existingLosers\n        ];\n        if (orderedLosers.length > 0) {\n            if (orderedLosers.length % 2 === 1) {\n                // Odd: bye goes to the most recent team dropped from winners bracket\n                let teamWithBye = null;\n                if (justDroppedFromWinners.length > 0) {\n                    teamWithBye = justDroppedFromWinners[justDroppedFromWinners.length - 1];\n                    // Remove the bye team from orderedLosers\n                    const byeIndex = orderedLosers.findIndex((t)=>t.id === teamWithBye.id);\n                    if (byeIndex !== -1) orderedLosers.splice(byeIndex, 1);\n                } else {\n                    // Defensive: fallback to first team if no recent drop\n                    teamWithBye = orderedLosers.shift();\n                }\n                nextRoundMatches.push(createMatch(\"L\".concat(nextRoundNumber, \"-1\"), nextRoundNumber, teamWithBye, null, true, \"losers\"));\n                // Pair the rest\n                for(let i = 0; i < orderedLosers.length; i += 2){\n                    const team1 = orderedLosers[i];\n                    var _orderedLosers_;\n                    const team2 = (_orderedLosers_ = orderedLosers[i + 1]) !== null && _orderedLosers_ !== void 0 ? _orderedLosers_ : null;\n                    nextRoundMatches.push(createMatch(\"L\".concat(nextRoundNumber, \"-\").concat(Math.floor(i / 2) + 2), nextRoundNumber, team1, team2, !team2, \"losers\"));\n                }\n            } else {\n                // Even number: pair all\n                for(let i = 0; i < orderedLosers.length; i += 2){\n                    const team1 = orderedLosers[i];\n                    var _orderedLosers_1;\n                    const team2 = (_orderedLosers_1 = orderedLosers[i + 1]) !== null && _orderedLosers_1 !== void 0 ? _orderedLosers_1 : null;\n                    nextRoundMatches.push(createMatch(\"L\".concat(nextRoundNumber, \"-\").concat(Math.floor(i / 2) + 1), nextRoundNumber, team1, team2, !team2, \"losers\"));\n                }\n            }\n        }\n    }\n    // --- Winner detection logic ---\n    let winner = tournament.winner;\n    if (isChampionshipRound) {\n        // Find the last championship match played\n        const lastChampMatch = championshipMatches[0] || prevChampionshipMatches[prevChampionshipMatches.length - 1];\n        if (lastChampMatch && lastChampMatch.isCompleted && lastChampMatch.winner && lastChampMatch.loser) {\n            const winnersBracketTeam = lastChampMatch.team1;\n            const losersBracketTeam = lastChampMatch.team2;\n            const losersBracketTeamWon = losersBracketTeam && lastChampMatch.winner.id === losersBracketTeam.id;\n            // If loser's bracket team won first championship match, winner's bracket team gets another chance\n            if (losersBracketTeamWon && tournament.championshipMatchesPlayed === 1) {\n                winner = undefined; // No winner yet, need reset match\n            } else {\n                // Either winner's bracket team won first match, or this was the reset match\n                winner = lastChampMatch.winner;\n            }\n        }\n    }\n    // --- INFINITE RECURSION GUARD ---\n    const noMoreMatches = isChampionshipRound && championshipMatches.length === 0 || !isChampionshipRound && nextRoundMatches.length === 0;\n    if (noMoreMatches) {\n        // Tournament is over, do not advance further\n        return {\n            ...tournament,\n            winner,\n            currentRound: tournament.currentRound\n        };\n    }\n    // Debug log before returning the new tournament object\n    (0,_logTournamentState__WEBPACK_IMPORTED_MODULE_0__.logTournamentState)({\n        roundNumber: nextRoundNumber,\n        winnersBracketTeams,\n        losersBracketTeams,\n        matches: isChampionshipRound ? championshipMatches : nextRoundMatches,\n        winnersBracketFinalLoser: tournament.winnersBracketFinalLoser\n    });\n    // Compose the new tournament object\n    return {\n        ...tournament,\n        rounds: [\n            ...tournament.rounds,\n            {\n                roundNumber: nextRoundNumber,\n                matches: isChampionshipRound ? championshipMatches : nextRoundMatches,\n                isDoubleElimination: true,\n                isChampionshipRound\n            }\n        ],\n        currentRound: nextRoundNumber,\n        eliminatedTeams: [\n            ...tournament.eliminatedTeams,\n            ...newlyEliminated.filter((t)=>!tournament.eliminatedTeams.some((et)=>et.id === t.id))\n        ],\n        championshipMatchesPlayed: isChampionshipRound ? tournament.championshipMatchesPlayed + 1 : tournament.championshipMatchesPlayed,\n        winnersBracketFinalLoser: tournament.winnersBracketFinalLoser,\n        winner\n    };\n}; // export const advanceToNextRound = (tournament: Tournament): Tournament => {\n //   const currentRound = tournament.rounds[tournament.rounds.length - 1];\n //   const nextRoundNumber = tournament.currentRound + 1;\n //   // Track all losses across the tournament\n //   const lossCounts: Record<string, number> = {};\n //   tournament.rounds.forEach((round) => {\n //     round.matches.forEach((match) => {\n //       if (match.isCompleted && match.loser) {\n //         lossCounts[match.loser.id] = (lossCounts[match.loser.id] || 0) + 1;\n //       }\n //     });\n //   });\n //   // Gather all teams ever in the tournament\n //   const allTeams: Team[] = [];\n //   const teamIds = new Set<string>();\n //   for (const round of tournament.rounds) {\n //     for (const match of round.matches) {\n //       if (match.team1 && !teamIds.has(match.team1.id)) {\n //         allTeams.push(match.team1);\n //         teamIds.add(match.team1.id);\n //       }\n //       if (match.team2 && !teamIds.has(match.team2.id)) {\n //         allTeams.push(match.team2);\n //         teamIds.add(match.team2.id);\n //       }\n //     }\n //   }\n //   // Identify newly eliminated teams (2 losses)\n //   const newlyEliminated: Team[] = [];\n //   for (const team of allTeams) {\n //     if (\n //       (lossCounts[team.id] || 0) >= 2 &&\n //       !tournament.eliminatedTeams.some((t) => t.id === team.id)\n //     ) {\n //       newlyEliminated.push(team);\n //     }\n //   }\n //   // Winners: teams with 0 losses and not eliminated\n //   const winnersBracketTeams = allTeams.filter(\n //     (team) =>\n //       (lossCounts[team.id] || 0) === 0 &&\n //       !tournament.eliminatedTeams.some((t) => t.id === team.id) &&\n //       !newlyEliminated.some((t) => t.id === team.id)\n //   );\n //   // Losers: teams with 1 loss and not eliminated\n //   const losersBracketTeams = allTeams.filter(\n //     (team) =>\n //       (lossCounts[team.id] || 0) === 1 &&\n //       !tournament.eliminatedTeams.some((t) => t.id === team.id) &&\n //       !newlyEliminated.some((t) => t.id === team.id)\n //   );\n //   let isChampionshipRound = false;\n //   let championshipMatches: Match[] = [];\n //   let nextRoundMatches: Match[] = [];\n //   const prevChampionshipMatches = tournament.rounds\n //     .filter((r) => r.isChampionshipRound)\n //     .flatMap((r) => r.matches)\n //     .filter((m) => m.bracket === \"championship\");\n //   // --- CHAMPIONSHIP LOGIC ---\n //   // Check if a championship match already happened and was completed\n //   if (\n //     prevChampionshipMatches.length >= 1 &&\n //     prevChampionshipMatches[prevChampionshipMatches.length - 1].isCompleted\n //   ) {\n //     const lastChampMatch =\n //       prevChampionshipMatches[prevChampionshipMatches.length - 1];\n //     const winnersBracketTeam = lastChampMatch.team1;\n //     const losersBracketTeam = lastChampMatch.team2;\n //     // If loser's bracket team won the first championship match, winner's bracket team gets another chance\n //     if (\n //       lastChampMatch.winner?.id === losersBracketTeam?.id &&\n //       tournament.championshipMatchesPlayed === 1\n //     ) {\n //       isChampionshipRound = true;\n //       // Create the \"reset\" match\n //       championshipMatches.push(\n //         createMatch(\n //           `C${nextRoundNumber}-1`,\n //           nextRoundNumber,\n //           winnersBracketTeam,\n //           losersBracketTeam,\n //           false,\n //           \"championship\"\n //         )\n //       );\n //     } else {\n //       // Either winner's bracket team won first match, or this was the reset match\n //       isChampionshipRound = true;\n //       // No new matches, winner will be determined in winner detection logic\n //     }\n //   }\n //   // Check if we're ready for the championship match - one team in each bracket and loser's final is complete\n //   else if (\n //     winnersBracketTeams.length === 1 &&\n //     losersBracketTeams.length === 1 &&\n //     currentRound.matches.some(\n //       (m) =>\n //         (m.bracket === \"losers\" || m.id.includes(\"LosersLast\")) &&\n //         m.isCompleted &&\n //         m.winner &&\n //         losersBracketTeams.some((t) => t.id === m.winner!.id)\n //     )\n //   ) {\n //     // Championship match: Winner's bracket champion vs Loser's bracket champion\n //     isChampionshipRound = true;\n //     championshipMatches.push(\n //       createMatch(\n //         `C${nextRoundNumber}-1`,\n //         nextRoundNumber,\n //         winnersBracketTeams[0], // Winner's bracket champion\n //         losersBracketTeams[0], // Loser's bracket champion\n //         false,\n //         \"championship\"\n //       )\n //     );\n //   }\n //   // Check if we have a loser from winner's bracket final waiting to play against loser's bracket winner\n //   else if (\n //     winnersBracketTeams.length === 1 && // We have a winner's bracket champion\n //     losersBracketTeams.length >= 1 && // We have at least one team in loser's bracket\n //     tournament.winnersBracketFinalLoser // We have stored the winner's bracket final loser\n //   ) {\n //     // Find the winner of the loser's bracket\n //     const losersBracketWinner = currentRound.matches\n //       .filter((m) => m.bracket === \"losers\" && m.isCompleted && m.winner)\n //       .map((m) => m.winner!)\n //       .find((winner) => losersBracketTeams.some((t) => t.id === winner.id));\n //     if (\n //       losersBracketWinner &&\n //       losersBracketWinner.id !== tournament.winnersBracketFinalLoser.id\n //     ) {\n //       // Only schedule if they're not the same team!\n //       nextRoundMatches.push(\n //         createMatch(\n //           `LosersLast-${nextRoundNumber}`,\n //           nextRoundNumber,\n //           tournament.winnersBracketFinalLoser,\n //           losersBracketWinner,\n //           false,\n //           \"losers\"\n //         )\n //       );\n //     } else {\n //       // Wait for the losers bracket to resolve properly\n //       createStandardBracketMatches();\n //     }\n //   }\n //   // Check if this is the winner's bracket final (exactly 2 teams in winner's bracket)\n //   else if (winnersBracketTeams.length === 2 && losersBracketTeams.length >= 1) {\n //     // Create the winner's bracket final match\n //     nextRoundMatches.push(\n //       createMatch(\n //         `W${nextRoundNumber}-1`,\n //         nextRoundNumber,\n //         winnersBracketTeams[0],\n //         winnersBracketTeams[1],\n //         false,\n //         \"winners\"\n //       )\n //     );\n //     // Continue with losers bracket matches separately\n //     createLosersBracketMatches();\n //   }\n //   // Otherwise, continue with normal bracket play\n //   else {\n //     createStandardBracketMatches();\n //   }\n //   // Helper function to create standard bracket matches\n //   function createStandardBracketMatches() {\n //     // --- Winners Bracket Matches ---\n //     let matchCounter = 1;\n //     for (let i = 0; i < winnersBracketTeams.length; i += 2) {\n //       const team1 = winnersBracketTeams[i];\n //       const team2 = winnersBracketTeams[i + 1] ?? null;\n //       const isBye = !team2;\n //       nextRoundMatches.push(\n //         createMatch(\n //           `W${nextRoundNumber}-${matchCounter}`,\n //           nextRoundNumber,\n //           team1,\n //           team2,\n //           isBye,\n //           \"winners\"\n //         )\n //       );\n //       matchCounter++;\n //     }\n //     // Create losers bracket matches separately\n //     createLosersBracketMatches();\n //   }\n //   // Helper function to create losers bracket matches\n //   function createLosersBracketMatches() {\n //     // --- Losers Bracket Matches ---\n //     const eligibleLosers = allTeams.filter(\n //       (team) =>\n //         (lossCounts[team.id] || 0) === 1 &&\n //         !tournament.eliminatedTeams.some((t) => t.id === team.id) &&\n //         !newlyEliminated.some((t) => t.id === team.id) &&\n //         // Exclude winner's bracket final loser if it exists but hasn't played yet in losers\n //         !(\n //           tournament.winnersBracketFinalLoser &&\n //           tournament.winnersBracketFinalLoser.id === team.id\n //         )\n //     );\n //     // Find teams recently dropped from winners bracket\n //     const justDroppedFromWinners = currentRound.matches\n //       .filter((m) => m.bracket === \"winners\" && m.loser && m.isCompleted)\n //       .map((m) => m.loser!)\n //       .filter((loser) => eligibleLosers.some((t) => t.id === loser.id));\n //     // If this is the winner's bracket final, store the loser for later use\n //     if (\n //       currentRound.matches.some(\n //         (m) =>\n //           m.bracket === \"winners\" &&\n //           winnersBracketTeams.length === 1 &&\n //           m.loser &&\n //           m.isCompleted\n //       )\n //     ) {\n //       // This is a special case - we found the winner's bracket final loser\n //       const winnersFinalLoser = currentRound.matches\n //         .filter((m) => m.bracket === \"winners\" && m.isCompleted && m.loser)\n //         .map((m) => m.loser!)\n //         .pop();\n //       if (winnersFinalLoser) {\n //         tournament.winnersBracketFinalLoser = winnersFinalLoser;\n //       }\n //     }\n //     // Existing losers bracket teams\n //     const existingLosers = eligibleLosers.filter(\n //       (t) => !justDroppedFromWinners.some((jd) => jd.id === t.id)\n //     );\n //     // Order: most recent drop(s) first\n //     const orderedLosers = [...justDroppedFromWinners, ...existingLosers];\n //     if (orderedLosers.length > 0) {\n //       if (orderedLosers.length % 2 === 1) {\n //         // Odd: bye goes to the most recent team dropped from winners bracket\n //         let teamWithBye: Team | null = null;\n //         if (justDroppedFromWinners.length > 0) {\n //           teamWithBye =\n //             justDroppedFromWinners[justDroppedFromWinners.length - 1];\n //           // Remove the bye team from orderedLosers\n //           const byeIndex = orderedLosers.findIndex(\n //             (t) => t.id === teamWithBye!.id\n //           );\n //           if (byeIndex !== -1) orderedLosers.splice(byeIndex, 1);\n //         } else {\n //           // Defensive: fallback to first team if no recent drop\n //           teamWithBye = orderedLosers.shift()!;\n //         }\n //         nextRoundMatches.push(\n //           createMatch(\n //             `L${nextRoundNumber}-1`,\n //             nextRoundNumber,\n //             teamWithBye,\n //             null,\n //             true,\n //             \"losers\"\n //           )\n //         );\n //         // Pair the rest\n //         for (let i = 0; i < orderedLosers.length; i += 2) {\n //           const team1 = orderedLosers[i];\n //           const team2 = orderedLosers[i + 1] ?? null;\n //           nextRoundMatches.push(\n //             createMatch(\n //               `L${nextRoundNumber}-${Math.floor(i / 2) + 2}`,\n //               nextRoundNumber,\n //               team1,\n //               team2,\n //               !team2,\n //               \"losers\"\n //             )\n //           );\n //         }\n //       } else {\n //         // Even number: pair all\n //         for (let i = 0; i < orderedLosers.length; i += 2) {\n //           const team1 = orderedLosers[i];\n //           const team2 = orderedLosers[i + 1] ?? null;\n //           nextRoundMatches.push(\n //             createMatch(\n //               `L${nextRoundNumber}-${Math.floor(i / 2) + 1}`,\n //               nextRoundNumber,\n //               team1,\n //               team2,\n //               !team2,\n //               \"losers\"\n //             )\n //           );\n //         }\n //       }\n //     }\n //   }\n //   // --- Winner detection logic ---\n //   let winner: Team | undefined = tournament.winner;\n //   if (isChampionshipRound) {\n //     // Find the last championship match played\n //     const lastChampMatch =\n //       championshipMatches[0] ||\n //       prevChampionshipMatches[prevChampionshipMatches.length - 1];\n //     if (\n //       lastChampMatch &&\n //       lastChampMatch.isCompleted &&\n //       lastChampMatch.winner &&\n //       lastChampMatch.loser\n //     ) {\n //       const winnersBracketTeam = lastChampMatch.team1;\n //       const losersBracketTeam = lastChampMatch.team2;\n //       const losersBracketTeamWon =\n //         lastChampMatch.winner.id === losersBracketTeam.id;\n //       // If loser's bracket team won first championship match, winner's bracket team gets another chance\n //       if (losersBracketTeamWon && tournament.championshipMatchesPlayed === 1) {\n //         winner = undefined; // No winner yet, need reset match\n //       } else {\n //         // Either winner's bracket team won first match, or this was the reset match\n //         winner = lastChampMatch.winner;\n //       }\n //     }\n //   }\n //   // --- INFINITE RECURSION GUARD ---\n //   const noMoreMatches =\n //     (isChampionshipRound && championshipMatches.length === 0) ||\n //     (!isChampionshipRound && nextRoundMatches.length === 0);\n //   if (noMoreMatches) {\n //     // Tournament is over, do not advance further\n //     return {\n //       ...tournament,\n //       winner,\n //       currentRound: tournament.currentRound\n //     };\n //   }\n //   // Compose the new tournament object\n //   return {\n //     ...tournament,\n //     rounds: [\n //       ...tournament.rounds,\n //       {\n //         roundNumber: nextRoundNumber,\n //         matches: isChampionshipRound ? championshipMatches : nextRoundMatches,\n //         isDoubleElimination: true,\n //         isChampionshipRound\n //       }\n //     ],\n //     currentRound: nextRoundNumber,\n //     eliminatedTeams: [\n //       ...tournament.eliminatedTeams,\n //       ...newlyEliminated.filter(\n //         (t) => !tournament.eliminatedTeams.some((et) => et.id === t.id)\n //       )\n //     ],\n //     championshipMatchesPlayed: isChampionshipRound\n //       ? tournament.championshipMatchesPlayed + 1\n //       : tournament.championshipMatchesPlayed,\n //     winnersBracketFinalLoser: tournament.winnersBracketFinalLoser,\n //     winner\n //   };\n // };\n // import type { Team } from \"./mlb-teams\";\n // export interface Match {\n //   id: string;\n //   roundNumber: number;\n //   team1: Team | null;\n //   team2: Team | null;\n //   isCompleted: boolean;\n //   isBye?: boolean;\n //   winner?: Team;\n //   loser?: Team;\n //   bracket: \"winners\" | \"losers\" | \"championship\";\n //   score: { team1Score: number; team2Score: number };\n //   nextMatchId?: string;\n //   nextLoserMatchId?: string;\n //   eliminatedLabel?: string; // label for eliminated teams in losers bracket\n //   requiresRematch?: boolean; // indicates if a championship rematch is required\n // }\n // export interface Round {\n //   roundNumber: number;\n //   matches: Match[];\n //   isDoubleElimination: boolean;\n //   isChampionshipRound: boolean;\n // }\n // export interface Tournament {\n //   rounds: Round[];\n //   currentRound: number;\n //   eliminatedTeams: Team[];\n //   championshipMatchesPlayed: number;\n //   winner?: Team;\n //   winnersBracketFinalLoser?: Team; // tracks the winner's bracket final loser for championship rematch logic\n // }\n // export const createMatch = (\n //   id: string,\n //   roundNumber: number,\n //   team1: Team | null,\n //   team2: Team | null,\n //   isBye: boolean = false,\n //   bracket: \"winners\" | \"losers\" | \"championship\" = \"winners\",\n //   nextMatchId?: string,\n //   nextLoserMatchId?: string\n // ): Match => ({\n //   id,\n //   roundNumber,\n //   team1,\n //   team2,\n //   isCompleted: isBye,\n //   isBye,\n //   bracket,\n //   winner: isBye ? (team1 ?? team2 ?? undefined) : undefined,\n //   loser: isBye ? undefined : undefined,\n //   score: { team1Score: 0, team2Score: 0 },\n //   nextMatchId,\n //   nextLoserMatchId,\n //   eliminatedLabel: undefined\n // });\n // export const createInitialRounds = (teams: Team[]): Tournament => {\n //   const numTeams = teams.length;\n //   const matches: Match[] = [];\n //   const numRounds = Math.ceil(Math.log2(numTeams));\n //   const firstRoundMatches = Math.pow(2, numRounds - 1);\n //   let matchCounter = 1;\n //   for (let i = 0; i < firstRoundMatches; i++) {\n //     const team1 = teams[i * 2] || null;\n //     const team2 = teams[i * 2 + 1] || null;\n //     const isBye = !team1 || !team2;\n //     const matchId = `W1-${matchCounter}`;\n //     const nextMatchId = `W2-${Math.ceil(matchCounter / 2)}`;\n //     const nextLoserMatchId = `L1-${Math.ceil(matchCounter / 2)}`;\n //     matches.push(\n //       createMatch(\n //         matchId,\n //         1,\n //         team1,\n //         team2,\n //         isBye,\n //         \"winners\",\n //         nextMatchId,\n //         nextLoserMatchId\n //       )\n //     );\n //     matchCounter++;\n //   }\n //   return {\n //     rounds: [\n //       {\n //         roundNumber: 1,\n //         matches,\n //         isDoubleElimination: true,\n //         isChampionshipRound: false\n //       }\n //     ],\n //     currentRound: 1,\n //     eliminatedTeams: [],\n //     championshipMatchesPlayed: 0\n //   };\n // };\n // export const updateMatchScore = (\n //   match: Match,\n //   newScore: { team1Score: number; team2Score: number }\n // ): Match => {\n //   // Mark match as completed if both teams have a score entered (even if scores are equal)\n //   const isCompleted =\n //     typeof newScore.team1Score === \"number\" &&\n //     typeof newScore.team2Score === \"number\" &&\n //     (!isNaN(newScore.team1Score) && !isNaN(newScore.team2Score));\n //   let winner: Team | undefined = undefined;\n //   let loser: Team | undefined = undefined;\n //   if (isCompleted) {\n //     if (newScore.team1Score > newScore.team2Score) {\n //       winner = match.team1 ? { ...match.team1, wins: (match.team1.wins ?? 0) + 1, losses: match.team1.losses ?? 0 } : undefined;\n //       loser = match.team2 ? { ...match.team2, wins: match.team2.wins ?? 0, losses: (match.team2.losses ?? 0) + 1 } : undefined;\n //     } else {\n //       winner = match.team2 ? { ...match.team2, wins: (match.team2.wins ?? 0) + 1, losses: match.team2.losses ?? 0 } : undefined;\n //       loser = match.team1 ? { ...match.team1, wins: match.team1.wins ?? 0, losses: (match.team1.losses ?? 0) + 1 } : undefined;\n //     }\n //   }\n //   return {\n //     ...match,\n //     score: newScore,\n //     isCompleted,\n //     winner,\n //     loser\n //   };\n // };\n // // Helper to deduplicate teams by ID\n // function dedupeTeams(teams: Team[]): Team[] {\n //   const seen = new Set<string>();\n //   return teams.filter(team => {\n //     if (!team) return false;\n //     if (seen.has(team.id)) return false;\n //     seen.add(team.id);\n //     return true;\n //   });\n // }\n // // Helper: get all teams with exactly N losses\n // function teamsWithLosses(lossCounts: Record<string, number>, n: number): string[] {\n //   return Object.keys(lossCounts).filter(teamId => lossCounts[teamId] === n);\n // }\n // export const advanceToNextRound = (tournament: Tournament): Tournament => {\n //   const currentRound = tournament.rounds[tournament.rounds.length - 1];\n //   const nextRoundNumber = tournament.currentRound + 1;\n //   // Track all losses and wins across the tournament\n //   const lossCounts: Record<string, number> = {};\n //   const winsCounts: Record<string, number> = {};\n //   tournament.rounds.forEach((round) => {\n //     round.matches.forEach((match) => {\n //       if (match.isCompleted && match.loser) {\n //         lossCounts[match.loser.id] = (lossCounts[match.loser.id] || 0) + 1;\n //       }\n //       if (match.isCompleted && match.winner) {\n //         winsCounts[match.winner.id] = (winsCounts[match.winner.id] || 0) + 1;\n //       }\n //     });\n //   });\n //   // Gather all teams ever in the tournament, attaching wins\n //   const allTeams: Team[] = [];\n //   const teamIds = new Set<string>();\n //   for (const round of tournament.rounds) {\n //     for (const match of round.matches) {\n //       if (match.team1 && !teamIds.has(match.team1.id)) {\n //         allTeams.push({\n //           ...match.team1,\n //           wins: winsCounts[match.team1.id] || 0,\n //           losses: lossCounts[match.team1.id] || 0\n //         });\n //         teamIds.add(match.team1.id);\n //       }\n //       if (match.team2 && !teamIds.has(match.team2.id)) {\n //         allTeams.push({\n //           ...match.team2,\n //           wins: winsCounts[match.team2.id] || 0,\n //           losses: lossCounts[match.team2.id] || 0\n //         });\n //         teamIds.add(match.team2.id);\n //       }\n //     }\n //   }\n //   // Identify newly eliminated teams (2 losses)\n //   const newlyEliminated: Team[] = [];\n //   for (const team of allTeams) {\n //     if (\n //       (lossCounts[team.id] || 0) >= 2 &&\n //       !tournament.eliminatedTeams.some((t) => t.id === team.id)\n //     ) {\n //       newlyEliminated.push(team);\n //     }\n //   }\n //   // Winners: teams with 0 losses and not eliminated\n //   const winnersBracketTeams = allTeams\n //     .filter(\n //       (team) =>\n //         (lossCounts[team.id] || 0) === 0 &&\n //         !tournament.eliminatedTeams.some((t) => t.id === team.id) &&\n //         !newlyEliminated.some((t) => t.id === team.id) &&\n //         !team.id.startsWith('tbd-') // Exclude any phantom TBD teams\n //     )\n //     .map((team) => ({ ...team, losses: lossCounts[team.id] || 0, wins: winsCounts[team.id] || 0 }));\n //   // Losers: teams with 1 loss and not eliminated\n //   const losersBracketTeams = allTeams\n //     .filter(\n //       (team) =>\n //         (lossCounts[team.id] || 0) === 1 &&\n //         !tournament.eliminatedTeams.some((t) => t.id === team.id) &&\n //         !newlyEliminated.some((t) => t.id === team.id)\n //     )\n //     .map((team) => ({\n //       ...team,\n //       losses: lossCounts[team.id] || 0,\n //       wins: winsCounts[team.id] || 0\n //     }));\n //   let isChampionshipRound = false;\n //   let championshipMatches: Match[] = [];\n //   let nextRoundMatches: Match[] = [];\n //   const prevChampionshipMatches = tournament.rounds\n //     .filter((r) => r.isChampionshipRound)\n //     .flatMap((r) => r.matches)\n //     .filter((m) => m.bracket === \"championship\");\n //   // --- CHAMPIONSHIP LOGIC ---\n //   // Check if a championship match already happened and was completed\n //   if (\n //     prevChampionshipMatches.length >= 1 &&\n //     prevChampionshipMatches[prevChampionshipMatches.length - 1].isCompleted\n //   ) {\n //     const lastChampMatch =\n //       prevChampionshipMatches[prevChampionshipMatches.length - 1];\n //     const winnersBracketTeam = lastChampMatch.team1;\n //     const losersBracketTeam = lastChampMatch.team2;\n //     // If loser's bracket team won the first championship match, winner's bracket team gets another chance\n //     if (\n //       lastChampMatch.winner?.id === losersBracketTeam?.id &&\n //       tournament.championshipMatchesPlayed === 1\n //     ) {\n //       isChampionshipRound = true;\n //       // Create the \"reset\" match with requiresRematch: true\n //       championshipMatches.push({\n //         ...createMatch(\n //           `C${nextRoundNumber}-1`,\n //           nextRoundNumber,\n //           winnersBracketTeam,\n //           losersBracketTeam,\n //           false,\n //           \"championship\"\n //         ),\n //         requiresRematch: true\n //       });\n //       // Increment the winner's bracket team's loss count for the record\n //       if (winnersBracketTeam && typeof winnersBracketTeam.losses === \"number\") {\n //         winnersBracketTeam.losses += 1;\n //       }\n //     } else {\n //       // Either winner's bracket team won first match, or this was the reset match\n //       isChampionshipRound = true;\n //       // No new matches, winner will be determined in winner detection logic\n //     }\n //   }\n //   // Check if we're ready for the championship match - one team in each bracket and loser's final is complete\n //   else if (\n //     winnersBracketTeams.length === 1 &&\n //     // If ANY losers bracket match in the current round is incomplete, show waiting cards\n //     currentRound.matches.some(\n //       (m) =>\n //         (m.bracket === \"losers\" || m.id.includes(\"LosersLast\")) &&\n //         !m.isCompleted\n //     )\n //   ) {\n //     // Not ready for championship: show waiting cards for both\n //     nextRoundMatches.push(\n //       createMatch(\n //         `W${nextRoundNumber}-waiting`,\n //         nextRoundNumber,\n //         winnersBracketTeams[0],\n //         {\n //           id: `tbd-${nextRoundNumber}-waiting`,\n //           name: \"TBD\",\n //           city: \"\",\n //           losses: 0\n //         },\n //         true,\n //         \"winners\"\n //       )\n //     );\n //     if (tournament.winnersBracketFinalLoser) {\n //       nextRoundMatches.push(\n //         createMatch(\n //           `LosersLast-${nextRoundNumber}`,\n //           nextRoundNumber,\n //           tournament.winnersBracketFinalLoser,\n //           {\n //             id: `tbd-losers-${nextRoundNumber}`,\n //             name: \"TBD\",\n //             city: \"\",\n //             losses: 0\n //           },\n //           true,\n //           \"losers\"\n //         )\n //       );\n //     }\n //     logTournamentState({\n //       roundNumber: nextRoundNumber,\n //       winnersBracketTeams,\n //       losersBracketTeams,\n //       matches: nextRoundMatches,\n //       winnersBracketFinalLoser: tournament.winnersBracketFinalLoser\n //     });\n //     createLosersBracketMatches();\n //   }\n //   // Check if we have a loser from winner's bracket final waiting to play against loser's bracket winner\n //   else if (\n //     winnersBracketTeams.length === 1 &&\n //     tournament.winnersBracketFinalLoser\n //   ) {\n //     // Always show the waiting card for the losers bracket final loser, even if the opponent is TBD\n //     let losersBracketWinner = null;\n //     if (losersBracketTeams.length >= 1) {\n //       losersBracketWinner = currentRound.matches\n //         .filter((m) => m.bracket === \"losers\" && m.isCompleted && m.winner)\n //         .map((m) => m.winner!)\n //         .find((winner) => losersBracketTeams.some((t) => t.id === winner.id));\n //     }\n //     const opponent =\n //       losersBracketWinner &&\n //       losersBracketWinner.id !== tournament.winnersBracketFinalLoser.id\n //         ? losersBracketWinner\n //         : {\n //             id: `tbd-losers-${nextRoundNumber}`,\n //             name: \"TBD\",\n //             city: \"\",\n //             losses: 0\n //           };\n //     const isBye =\n //       !losersBracketWinner ||\n //       losersBracketWinner.id === tournament.winnersBracketFinalLoser.id;\n //     nextRoundMatches.push(\n //       createMatch(\n //         `LosersLast-${nextRoundNumber}`,\n //         nextRoundNumber,\n //         tournament.winnersBracketFinalLoser,\n //         opponent,\n //         isBye,\n //         \"losers\"\n //       )\n //     );\n //     // Always render the winners bracket champion as a non-scoreable waiting card if the losers bracket is not resolved\n //     nextRoundMatches.push(\n //       createMatch(\n //         `W${nextRoundNumber}-waiting`,\n //         nextRoundNumber,\n //         winnersBracketTeams[0],\n //         {\n //           id: `tbd-${nextRoundNumber}-waiting`,\n //           name: \"TBD\",\n //           city: \"\",\n //           losses: 0\n //         },\n //         true, // isBye: true to ensure it's not scoreable\n //         \"winners\"\n //       )\n //     );\n //     createLosersBracketMatches();\n //   }\n //   // Otherwise, continue with normal bracket play\n //   else {\n //     // If only one team in winners and losers bracket is not resolved, always show waiting cards\n //     if (winnersBracketTeams.length === 1 && losersBracketTeams.length >= 1) {\n //       nextRoundMatches.push(\n //         createMatch(\n //           `W${nextRoundNumber}-waiting`,\n //           nextRoundNumber,\n //           winnersBracketTeams[0],\n //           {\n //             id: `tbd-${nextRoundNumber}-waiting`,\n //             name: \"TBD\",\n //             city: \"\",\n //             losses: 0\n //           },\n //           true,\n //           \"winners\"\n //         )\n //       );\n //       if (tournament.winnersBracketFinalLoser) {\n //         nextRoundMatches.push(\n //           createMatch(\n //             `LosersLast-${nextRoundNumber}`,\n //             nextRoundNumber,\n //             tournament.winnersBracketFinalLoser,\n //             {\n //               id: `tbd-losers-${nextRoundNumber}`,\n //               name: \"TBD\",\n //               city: \"\",\n //               losses: 0\n //             },\n //             true,\n //             \"losers\"\n //           )\n //         );\n //       }\n //     }\n //   }\n //   // Helper function to create standard bracket matches\n //   function createStandardBracketMatches() {\n //     // --- Winners Bracket Matches ---\n //     let matchCounter = 1;\n //     for (let i = 0; i < winnersBracketTeams.length; i += 2) {\n //       const team1 = winnersBracketTeams[i];\n //       const team2 = winnersBracketTeams[i + 1] ?? null;\n //       const isBye = !team2;\n //       nextRoundMatches.push(\n //         createMatch(\n //           `W${nextRoundNumber}-${matchCounter}`,\n //           nextRoundNumber,\n //           team1,\n //           team2,\n //           isBye,\n //           \"winners\"\n //         )\n //       );\n //       matchCounter++;\n //     }\n //     // Create losers bracket matches separately\n //     createLosersBracketMatches();\n //   }\n //   // Helper function to create losers bracket matches\n //   function createLosersBracketMatches() {\n //     // --- Losers Bracket Matches ---\n //     const eligibleLosers = allTeams.filter(\n //       (team) =>\n //         (lossCounts[team.id] || 0) === 1 &&\n //         !tournament.eliminatedTeams.some((t) => t.id === team.id) &&\n //         !newlyEliminated.some((t) => t.id === team.id) &&\n //         // Exclude winner's bracket final loser if it exists but hasn't played yet in losers\n //         !(\n //           tournament.winnersBracketFinalLoser &&\n //           tournament.winnersBracketFinalLoser.id === team.id\n //         )\n //     );\n //     // Find teams recently dropped from winners bracket\n //     const justDroppedFromWinners = currentRound.matches\n //       .filter((m) => m.bracket === \"winners\" && m.loser && m.isCompleted)\n //       .map((m) => m.loser!)\n //       .filter((loser) => eligibleLosers.some((t) => t.id === loser.id));\n //     // If this is the winner's bracket final, store the loser for later use\n //     if (\n //       currentRound.matches.some(\n //         (m) =>\n //           m.bracket === \"winners\" &&\n //           winnersBracketTeams.length === 1 &&\n //           m.loser &&\n //           m.isCompleted\n //       )\n //     ) {\n //       // This is a special case - we found the winner's bracket final loser\n //       const winnersFinalLoser = currentRound.matches\n //         .filter((m) => m.bracket === \"winners\" && m.isCompleted && m.loser)\n //         .map((m) => m.loser!)\n //         .pop();\n //       if (winnersFinalLoser) {\n //         tournament.winnersBracketFinalLoser = winnersFinalLoser;\n //       }\n //     }\n //     // Existing losers bracket teams\n //     const existingLosers = eligibleLosers.filter(\n //       (t) => !justDroppedFromWinners.some((jd) => jd.id === t.id)\n //     );\n //     // Order: most recent drop(s) first\n //     const orderedLosers = [...justDroppedFromWinners, ...existingLosers];\n //     if (orderedLosers.length > 0) {\n //       if (orderedLosers.length % 2 === 1) {\n //         // Odd: bye goes to the most recent team dropped from winners bracket\n //         let teamWithBye: Team | null = null;\n //         if (justDroppedFromWinners.length > 0) {\n //           teamWithBye =\n //             justDroppedFromWinners[justDroppedFromWinners.length - 1];\n //           // Remove the bye team from orderedLosers\n //           const byeIndex = orderedLosers.findIndex(\n //             (t) => t.id === teamWithBye!.id\n //           );\n //           if (byeIndex !== -1) orderedLosers.splice(byeIndex, 1);\n //         } else {\n //           // Defensive: fallback to first team if no recent drop\n //           teamWithBye = orderedLosers.shift()!;\n //         }\n //         nextRoundMatches.push(\n //           createMatch(\n //             `L${nextRoundNumber}-1`,\n //             nextRoundNumber,\n //             teamWithBye,\n //             null,\n //             true,\n //             \"losers\"\n //           )\n //         );\n //         // Pair the rest\n //         for (let i = 0; i < orderedLosers.length; i += 2) {\n //           const team1 = orderedLosers[i];\n //           const team2 = orderedLosers[i + 1] ?? null;\n //           nextRoundMatches.push(\n //             createMatch(\n //               `L${nextRoundNumber}-${Math.floor(i / 2) + 2}`,\n //               nextRoundNumber,\n //               team1,\n //               team2,\n //               !team2,\n //               \"losers\"\n //             )\n //           );\n //         }\n //       } else {\n //         // Even number: pair all\n //         for (let i = 0; i < orderedLosers.length; i += 2) {\n //           const team1 = orderedLosers[i];\n //           const team2 = orderedLosers[i + 1] ?? null;\n //           nextRoundMatches.push(\n //             createMatch(\n //               `L${nextRoundNumber}-${Math.floor(i / 2) + 1}`,\n //               nextRoundNumber,\n //               team1,\n //               team2,\n //               !team2,\n //               \"losers\"\n //             )\n //           );\n //         }\n //       }\n //     }\n //   }\n //   // --- Winner detection logic ---\n //   let winner: Team | undefined = tournament.winner;\n //   if (isChampionshipRound) {\n //     // Find the last championship match played\n //     const lastChampMatch =\n //       championshipMatches[0] ||\n //       prevChampionshipMatches[prevChampionshipMatches.length - 1];\n //     if (\n //       lastChampMatch &&\n //       lastChampMatch.isCompleted &&\n //       lastChampMatch.winner &&\n //       lastChampMatch.loser\n //     ) {\n //       const winnersBracketTeam = lastChampMatch.team1;\n //       const losersBracketTeam = lastChampMatch.team2;\n //       const losersBracketTeamWon =\n //         losersBracketTeam && lastChampMatch.winner.id === losersBracketTeam.id;\n //       // If loser's bracket team won first championship match, winner's bracket team gets another chance\n //       if (losersBracketTeamWon && tournament.championshipMatchesPlayed === 1) {\n //         // Do NOT increment the winner's bracket team's loss count or set winner yet\n //         // Wait for the rematch to be played\n //         winner = undefined; // No winner yet, need reset match\n //       } else if (\n //         lastChampMatch.requiresRematch &&\n //         !lastChampMatch.isCompleted\n //       ) {\n //         // If the rematch is required but not completed, do not set winner or increment losses\n //         winner = undefined;\n //       } else {\n //         // If this is the rematch and it's completed, increment loss for winner's bracket team ONLY IF they lose again\n //         if (\n //           lastChampMatch.requiresRematch &&\n //           lastChampMatch.isCompleted &&\n //           winnersBracketTeam &&\n //           lastChampMatch.winner.id !== winnersBracketTeam.id &&\n //           typeof winnersBracketTeam.losses === \"number\"\n //         ) {\n //           winnersBracketTeam.losses += 1;\n //         }\n //         winner = lastChampMatch.winner;\n //       }\n //     }\n //   }\n //   // --- INFINITE RECURSION GUARD ---\n //   const noMoreMatches =\n //     (isChampionshipRound && championshipMatches.length === 0) ||\n //     (!isChampionshipRound && nextRoundMatches.length === 0);\n //   if (noMoreMatches) {\n //     // Tournament is over, do not advance further\n //     return {\n //       ...tournament,\n //       winner,\n //       currentRound: tournament.currentRound\n //     };\n //   }\n //   // <--- PLACE THE DEBUG CALL HERE, just before returning the new tournament object!\n //   logTournamentState({\n //     roundNumber: nextRoundNumber,\n //     winnersBracketTeams,\n //     losersBracketTeams,\n //     matches: isChampionshipRound ? championshipMatches : nextRoundMatches,\n //     winnersBracketFinalLoser: tournament.winnersBracketFinalLoser\n //   });\n //   // Compose the new tournament object\n //   return {\n //     ...tournament,\n //     rounds: [\n //       ...tournament.rounds,\n //       {\n //         roundNumber: nextRoundNumber,\n //         matches: isChampionshipRound ? championshipMatches : nextRoundMatches,\n //         isDoubleElimination: true,\n //         isChampionshipRound\n //       }\n //     ],\n //     currentRound: nextRoundNumber,\n //     eliminatedTeams: [\n //       ...tournament.eliminatedTeams,\n //       ...newlyEliminated.filter(\n //         (t) => !tournament.eliminatedTeams.some((et) => et.id === t.id)\n //       )\n //     ],\n //     championshipMatchesPlayed: isChampionshipRound\n //       ? tournament.championshipMatchesPlayed + 1\n //       : tournament.championshipMatchesPlayed,\n //     winnersBracketFinalLoser: tournament.winnersBracketFinalLoser,\n //     winner\n //   };\n // };\n // function logTournamentState({\n //   roundNumber,\n //   winnersBracketTeams,\n //   losersBracketTeams,\n //   matches,\n //   winnersBracketFinalLoser\n // }: {\n //   roundNumber: number,\n //   winnersBracketTeams: any[],\n //   losersBracketTeams: any[],\n //   matches: any[],\n //   winnersBracketFinalLoser: any\n // }) {\n //   // eslint-disable-next-line no-console\n //   console.log('--- TOURNAMENT DEBUG ---');\n //   console.log('Round:', roundNumber);\n //   console.log('Winners Bracket Teams:', winnersBracketTeams.map(t => `${t.name} (${t.id})`).join(', '));\n //   console.log('Losers Bracket Teams:', losersBracketTeams.map(t => `${t.name} (${t.id})`).join(', '));\n //   console.log('Matches:');\n //   matches.forEach(m =>\n //     console.log(`  [${m.bracket}] ${m.team1?.name ?? 'TBD'} vs ${m.team2?.name ?? 'TBD'} | isCompleted: ${m.isCompleted} | isBye: ${m.isBye}`)\n //   );\n //   if (winnersBracketFinalLoser) {\n //     console.log('Winners Bracket Final Loser:', winnersBracketFinalLoser.name, winnersBracketFinalLoser.id);\n //   }\n //   console.log('------------------------');\n // }\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3R5cGVzL3RvdXJuYW1lbnQvbWF0Y2hlcy50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUMwRDtBQW1DbkQsTUFBTUMsY0FBYyxTQUN6QkMsSUFDQUMsYUFDQUMsT0FDQUM7UUFDQUMseUVBQWlCLE9BQ2pCQywyRUFBaUQsV0FDakRDLDREQUNBQztRQVNpQkw7V0FSTjtRQUNYRjtRQUNBQztRQUNBQztRQUNBQztRQUNBSyxhQUFhSjtRQUNiQTtRQUNBQztRQUNBSSxRQUFRTCxRQUFTRixDQUFBQSxPQUFBQSxrQkFBQUEsbUJBQUFBLFFBQVNDLG1CQUFURCxrQkFBQUEsT0FBa0JRLFlBQWFBO1FBQ2hEQyxPQUFPUCxRQUFRTSxZQUFZQTtRQUMzQkUsT0FBTztZQUFFQyxZQUFZO1lBQUdDLFlBQVk7UUFBRTtRQUN0Q1I7UUFDQUM7UUFDQVEsaUJBQWlCTDtJQUNuQjtBQUFBLEVBQUc7QUFFSSxNQUFNTSxzQkFBc0IsQ0FBQ0M7SUFDbEMsTUFBTUMsV0FBV0QsTUFBTUUsTUFBTTtJQUM3QixNQUFNQyxVQUFtQixFQUFFO0lBQzNCLE1BQU1DLFlBQVlDLEtBQUtDLElBQUksQ0FBQ0QsS0FBS0UsSUFBSSxDQUFDTjtJQUV0QyxNQUFNTyxvQkFBb0JILEtBQUtJLEdBQUcsQ0FBQyxHQUFHTCxZQUFZO0lBQ2xELElBQUlNLGVBQWU7SUFFbkIsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlILG1CQUFtQkcsSUFBSztRQUMxQyxNQUFNMUIsUUFBUWUsS0FBSyxDQUFDVyxJQUFJLEVBQUUsSUFBSTtRQUM5QixNQUFNekIsUUFBUWMsS0FBSyxDQUFDVyxJQUFJLElBQUksRUFBRSxJQUFJO1FBQ2xDLE1BQU14QixRQUFRLENBQUNGLFNBQVMsQ0FBQ0M7UUFFekIsTUFBTTBCLFVBQVUsTUFBbUIsT0FBYkY7UUFDdEIsTUFBTXJCLGNBQWMsTUFBa0MsT0FBNUJnQixLQUFLQyxJQUFJLENBQUNJLGVBQWU7UUFDbkQsTUFBTXBCLG1CQUFtQixN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QixnQkFBZ0I7Q0FDaEIsOEJBQThCO0NBQzlCLFVBQVU7Q0FDVix3Q0FBd0M7Q0FDeEMsaUZBQWlGO0NBQ2pGLHFDQUFxQztDQUNyQyw4QkFBOEI7Q0FDOUIsVUFBVTtDQUNWLFNBQVM7Q0FDVCxxQ0FBcUM7Q0FDckMseUJBQXlCO0NBQ3pCLHVDQUF1QztDQUN2QyxtQ0FBbUM7Q0FDbkMsMEVBQTBFO0NBQzFFLFVBQVU7Q0FDVixTQUFTO0NBQ1QscURBQXFEO0NBQ3JELG1EQUFtRDtDQUNuRCxnREFBZ0Q7Q0FDaEQscUVBQXFFO0NBQ3JFLGFBQWE7Q0FDYixPQUFPO0NBQ1AsS0FBSztDQUVMLGdDQUFnQztDQUNoQyxpQkFBaUI7Q0FDakIseUJBQXlCO0NBQ3pCLHdCQUF3QjtDQUN4QixhQUFhO0NBQ2IsNkJBQTZCO0NBQzdCLE9BQU87Q0FDUCx5QkFBeUI7Q0FDekIsZ0NBQWdDO0NBQ2hDLCtCQUErQjtDQUMvQixvQkFBb0I7Q0FDcEIsa0NBQWtDO0NBQ2xDLE9BQU87Q0FDUCwyQ0FBMkM7Q0FDM0MsNkNBQTZDO0NBQzdDLHdDQUF3QztDQUN4QywyR0FBMkc7Q0FDM0cseUdBQXlHO0NBQ3pHLDZCQUE2QjtDQUM3Qix5QkFBeUI7Q0FDekIsaUpBQWlKO0NBQ2pKLE9BQU87Q0FDUCxvQ0FBb0M7Q0FDcEMsK0dBQStHO0NBQy9HLE1BQU07Q0FDTiw2Q0FBNkM7Q0FDN0MsSUFBSSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi90eXBlcy90b3VybmFtZW50L21hdGNoZXMudHM/ZGEyMiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7IFRlYW0gfSBmcm9tIFwiLi9tbGItdGVhbXNcIjtcbmltcG9ydCB7IGxvZ1RvdXJuYW1lbnRTdGF0ZSB9IGZyb20gXCIuL2xvZ1RvdXJuYW1lbnRTdGF0ZVwiO1xuXG5leHBvcnQgaW50ZXJmYWNlIE1hdGNoIHtcbiAgaWQ6IHN0cmluZztcbiAgcm91bmROdW1iZXI6IG51bWJlcjtcbiAgdGVhbTE6IFRlYW0gfCBudWxsO1xuICB0ZWFtMjogVGVhbSB8IG51bGw7XG4gIGlzQ29tcGxldGVkOiBib29sZWFuO1xuICBpc0J5ZT86IGJvb2xlYW47XG4gIHdpbm5lcj86IFRlYW07XG4gIGxvc2VyPzogVGVhbTtcbiAgYnJhY2tldDogXCJ3aW5uZXJzXCIgfCBcImxvc2Vyc1wiIHwgXCJjaGFtcGlvbnNoaXBcIjtcbiAgc2NvcmU6IHsgdGVhbTFTY29yZTogbnVtYmVyOyB0ZWFtMlNjb3JlOiBudW1iZXIgfTtcbiAgbmV4dE1hdGNoSWQ/OiBzdHJpbmc7XG4gIG5leHRMb3Nlck1hdGNoSWQ/OiBzdHJpbmc7XG4gIGVsaW1pbmF0ZWRMYWJlbD86IHN0cmluZzsgLy8gbGFiZWwgZm9yIGVsaW1pbmF0ZWQgdGVhbXMgaW4gbG9zZXJzIGJyYWNrZXRcbiAgcmVxdWlyZXNSZW1hdGNoPzogYm9vbGVhbjsgLy8gaW5kaWNhdGVzIGlmIGEgY2hhbXBpb25zaGlwIHJlbWF0Y2ggaXMgcmVxdWlyZWRcbn1cblxuZXhwb3J0IGludGVyZmFjZSBSb3VuZCB7XG4gIHJvdW5kTnVtYmVyOiBudW1iZXI7XG4gIG1hdGNoZXM6IE1hdGNoW107XG4gIGlzRG91YmxlRWxpbWluYXRpb246IGJvb2xlYW47XG4gIGlzQ2hhbXBpb25zaGlwUm91bmQ6IGJvb2xlYW47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVG91cm5hbWVudCB7XG4gIHJvdW5kczogUm91bmRbXTtcbiAgY3VycmVudFJvdW5kOiBudW1iZXI7XG4gIGVsaW1pbmF0ZWRUZWFtczogVGVhbVtdO1xuICBjaGFtcGlvbnNoaXBNYXRjaGVzUGxheWVkOiBudW1iZXI7XG4gIHdpbm5lcj86IFRlYW07XG4gIHdpbm5lcnNCcmFja2V0RmluYWxMb3Nlcj86IFRlYW07IC8vIHRyYWNrcyB0aGUgd2lubmVyJ3MgYnJhY2tldCBmaW5hbCBsb3NlciBmb3IgY2hhbXBpb25zaGlwIHJlbWF0Y2ggbG9naWNcbn1cblxuZXhwb3J0IGNvbnN0IGNyZWF0ZU1hdGNoID0gKFxuICBpZDogc3RyaW5nLFxuICByb3VuZE51bWJlcjogbnVtYmVyLFxuICB0ZWFtMTogVGVhbSB8IG51bGwsXG4gIHRlYW0yOiBUZWFtIHwgbnVsbCxcbiAgaXNCeWU6IGJvb2xlYW4gPSBmYWxzZSxcbiAgYnJhY2tldDogXCJ3aW5uZXJzXCIgfCBcImxvc2Vyc1wiIHwgXCJjaGFtcGlvbnNoaXBcIiA9IFwid2lubmVyc1wiLFxuICBuZXh0TWF0Y2hJZD86IHN0cmluZyxcbiAgbmV4dExvc2VyTWF0Y2hJZD86IHN0cmluZ1xuKTogTWF0Y2ggPT4gKHtcbiAgaWQsXG4gIHJvdW5kTnVtYmVyLFxuICB0ZWFtMSxcbiAgdGVhbTIsXG4gIGlzQ29tcGxldGVkOiBpc0J5ZSxcbiAgaXNCeWUsXG4gIGJyYWNrZXQsXG4gIHdpbm5lcjogaXNCeWUgPyAodGVhbTEgPz8gdGVhbTIgPz8gdW5kZWZpbmVkKSA6IHVuZGVmaW5lZCxcbiAgbG9zZXI6IGlzQnllID8gdW5kZWZpbmVkIDogdW5kZWZpbmVkLFxuICBzY29yZTogeyB0ZWFtMVNjb3JlOiAwLCB0ZWFtMlNjb3JlOiAwIH0sXG4gIG5leHRNYXRjaElkLFxuICBuZXh0TG9zZXJNYXRjaElkLFxuICBlbGltaW5hdGVkTGFiZWw6IHVuZGVmaW5lZFxufSk7XG5cbmV4cG9ydCBjb25zdCBjcmVhdGVJbml0aWFsUm91bmRzID0gKHRlYW1zOiBUZWFtW10pOiBUb3VybmFtZW50ID0+IHtcbiAgY29uc3QgbnVtVGVhbXMgPSB0ZWFtcy5sZW5ndGg7XG4gIGNvbnN0IG1hdGNoZXM6IE1hdGNoW10gPSBbXTtcbiAgY29uc3QgbnVtUm91bmRzID0gTWF0aC5jZWlsKE1hdGgubG9nMihudW1UZWFtcykpO1xuXG4gIGNvbnN0IGZpcnN0Um91bmRNYXRjaGVzID0gTWF0aC5wb3coMiwgbnVtUm91bmRzIC0gMSk7XG4gIGxldCBtYXRjaENvdW50ZXIgPSAxO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZmlyc3RSb3VuZE1hdGNoZXM7IGkrKykge1xuICAgIGNvbnN0IHRlYW0xID0gdGVhbXNbaSAqIDJdIHx8IG51bGw7XG4gICAgY29uc3QgdGVhbTIgPSB0ZWFtc1tpICogMiArIDFdIHx8IG51bGw7XG4gICAgY29uc3QgaXNCeWUgPSAhdGVhbTEgfHwgIXRlYW0yO1xuXG4gICAgY29uc3QgbWF0Y2hJZCA9IGBXMS0ke21hdGNoQ291bnRlcn1gO1xuICAgIGNvbnN0IG5leHRNYXRjaElkID0gYFcyLSR7TWF0aC5jZWlsKG1hdGNoQ291bnRlciAvIDIpfWA7XG4gICAgY29uc3QgbmV4dExvc2VyTWF0Y2hJZCA9IGBMMS0ke01hdGguY2VpbChtYXRjaENvdW50ZXIgLyAyKX1gO1xuXG4gICAgbWF0Y2hlcy5wdXNoKFxuICAgICAgY3JlYXRlTWF0Y2goXG4gICAgICAgIG1hdGNoSWQsXG4gICAgICAgIDEsXG4gICAgICAgIHRlYW0xLFxuICAgICAgICB0ZWFtMixcbiAgICAgICAgaXNCeWUsXG4gICAgICAgIFwid2lubmVyc1wiLFxuICAgICAgICBuZXh0TWF0Y2hJZCxcbiAgICAgICAgbmV4dExvc2VyTWF0Y2hJZFxuICAgICAgKVxuICAgICk7XG4gICAgbWF0Y2hDb3VudGVyKys7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHJvdW5kczogW1xuICAgICAge1xuICAgICAgICByb3VuZE51bWJlcjogMSxcbiAgICAgICAgbWF0Y2hlcyxcbiAgICAgICAgaXNEb3VibGVFbGltaW5hdGlvbjogdHJ1ZSxcbiAgICAgICAgaXNDaGFtcGlvbnNoaXBSb3VuZDogZmFsc2VcbiAgICAgIH1cbiAgICBdLFxuICAgIGN1cnJlbnRSb3VuZDogMSxcbiAgICBlbGltaW5hdGVkVGVhbXM6IFtdLFxuICAgIGNoYW1waW9uc2hpcE1hdGNoZXNQbGF5ZWQ6IDBcbiAgfTtcbn07XG5cbmV4cG9ydCBjb25zdCB1cGRhdGVNYXRjaFNjb3JlID0gKFxuICBtYXRjaDogTWF0Y2gsXG4gIG5ld1Njb3JlOiB7IHRlYW0xU2NvcmU6IG51bWJlcjsgdGVhbTJTY29yZTogbnVtYmVyIH1cbik6IE1hdGNoID0+IHtcbiAgY29uc3QgaXNDb21wbGV0ZWQgPSBuZXdTY29yZS50ZWFtMVNjb3JlICE9PSBuZXdTY29yZS50ZWFtMlNjb3JlO1xuICBsZXQgd2lubmVyOiBUZWFtIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuICBsZXQgbG9zZXI6IFRlYW0gfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG4gIGlmIChpc0NvbXBsZXRlZCkge1xuICAgIGlmIChuZXdTY29yZS50ZWFtMVNjb3JlID4gbmV3U2NvcmUudGVhbTJTY29yZSkge1xuICAgICAgd2lubmVyID0gbWF0Y2gudGVhbTEgPyB7IC4uLm1hdGNoLnRlYW0xLCB3aW5zOiAobWF0Y2gudGVhbTEud2lucyA/PyAwKSArIDEsIGxvc3NlczogbWF0Y2gudGVhbTEubG9zc2VzID8/IDAgfSA6IHVuZGVmaW5lZDtcbiAgICAgIGxvc2VyID0gbWF0Y2gudGVhbTIgPyB7IC4uLm1hdGNoLnRlYW0yLCB3aW5zOiBtYXRjaC50ZWFtMi53aW5zID8/IDAsIGxvc3NlczogKG1hdGNoLnRlYW0yLmxvc3NlcyA/PyAwKSArIDEgfSA6IHVuZGVmaW5lZDtcbiAgICB9IGVsc2Uge1xuICAgICAgd2lubmVyID0gbWF0Y2gudGVhbTIgPyB7IC4uLm1hdGNoLnRlYW0yLCB3aW5zOiAobWF0Y2gudGVhbTIud2lucyA/PyAwKSArIDEsIGxvc3NlczogbWF0Y2gudGVhbTIubG9zc2VzID8/IDAgfSA6IHVuZGVmaW5lZDtcbiAgICAgIGxvc2VyID0gbWF0Y2gudGVhbTEgPyB7IC4uLm1hdGNoLnRlYW0xLCB3aW5zOiBtYXRjaC50ZWFtMS53aW5zID8/IDAsIGxvc3NlczogKG1hdGNoLnRlYW0xLmxvc3NlcyA/PyAwKSArIDEgfSA6IHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICAuLi5tYXRjaCxcbiAgICBzY29yZTogbmV3U2NvcmUsXG4gICAgaXNDb21wbGV0ZWQsXG4gICAgd2lubmVyLFxuICAgIGxvc2VyXG4gIH07XG59O1xuXG4vLyBIZWxwZXIgdG8gZGVkdXBsaWNhdGUgdGVhbXMgYnkgSURcbmZ1bmN0aW9uIGRlZHVwZVRlYW1zKHRlYW1zOiBUZWFtW10pOiBUZWFtW10ge1xuICBjb25zdCBzZWVuID0gbmV3IFNldDxzdHJpbmc+KCk7XG4gIHJldHVybiB0ZWFtcy5maWx0ZXIodGVhbSA9PiB7XG4gICAgaWYgKCF0ZWFtKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKHNlZW4uaGFzKHRlYW0uaWQpKSByZXR1cm4gZmFsc2U7XG4gICAgc2Vlbi5hZGQodGVhbS5pZCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0pO1xufVxuXG4vLyBIZWxwZXI6IGdldCBhbGwgdGVhbXMgd2l0aCBleGFjdGx5IE4gbG9zc2VzXG5mdW5jdGlvbiB0ZWFtc1dpdGhMb3NzZXMobG9zc0NvdW50czogUmVjb3JkPHN0cmluZywgbnVtYmVyPiwgbjogbnVtYmVyKTogc3RyaW5nW10ge1xuICByZXR1cm4gT2JqZWN0LmtleXMobG9zc0NvdW50cykuZmlsdGVyKHRlYW1JZCA9PiBsb3NzQ291bnRzW3RlYW1JZF0gPT09IG4pO1xufVxuZXhwb3J0IGNvbnN0IGFkdmFuY2VUb05leHRSb3VuZCA9ICh0b3VybmFtZW50OiBUb3VybmFtZW50KTogVG91cm5hbWVudCA9PiB7XG4gIGNvbnN0IGN1cnJlbnRSb3VuZCA9IHRvdXJuYW1lbnQucm91bmRzW3RvdXJuYW1lbnQucm91bmRzLmxlbmd0aCAtIDFdO1xuICBjb25zdCBuZXh0Um91bmROdW1iZXIgPSB0b3VybmFtZW50LmN1cnJlbnRSb3VuZCArIDE7XG5cbiAgLy8gVHJhY2sgYWxsIGxvc3NlcyBhbmQgd2lucyBhY3Jvc3MgdGhlIHRvdXJuYW1lbnRcbiAgY29uc3QgbG9zc0NvdW50czogUmVjb3JkPHN0cmluZywgbnVtYmVyPiA9IHt9O1xuICBjb25zdCB3aW5zQ291bnRzOiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+ID0ge307XG4gIHRvdXJuYW1lbnQucm91bmRzLmZvckVhY2goKHJvdW5kKSA9PiB7XG4gICAgcm91bmQubWF0Y2hlcy5mb3JFYWNoKChtYXRjaCkgPT4ge1xuICAgICAgaWYgKG1hdGNoLmlzQ29tcGxldGVkICYmIG1hdGNoLmxvc2VyKSB7XG4gICAgICAgIGxvc3NDb3VudHNbbWF0Y2gubG9zZXIuaWRdID0gKGxvc3NDb3VudHNbbWF0Y2gubG9zZXIuaWRdIHx8IDApICsgMTtcbiAgICAgIH1cbiAgICAgIGlmIChtYXRjaC5pc0NvbXBsZXRlZCAmJiBtYXRjaC53aW5uZXIpIHtcbiAgICAgICAgd2luc0NvdW50c1ttYXRjaC53aW5uZXIuaWRdID0gKHdpbnNDb3VudHNbbWF0Y2gud2lubmVyLmlkXSB8fCAwKSArIDE7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuXG4gIC8vIEdhdGhlciBhbGwgdGVhbXMgZXZlciBpbiB0aGUgdG91cm5hbWVudCwgYXR0YWNoaW5nIHdpbnNcbiAgY29uc3QgYWxsVGVhbXM6IFRlYW1bXSA9IFtdO1xuICBjb25zdCB0ZWFtSWRzID0gbmV3IFNldDxzdHJpbmc+KCk7XG4gIGZvciAoY29uc3Qgcm91bmQgb2YgdG91cm5hbWVudC5yb3VuZHMpIHtcbiAgICBmb3IgKGNvbnN0IG1hdGNoIG9mIHJvdW5kLm1hdGNoZXMpIHtcbiAgICAgIGlmIChtYXRjaC50ZWFtMSAmJiAhdGVhbUlkcy5oYXMobWF0Y2gudGVhbTEuaWQpKSB7XG4gICAgICAgIGFsbFRlYW1zLnB1c2goe1xuICAgICAgICAgIC4uLm1hdGNoLnRlYW0xLFxuICAgICAgICAgIHdpbnM6IHdpbnNDb3VudHNbbWF0Y2gudGVhbTEuaWRdIHx8IDAsXG4gICAgICAgICAgbG9zc2VzOiBsb3NzQ291bnRzW21hdGNoLnRlYW0xLmlkXSB8fCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0ZWFtSWRzLmFkZChtYXRjaC50ZWFtMS5pZCk7XG4gICAgICB9XG4gICAgICBpZiAobWF0Y2gudGVhbTIgJiYgIXRlYW1JZHMuaGFzKG1hdGNoLnRlYW0yLmlkKSkge1xuICAgICAgICBhbGxUZWFtcy5wdXNoKHtcbiAgICAgICAgICAuLi5tYXRjaC50ZWFtMixcbiAgICAgICAgICB3aW5zOiB3aW5zQ291bnRzW21hdGNoLnRlYW0yLmlkXSB8fCAwLFxuICAgICAgICAgIGxvc3NlczogbG9zc0NvdW50c1ttYXRjaC50ZWFtMi5pZF0gfHwgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGVhbUlkcy5hZGQobWF0Y2gudGVhbTIuaWQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIElkZW50aWZ5IG5ld2x5IGVsaW1pbmF0ZWQgdGVhbXMgKDIgbG9zc2VzKVxuICBjb25zdCBuZXdseUVsaW1pbmF0ZWQ6IFRlYW1bXSA9IFtdO1xuICBmb3IgKGNvbnN0IHRlYW0gb2YgYWxsVGVhbXMpIHtcbiAgICBpZiAoXG4gICAgICAobG9zc0NvdW50c1t0ZWFtLmlkXSB8fCAwKSA+PSAyICYmXG4gICAgICAhdG91cm5hbWVudC5lbGltaW5hdGVkVGVhbXMuc29tZSgodCkgPT4gdC5pZCA9PT0gdGVhbS5pZClcbiAgICApIHtcbiAgICAgIG5ld2x5RWxpbWluYXRlZC5wdXNoKHRlYW0pO1xuICAgIH1cbiAgfVxuXG4gIC8vIFdpbm5lcnM6IHRlYW1zIHdpdGggMCBsb3NzZXMgYW5kIG5vdCBlbGltaW5hdGVkXG4gIGNvbnN0IHdpbm5lcnNCcmFja2V0VGVhbXMgPSBhbGxUZWFtc1xuICAgIC5maWx0ZXIoXG4gICAgICAodGVhbSkgPT5cbiAgICAgICAgKGxvc3NDb3VudHNbdGVhbS5pZF0gfHwgMCkgPT09IDAgJiZcbiAgICAgICAgIXRvdXJuYW1lbnQuZWxpbWluYXRlZFRlYW1zLnNvbWUoKHQpID0+IHQuaWQgPT09IHRlYW0uaWQpICYmXG4gICAgICAgICFuZXdseUVsaW1pbmF0ZWQuc29tZSgodCkgPT4gdC5pZCA9PT0gdGVhbS5pZCkgJiZcbiAgICAgICAgIXRlYW0uaWQuc3RhcnRzV2l0aChcInRiZC1cIikgLy8gRXhjbHVkZSBwaGFudG9tIFRCRCB0ZWFtc1xuICAgIClcbiAgICAubWFwKCh0ZWFtKSA9PiAoe1xuICAgICAgLi4udGVhbSxcbiAgICAgIGxvc3NlczogbG9zc0NvdW50c1t0ZWFtLmlkXSB8fCAwLFxuICAgICAgd2luczogd2luc0NvdW50c1t0ZWFtLmlkXSB8fCAwXG4gICAgfSkpO1xuXG4gIC8vIExvc2VyczogdGVhbXMgd2l0aCAxIGxvc3MgYW5kIG5vdCBlbGltaW5hdGVkXG4gIGNvbnN0IGxvc2Vyc0JyYWNrZXRUZWFtcyA9IGFsbFRlYW1zXG4gICAgLmZpbHRlcihcbiAgICAgICh0ZWFtKSA9PlxuICAgICAgICAobG9zc0NvdW50c1t0ZWFtLmlkXSB8fCAwKSA9PT0gMSAmJlxuICAgICAgICAhdG91cm5hbWVudC5lbGltaW5hdGVkVGVhbXMuc29tZSgodCkgPT4gdC5pZCA9PT0gdGVhbS5pZCkgJiZcbiAgICAgICAgIW5ld2x5RWxpbWluYXRlZC5zb21lKCh0KSA9PiB0LmlkID09PSB0ZWFtLmlkKSAmJlxuICAgICAgICAvLyBEb24ndCBpbmNsdWRlIHRoZSB3aW5uZXJzIGJyYWNrZXQgZmluYWwgbG9zZXIgaW4gcmVndWxhciBsb3NlcnMgYnJhY2tldCB0ZWFtc1xuICAgICAgICAhKFxuICAgICAgICAgIHRvdXJuYW1lbnQud2lubmVyc0JyYWNrZXRGaW5hbExvc2VyICYmXG4gICAgICAgICAgdG91cm5hbWVudC53aW5uZXJzQnJhY2tldEZpbmFsTG9zZXIuaWQgPT09IHRlYW0uaWRcbiAgICAgICAgKVxuICAgIClcbiAgICAubWFwKCh0ZWFtKSA9PiAoe1xuICAgICAgLi4udGVhbSxcbiAgICAgIGxvc3NlczogbG9zc0NvdW50c1t0ZWFtLmlkXSB8fCAwLFxuICAgICAgd2luczogd2luc0NvdW50c1t0ZWFtLmlkXSB8fCAwXG4gICAgfSkpO1xuXG4gIGxldCBpc0NoYW1waW9uc2hpcFJvdW5kID0gZmFsc2U7XG4gIGxldCBjaGFtcGlvbnNoaXBNYXRjaGVzOiBNYXRjaFtdID0gW107XG4gIGxldCBuZXh0Um91bmRNYXRjaGVzOiBNYXRjaFtdID0gW107XG5cbiAgY29uc3QgcHJldkNoYW1waW9uc2hpcE1hdGNoZXMgPSB0b3VybmFtZW50LnJvdW5kc1xuICAgIC5maWx0ZXIoKHIpID0+IHIuaXNDaGFtcGlvbnNoaXBSb3VuZClcbiAgICAuZmxhdE1hcCgocikgPT4gci5tYXRjaGVzKVxuICAgIC5maWx0ZXIoKG0pID0+IG0uYnJhY2tldCA9PT0gXCJjaGFtcGlvbnNoaXBcIik7XG5cbiAgLy8gLS0tIENIQU1QSU9OU0hJUCBMT0dJQyAtLS1cblxuICAvLyBDaGVjayBpZiBhIGNoYW1waW9uc2hpcCBtYXRjaCBhbHJlYWR5IGhhcHBlbmVkIGFuZCB3YXMgY29tcGxldGVkXG4gIGlmIChcbiAgICBwcmV2Q2hhbXBpb25zaGlwTWF0Y2hlcy5sZW5ndGggPj0gMSAmJlxuICAgIHByZXZDaGFtcGlvbnNoaXBNYXRjaGVzW3ByZXZDaGFtcGlvbnNoaXBNYXRjaGVzLmxlbmd0aCAtIDFdLmlzQ29tcGxldGVkXG4gICkge1xuICAgIGNvbnN0IGxhc3RDaGFtcE1hdGNoID1cbiAgICAgIHByZXZDaGFtcGlvbnNoaXBNYXRjaGVzW3ByZXZDaGFtcGlvbnNoaXBNYXRjaGVzLmxlbmd0aCAtIDFdO1xuICAgIGNvbnN0IHdpbm5lcnNCcmFja2V0VGVhbSA9IGxhc3RDaGFtcE1hdGNoLnRlYW0xO1xuICAgIGNvbnN0IGxvc2Vyc0JyYWNrZXRUZWFtID0gbGFzdENoYW1wTWF0Y2gudGVhbTI7XG5cbiAgICAvLyBJZiBsb3NlcidzIGJyYWNrZXQgdGVhbSB3b24gdGhlIGZpcnN0IGNoYW1waW9uc2hpcCBtYXRjaCwgd2lubmVyJ3MgYnJhY2tldCB0ZWFtIGdldHMgYW5vdGhlciBjaGFuY2VcbiAgICBpZiAoXG4gICAgICBsYXN0Q2hhbXBNYXRjaC53aW5uZXI/LmlkID09PSBsb3NlcnNCcmFja2V0VGVhbT8uaWQgJiZcbiAgICAgIHRvdXJuYW1lbnQuY2hhbXBpb25zaGlwTWF0Y2hlc1BsYXllZCA9PT0gMVxuICAgICkge1xuICAgICAgaXNDaGFtcGlvbnNoaXBSb3VuZCA9IHRydWU7XG4gICAgICAvLyBDcmVhdGUgdGhlIFwicmVzZXRcIiBtYXRjaFxuICAgICAgY2hhbXBpb25zaGlwTWF0Y2hlcy5wdXNoKFxuICAgICAgICBjcmVhdGVNYXRjaChcbiAgICAgICAgICBgQyR7bmV4dFJvdW5kTnVtYmVyfS0xYCxcbiAgICAgICAgICBuZXh0Um91bmROdW1iZXIsXG4gICAgICAgICAgd2lubmVyc0JyYWNrZXRUZWFtLFxuICAgICAgICAgIGxvc2Vyc0JyYWNrZXRUZWFtLFxuICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgIFwiY2hhbXBpb25zaGlwXCJcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRWl0aGVyIHdpbm5lcidzIGJyYWNrZXQgdGVhbSB3b24gZmlyc3QgbWF0Y2gsIG9yIHRoaXMgd2FzIHRoZSByZXNldCBtYXRjaFxuICAgICAgaXNDaGFtcGlvbnNoaXBSb3VuZCA9IHRydWU7XG4gICAgICAvLyBObyBuZXcgbWF0Y2hlcywgd2lubmVyIHdpbGwgYmUgZGV0ZXJtaW5lZCBpbiB3aW5uZXIgZGV0ZWN0aW9uIGxvZ2ljXG4gICAgfVxuICB9XG4gIC8vIENoZWNrIGlmIHdlJ3JlIHJlYWR5IGZvciB0aGUgY2hhbXBpb25zaGlwIG1hdGNoIC0gb25lIHRlYW0gaW4gZWFjaCBicmFja2V0IGFuZCBsb3NlcidzIGZpbmFsIGlzIGNvbXBsZXRlXG4gIGVsc2UgaWYgKFxuICAgIHdpbm5lcnNCcmFja2V0VGVhbXMubGVuZ3RoID09PSAxICYmXG4gICAgbG9zZXJzQnJhY2tldFRlYW1zLmxlbmd0aCA9PT0gMSAmJlxuICAgIGN1cnJlbnRSb3VuZC5tYXRjaGVzLnNvbWUoXG4gICAgICAobSkgPT5cbiAgICAgICAgKG0uYnJhY2tldCA9PT0gXCJsb3NlcnNcIiB8fCBtLmlkLmluY2x1ZGVzKFwiTG9zZXJzTGFzdFwiKSkgJiZcbiAgICAgICAgbS5pc0NvbXBsZXRlZCAmJlxuICAgICAgICBtLndpbm5lciAmJlxuICAgICAgICAobG9zZXJzQnJhY2tldFRlYW1zLnNvbWUoKHQpID0+IHQuaWQgPT09IG0ud2lubmVyIS5pZCkgfHxcbiAgICAgICAgICAodG91cm5hbWVudC53aW5uZXJzQnJhY2tldEZpbmFsTG9zZXIgJiZcbiAgICAgICAgICAgIG0ud2lubmVyIS5pZCA9PT0gdG91cm5hbWVudC53aW5uZXJzQnJhY2tldEZpbmFsTG9zZXIuaWQpKVxuICAgIClcbiAgKSB7XG4gICAgLy8gRmluZCB0aGUgd2lubmVyIG9mIHRoZSBsb3NlcnMgYnJhY2tldCBmaW5hbFxuICAgIGNvbnN0IGxvc2Vyc0JyYWNrZXRXaW5uZXIgPSBjdXJyZW50Um91bmQubWF0Y2hlc1xuICAgICAgLmZpbHRlcihcbiAgICAgICAgKG0pID0+XG4gICAgICAgICAgKG0uYnJhY2tldCA9PT0gXCJsb3NlcnNcIiB8fCBtLmlkLmluY2x1ZGVzKFwiTG9zZXJzTGFzdFwiKSkgJiZcbiAgICAgICAgICBtLmlzQ29tcGxldGVkICYmXG4gICAgICAgICAgbS53aW5uZXJcbiAgICAgIClcbiAgICAgIC5tYXAoKG0pID0+IG0ud2lubmVyISlcbiAgICAgIC5wb3AoKTtcblxuICAgIGlmIChsb3NlcnNCcmFja2V0V2lubmVyKSB7XG4gICAgICAvLyBPbmx5IHNjaGVkdWxlIHRoZSBjaGFtcGlvbnNoaXAgaWYgdGhlcmUgaXMgbm8gd2lubmVyc0JyYWNrZXRGaW5hbExvc2VyIHdhaXRpbmcgdG8gcGxheVxuICAgICAgaWYgKCF0b3VybmFtZW50Lndpbm5lcnNCcmFja2V0RmluYWxMb3Nlcikge1xuICAgICAgICBpc0NoYW1waW9uc2hpcFJvdW5kID0gdHJ1ZTtcbiAgICAgICAgY2hhbXBpb25zaGlwTWF0Y2hlcy5wdXNoKFxuICAgICAgICAgIGNyZWF0ZU1hdGNoKFxuICAgICAgICAgICAgYEMke25leHRSb3VuZE51bWJlcn0tMWAsXG4gICAgICAgICAgICBuZXh0Um91bmROdW1iZXIsXG4gICAgICAgICAgICB3aW5uZXJzQnJhY2tldFRlYW1zWzBdLCAvLyBXaW5uZXIncyBicmFja2V0IGNoYW1waW9uXG4gICAgICAgICAgICBsb3NlcnNCcmFja2V0V2lubmVyLCAvLyBMb3NlcidzIGJyYWNrZXQgY2hhbXBpb25cbiAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgXCJjaGFtcGlvbnNoaXBcIlxuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEluc3RlYWQsIHNjaGVkdWxlIHRoZSBsb3NlcnMgYnJhY2tldCBmaW5hbCAoTExXQiB2cyBMV0xCKSwgYW5kIHNob3cgdGhlIHdpbm5lcnMgYnJhY2tldCBjaGFtcGlvbiBhcyB3YWl0aW5nXG4gICAgICAgIG5leHRSb3VuZE1hdGNoZXMucHVzaChcbiAgICAgICAgICBjcmVhdGVNYXRjaChcbiAgICAgICAgICAgIGBMb3NlcnNMYXN0LSR7bmV4dFJvdW5kTnVtYmVyfWAsXG4gICAgICAgICAgICBuZXh0Um91bmROdW1iZXIsXG4gICAgICAgICAgICB0b3VybmFtZW50Lndpbm5lcnNCcmFja2V0RmluYWxMb3NlcixcbiAgICAgICAgICAgIGxvc2Vyc0JyYWNrZXRUZWFtc1swXSxcbiAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgXCJsb3NlcnNcIlxuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgICAgbmV4dFJvdW5kTWF0Y2hlcy5wdXNoKFxuICAgICAgICAgIGNyZWF0ZU1hdGNoKFxuICAgICAgICAgICAgYFdpbm5lcnNCcmFja2V0Q2hhbXBpb24td2FpdGluZy0ke25leHRSb3VuZE51bWJlcn1gLFxuICAgICAgICAgICAgbmV4dFJvdW5kTnVtYmVyLFxuICAgICAgICAgICAgd2lubmVyc0JyYWNrZXRUZWFtc1swXSxcbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICB0cnVlLFxuICAgICAgICAgICAgXCJ3aW5uZXJzXCJcbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8vIENoZWNrIGlmIHdlIG5lZWQgdG8gY3JlYXRlIHRoZSBmaW5hbCBsb3NlcnMgYnJhY2tldCBtYXRjaCAod2lubmVycyBicmFja2V0IGZpbmFsIGxvc2VyIHZzIGxvc2VycyBicmFja2V0IHdpbm5lcilcbiAgZWxzZSBpZiAoXG4gICAgd2lubmVyc0JyYWNrZXRUZWFtcy5sZW5ndGggPT09IDEgJiZcbiAgICB0b3VybmFtZW50Lndpbm5lcnNCcmFja2V0RmluYWxMb3NlclxuICApIHtcbiAgICBpZiAobG9zZXJzQnJhY2tldFRlYW1zLmxlbmd0aCA9PT0gMSkge1xuICAgICAgLy8gUHJldmVudCBkdXBsaWNhdGUgbG9zZXJzIGJyYWNrZXQgZmluYWw6IGNoZWNrIGlmIHByZXZpb3VzIHJvdW5kIGFscmVhZHkgaGFkIHRoaXMgbWF0Y2hcbiAgICAgIGNvbnN0IHByZXZpb3VzUm91bmRNYXRjaGVzID0gdG91cm5hbWVudC5yb3VuZHNbbmV4dFJvdW5kTnVtYmVyIC0gMl0/Lm1hdGNoZXMgfHwgW107XG4gICAgICBjb25zdCBwcmV2SGFkU2FtZU1hdGNoID0gcHJldmlvdXNSb3VuZE1hdGNoZXMuc29tZShcbiAgICAgICAgKG06IGFueSkgPT4ge1xuICAgICAgICAgIGNvbnN0IGlkcyA9IFttLnRlYW0xPy5pZCwgbS50ZWFtMj8uaWRdLmZpbHRlcihCb29sZWFuKS5zb3J0KCk7XG4gICAgICAgICAgY29uc3QgY3VycklkcyA9IFt0b3VybmFtZW50Lndpbm5lcnNCcmFja2V0RmluYWxMb3Nlci5pZCwgbG9zZXJzQnJhY2tldFRlYW1zWzBdLmlkXS5zb3J0KCk7XG4gICAgICAgICAgcmV0dXJuIGlkcy5sZW5ndGggPT09IDIgJiYgaWRzWzBdID09PSBjdXJySWRzWzBdICYmIGlkc1sxXSA9PT0gY3Vycklkc1sxXTtcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICAgIGlmICghcHJldkhhZFNhbWVNYXRjaCkge1xuICAgICAgICAvLyBPbmx5IG5vdyBzY2hlZHVsZSBXQkZMIHZzIExCTFxuICAgICAgICBuZXh0Um91bmRNYXRjaGVzLnB1c2goXG4gICAgICAgICAgY3JlYXRlTWF0Y2goXG4gICAgICAgICAgICBgTG9zZXJzTGFzdC0ke25leHRSb3VuZE51bWJlcn1gLFxuICAgICAgICAgICAgbmV4dFJvdW5kTnVtYmVyLFxuICAgICAgICAgICAgdG91cm5hbWVudC53aW5uZXJzQnJhY2tldEZpbmFsTG9zZXIsXG4gICAgICAgICAgICBsb3NlcnNCcmFja2V0VGVhbXNbMF0sXG4gICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgIFwibG9zZXJzXCJcbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICAvLyBJZiBtYXRjaCBhbHJlYWR5IHBsYXllZCwgZG8gbm90IHNjaGVkdWxlIGFnYWluOyBjaGFtcGlvbnNoaXAgbG9naWMgd2lsbCBoYW5kbGUgbmV4dCBzdGVwXG4gICAgfSBlbHNlIGlmIChsb3NlcnNCcmFja2V0VGVhbXMubGVuZ3RoID09PSAyKSB7XG4gICAgICAvLyBTY2hlZHVsZSB0aGUgbWF0Y2ggYmV0d2VlbiB0aGUgbGFzdCB0d28gbG9zZXJzIGJyYWNrZXQgdGVhbXNcbiAgICAgIG5leHRSb3VuZE1hdGNoZXMucHVzaChcbiAgICAgICAgY3JlYXRlTWF0Y2goXG4gICAgICAgICAgYEwke25leHRSb3VuZE51bWJlcn0tMWAsXG4gICAgICAgICAgbmV4dFJvdW5kTnVtYmVyLFxuICAgICAgICAgIGxvc2Vyc0JyYWNrZXRUZWFtc1swXSxcbiAgICAgICAgICBsb3NlcnNCcmFja2V0VGVhbXNbMV0sXG4gICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgXCJsb3NlcnNcIlxuICAgICAgICApXG4gICAgICApO1xuICAgICAgLy8gV0JGTCBpcyB3YWl0aW5nIGZvciB0aGUgd2lubmVyXG4gICAgICBuZXh0Um91bmRNYXRjaGVzLnB1c2goXG4gICAgICAgIGNyZWF0ZU1hdGNoKFxuICAgICAgICAgIGBXaW5uZXJzRmluYWxMb3Nlci13YWl0aW5nLSR7bmV4dFJvdW5kTnVtYmVyfWAsXG4gICAgICAgICAgbmV4dFJvdW5kTnVtYmVyLFxuICAgICAgICAgIHRvdXJuYW1lbnQud2lubmVyc0JyYWNrZXRGaW5hbExvc2VyLFxuICAgICAgICAgIG51bGwsXG4gICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICBcImxvc2Vyc1wiXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfSBlbHNlIGlmIChsb3NlcnNCcmFja2V0VGVhbXMubGVuZ3RoID4gMikge1xuICAgICAgLy8gTW9yZSB0aGFuIDIgdGVhbXM6IHBhaXIgb2ZmIGFzIHVzdWFsLCBXQkZMIHdhaXRzXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxvc2Vyc0JyYWNrZXRUZWFtcy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICBjb25zdCB0ZWFtMSA9IGxvc2Vyc0JyYWNrZXRUZWFtc1tpXTtcbiAgICAgICAgY29uc3QgdGVhbTIgPSBsb3NlcnNCcmFja2V0VGVhbXNbaSArIDFdID8/IG51bGw7XG4gICAgICAgIG5leHRSb3VuZE1hdGNoZXMucHVzaChcbiAgICAgICAgICBjcmVhdGVNYXRjaChcbiAgICAgICAgICAgIGBMJHtuZXh0Um91bmROdW1iZXJ9LSR7TWF0aC5mbG9vcihpIC8gMikgKyAxfWAsXG4gICAgICAgICAgICBuZXh0Um91bmROdW1iZXIsXG4gICAgICAgICAgICB0ZWFtMSxcbiAgICAgICAgICAgIHRlYW0yLFxuICAgICAgICAgICAgIXRlYW0yLFxuICAgICAgICAgICAgXCJsb3NlcnNcIlxuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIG5leHRSb3VuZE1hdGNoZXMucHVzaChcbiAgICAgICAgY3JlYXRlTWF0Y2goXG4gICAgICAgICAgYFdpbm5lcnNGaW5hbExvc2VyLXdhaXRpbmctJHtuZXh0Um91bmROdW1iZXJ9YCxcbiAgICAgICAgICBuZXh0Um91bmROdW1iZXIsXG4gICAgICAgICAgdG91cm5hbWVudC53aW5uZXJzQnJhY2tldEZpbmFsTG9zZXIsXG4gICAgICAgICAgbnVsbCxcbiAgICAgICAgICB0cnVlLFxuICAgICAgICAgIFwibG9zZXJzXCJcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gV0JGTCBpcyB3YWl0aW5nIGZvciB0aGUgbG9zZXJzIGJyYWNrZXQgdG8gcmVzb2x2ZVxuICAgICAgbmV4dFJvdW5kTWF0Y2hlcy5wdXNoKFxuICAgICAgICBjcmVhdGVNYXRjaChcbiAgICAgICAgICBgV2lubmVyc0ZpbmFsTG9zZXItd2FpdGluZy0ke25leHRSb3VuZE51bWJlcn1gLFxuICAgICAgICAgIG5leHRSb3VuZE51bWJlcixcbiAgICAgICAgICB0b3VybmFtZW50Lndpbm5lcnNCcmFja2V0RmluYWxMb3NlcixcbiAgICAgICAgICBudWxsLFxuICAgICAgICAgIHRydWUsXG4gICAgICAgICAgXCJsb3NlcnNcIlxuICAgICAgICApXG4gICAgICApO1xuICAgIH1cbiAgICAvLyBBbHdheXMgc2hvdyBhIHdhaXRpbmcgY2FyZCBmb3IgdGhlIHdpbm5lcnMgYnJhY2tldCBjaGFtcGlvbiBpZiBub3QgaW4gY2hhbXBpb25zaGlwXG4gICAgbmV4dFJvdW5kTWF0Y2hlcy5wdXNoKFxuICAgICAgY3JlYXRlTWF0Y2goXG4gICAgICAgIGBXaW5uZXJzQnJhY2tldENoYW1waW9uLXdhaXRpbmctJHtuZXh0Um91bmROdW1iZXJ9YCxcbiAgICAgICAgbmV4dFJvdW5kTnVtYmVyLFxuICAgICAgICB3aW5uZXJzQnJhY2tldFRlYW1zWzBdLFxuICAgICAgICBudWxsLFxuICAgICAgICB0cnVlLFxuICAgICAgICBcIndpbm5lcnNcIlxuICAgICAgKVxuICAgICk7XG4gIH1cbiAgLy8gQ2hlY2sgaWYgdGhpcyBpcyB0aGUgd2lubmVyJ3MgYnJhY2tldCBmaW5hbCAoZXhhY3RseSAyIHRlYW1zIGluIHdpbm5lcidzIGJyYWNrZXQpXG4gIGVsc2UgaWYgKHdpbm5lcnNCcmFja2V0VGVhbXMubGVuZ3RoID09PSAyKSB7XG4gICAgLy8gQ3JlYXRlIHRoZSB3aW5uZXIncyBicmFja2V0IGZpbmFsIG1hdGNoXG4gICAgbmV4dFJvdW5kTWF0Y2hlcy5wdXNoKFxuICAgICAgY3JlYXRlTWF0Y2goXG4gICAgICAgIGBXJHtuZXh0Um91bmROdW1iZXJ9LTFgLFxuICAgICAgICBuZXh0Um91bmROdW1iZXIsXG4gICAgICAgIHdpbm5lcnNCcmFja2V0VGVhbXNbMF0sXG4gICAgICAgIHdpbm5lcnNCcmFja2V0VGVhbXNbMV0sXG4gICAgICAgIGZhbHNlLFxuICAgICAgICBcIndpbm5lcnNcIlxuICAgICAgKVxuICAgICk7XG5cbiAgICAvLyBDb250aW51ZSB3aXRoIGxvc2VycyBicmFja2V0IG1hdGNoZXMgc2VwYXJhdGVseVxuICAgIGNyZWF0ZUxvc2Vyc0JyYWNrZXRNYXRjaGVzKCk7XG4gIH1cbiAgLy8gT3RoZXJ3aXNlLCBjb250aW51ZSB3aXRoIG5vcm1hbCBicmFja2V0IHBsYXlcbiAgZWxzZSB7XG4gICAgY3JlYXRlU3RhbmRhcmRCcmFja2V0TWF0Y2hlcygpO1xuICB9XG5cbiAgLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGNyZWF0ZSBzdGFuZGFyZCBicmFja2V0IG1hdGNoZXNcbiAgZnVuY3Rpb24gY3JlYXRlU3RhbmRhcmRCcmFja2V0TWF0Y2hlcygpIHtcbiAgICAvLyAtLS0gV2lubmVycyBCcmFja2V0IE1hdGNoZXMgLS0tXG4gICAgbGV0IG1hdGNoQ291bnRlciA9IDE7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB3aW5uZXJzQnJhY2tldFRlYW1zLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICBjb25zdCB0ZWFtMSA9IHdpbm5lcnNCcmFja2V0VGVhbXNbaV07XG4gICAgICBjb25zdCB0ZWFtMiA9IHdpbm5lcnNCcmFja2V0VGVhbXNbaSArIDFdID8/IG51bGw7XG4gICAgICBjb25zdCBpc0J5ZSA9ICF0ZWFtMjtcbiAgICAgIG5leHRSb3VuZE1hdGNoZXMucHVzaChcbiAgICAgICAgY3JlYXRlTWF0Y2goXG4gICAgICAgICAgYFcke25leHRSb3VuZE51bWJlcn0tJHttYXRjaENvdW50ZXJ9YCxcbiAgICAgICAgICBuZXh0Um91bmROdW1iZXIsXG4gICAgICAgICAgdGVhbTEsXG4gICAgICAgICAgdGVhbTIsXG4gICAgICAgICAgaXNCeWUsXG4gICAgICAgICAgXCJ3aW5uZXJzXCJcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICAgIG1hdGNoQ291bnRlcisrO1xuICAgIH1cblxuICAgIC8vIENyZWF0ZSBsb3NlcnMgYnJhY2tldCBtYXRjaGVzIHNlcGFyYXRlbHlcbiAgICBjcmVhdGVMb3NlcnNCcmFja2V0TWF0Y2hlcygpO1xuICB9XG5cbiAgLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGNyZWF0ZSBsb3NlcnMgYnJhY2tldCBtYXRjaGVzXG4gIGZ1bmN0aW9uIGNyZWF0ZUxvc2Vyc0JyYWNrZXRNYXRjaGVzKCkge1xuICAgIC8vIC0tLSBMb3NlcnMgQnJhY2tldCBNYXRjaGVzIC0tLVxuICAgIGNvbnN0IGVsaWdpYmxlTG9zZXJzID0gYWxsVGVhbXMuZmlsdGVyKFxuICAgICAgKHRlYW0pID0+XG4gICAgICAgIChsb3NzQ291bnRzW3RlYW0uaWRdIHx8IDApID09PSAxICYmXG4gICAgICAgICF0b3VybmFtZW50LmVsaW1pbmF0ZWRUZWFtcy5zb21lKCh0KSA9PiB0LmlkID09PSB0ZWFtLmlkKSAmJlxuICAgICAgICAhbmV3bHlFbGltaW5hdGVkLnNvbWUoKHQpID0+IHQuaWQgPT09IHRlYW0uaWQpICYmXG4gICAgICAgIC8vIEV4Y2x1ZGUgd2lubmVyJ3MgYnJhY2tldCBmaW5hbCBsb3NlciBpZiBpdCBleGlzdHNcbiAgICAgICAgIShcbiAgICAgICAgICB0b3VybmFtZW50Lndpbm5lcnNCcmFja2V0RmluYWxMb3NlciAmJlxuICAgICAgICAgIHRvdXJuYW1lbnQud2lubmVyc0JyYWNrZXRGaW5hbExvc2VyLmlkID09PSB0ZWFtLmlkXG4gICAgICAgIClcbiAgICApO1xuXG4gICAgLy8gRmluZCB0ZWFtcyByZWNlbnRseSBkcm9wcGVkIGZyb20gd2lubmVycyBicmFja2V0XG4gICAgY29uc3QganVzdERyb3BwZWRGcm9tV2lubmVycyA9IGN1cnJlbnRSb3VuZC5tYXRjaGVzXG4gICAgICAuZmlsdGVyKChtKSA9PiBtLmJyYWNrZXQgPT09IFwid2lubmVyc1wiICYmIG0ubG9zZXIgJiYgbS5pc0NvbXBsZXRlZClcbiAgICAgIC5tYXAoKG0pID0+IG0ubG9zZXIhKVxuICAgICAgLmZpbHRlcigobG9zZXIpID0+IGVsaWdpYmxlTG9zZXJzLnNvbWUoKHQpID0+IHQuaWQgPT09IGxvc2VyLmlkKSk7XG5cbiAgICAvLyBJZiB0aGlzIGlzIHRoZSB3aW5uZXIncyBicmFja2V0IGZpbmFsLCBzdG9yZSB0aGUgbG9zZXIgZm9yIGxhdGVyIHVzZVxuICAgIGlmIChcbiAgICAgIGN1cnJlbnRSb3VuZC5tYXRjaGVzLnNvbWUoXG4gICAgICAgIChtKSA9PlxuICAgICAgICAgIG0uYnJhY2tldCA9PT0gXCJ3aW5uZXJzXCIgJiZcbiAgICAgICAgICB3aW5uZXJzQnJhY2tldFRlYW1zLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgICAgIG0ubG9zZXIgJiZcbiAgICAgICAgICBtLmlzQ29tcGxldGVkXG4gICAgICApXG4gICAgKSB7XG4gICAgICAvLyBUaGlzIGlzIGEgc3BlY2lhbCBjYXNlIC0gd2UgZm91bmQgdGhlIHdpbm5lcidzIGJyYWNrZXQgZmluYWwgbG9zZXJcbiAgICAgIGNvbnN0IHdpbm5lcnNGaW5hbExvc2VyID0gY3VycmVudFJvdW5kLm1hdGNoZXNcbiAgICAgICAgLmZpbHRlcigobSkgPT4gbS5icmFja2V0ID09PSBcIndpbm5lcnNcIiAmJiBtLmlzQ29tcGxldGVkICYmIG0ubG9zZXIpXG4gICAgICAgIC5tYXAoKG0pID0+IG0ubG9zZXIhKVxuICAgICAgICAucG9wKCk7XG5cbiAgICAgIGlmIChcbiAgICAgICAgd2lubmVyc0ZpbmFsTG9zZXIgJiZcbiAgICAgICAgIXRvdXJuYW1lbnQuZWxpbWluYXRlZFRlYW1zLnNvbWUoKHQpID0+IHQuaWQgPT09IHdpbm5lcnNGaW5hbExvc2VyLmlkKVxuICAgICAgKSB7XG4gICAgICAgIHRvdXJuYW1lbnQud2lubmVyc0JyYWNrZXRGaW5hbExvc2VyID0gd2lubmVyc0ZpbmFsTG9zZXI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gRXhpc3RpbmcgbG9zZXJzIGJyYWNrZXQgdGVhbXNcbiAgICBjb25zdCBleGlzdGluZ0xvc2VycyA9IGVsaWdpYmxlTG9zZXJzLmZpbHRlcihcbiAgICAgICh0KSA9PiAhanVzdERyb3BwZWRGcm9tV2lubmVycy5zb21lKChqZCkgPT4gamQuaWQgPT09IHQuaWQpXG4gICAgKTtcblxuICAgIC8vIE9yZGVyOiBtb3N0IHJlY2VudCBkcm9wKHMpIGZpcnN0XG4gICAgY29uc3Qgb3JkZXJlZExvc2VycyA9IFsuLi5qdXN0RHJvcHBlZEZyb21XaW5uZXJzLCAuLi5leGlzdGluZ0xvc2Vyc107XG5cbiAgICBpZiAob3JkZXJlZExvc2Vycy5sZW5ndGggPiAwKSB7XG4gICAgICBpZiAob3JkZXJlZExvc2Vycy5sZW5ndGggJSAyID09PSAxKSB7XG4gICAgICAgIC8vIE9kZDogYnllIGdvZXMgdG8gdGhlIG1vc3QgcmVjZW50IHRlYW0gZHJvcHBlZCBmcm9tIHdpbm5lcnMgYnJhY2tldFxuICAgICAgICBsZXQgdGVhbVdpdGhCeWU6IFRlYW0gfCBudWxsID0gbnVsbDtcbiAgICAgICAgaWYgKGp1c3REcm9wcGVkRnJvbVdpbm5lcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHRlYW1XaXRoQnllID1cbiAgICAgICAgICAgIGp1c3REcm9wcGVkRnJvbVdpbm5lcnNbanVzdERyb3BwZWRGcm9tV2lubmVycy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAvLyBSZW1vdmUgdGhlIGJ5ZSB0ZWFtIGZyb20gb3JkZXJlZExvc2Vyc1xuICAgICAgICAgIGNvbnN0IGJ5ZUluZGV4ID0gb3JkZXJlZExvc2Vycy5maW5kSW5kZXgoXG4gICAgICAgICAgICAodCkgPT4gdC5pZCA9PT0gdGVhbVdpdGhCeWUhLmlkXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpZiAoYnllSW5kZXggIT09IC0xKSBvcmRlcmVkTG9zZXJzLnNwbGljZShieWVJbmRleCwgMSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gRGVmZW5zaXZlOiBmYWxsYmFjayB0byBmaXJzdCB0ZWFtIGlmIG5vIHJlY2VudCBkcm9wXG4gICAgICAgICAgdGVhbVdpdGhCeWUgPSBvcmRlcmVkTG9zZXJzLnNoaWZ0KCkhO1xuICAgICAgICB9XG4gICAgICAgIG5leHRSb3VuZE1hdGNoZXMucHVzaChcbiAgICAgICAgICBjcmVhdGVNYXRjaChcbiAgICAgICAgICAgIGBMJHtuZXh0Um91bmROdW1iZXJ9LTFgLFxuICAgICAgICAgICAgbmV4dFJvdW5kTnVtYmVyLFxuICAgICAgICAgICAgdGVhbVdpdGhCeWUsXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAgIFwibG9zZXJzXCJcbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICAgIC8vIFBhaXIgdGhlIHJlc3RcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvcmRlcmVkTG9zZXJzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgY29uc3QgdGVhbTEgPSBvcmRlcmVkTG9zZXJzW2ldO1xuICAgICAgICAgIGNvbnN0IHRlYW0yID0gb3JkZXJlZExvc2Vyc1tpICsgMV0gPz8gbnVsbDtcbiAgICAgICAgICBuZXh0Um91bmRNYXRjaGVzLnB1c2goXG4gICAgICAgICAgICBjcmVhdGVNYXRjaChcbiAgICAgICAgICAgICAgYEwke25leHRSb3VuZE51bWJlcn0tJHtNYXRoLmZsb29yKGkgLyAyKSArIDJ9YCxcbiAgICAgICAgICAgICAgbmV4dFJvdW5kTnVtYmVyLFxuICAgICAgICAgICAgICB0ZWFtMSxcbiAgICAgICAgICAgICAgdGVhbTIsXG4gICAgICAgICAgICAgICF0ZWFtMixcbiAgICAgICAgICAgICAgXCJsb3NlcnNcIlxuICAgICAgICAgICAgKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEV2ZW4gbnVtYmVyOiBwYWlyIGFsbFxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9yZGVyZWRMb3NlcnMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICBjb25zdCB0ZWFtMSA9IG9yZGVyZWRMb3NlcnNbaV07XG4gICAgICAgICAgY29uc3QgdGVhbTIgPSBvcmRlcmVkTG9zZXJzW2kgKyAxXSA/PyBudWxsO1xuICAgICAgICAgIG5leHRSb3VuZE1hdGNoZXMucHVzaChcbiAgICAgICAgICAgIGNyZWF0ZU1hdGNoKFxuICAgICAgICAgICAgICBgTCR7bmV4dFJvdW5kTnVtYmVyfS0ke01hdGguZmxvb3IoaSAvIDIpICsgMX1gLFxuICAgICAgICAgICAgICBuZXh0Um91bmROdW1iZXIsXG4gICAgICAgICAgICAgIHRlYW0xLFxuICAgICAgICAgICAgICB0ZWFtMixcbiAgICAgICAgICAgICAgIXRlYW0yLFxuICAgICAgICAgICAgICBcImxvc2Vyc1wiXG4gICAgICAgICAgICApXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIC0tLSBXaW5uZXIgZGV0ZWN0aW9uIGxvZ2ljIC0tLVxuICBsZXQgd2lubmVyOiBUZWFtIHwgdW5kZWZpbmVkID0gdG91cm5hbWVudC53aW5uZXI7XG5cbiAgaWYgKGlzQ2hhbXBpb25zaGlwUm91bmQpIHtcbiAgICAvLyBGaW5kIHRoZSBsYXN0IGNoYW1waW9uc2hpcCBtYXRjaCBwbGF5ZWRcbiAgICBjb25zdCBsYXN0Q2hhbXBNYXRjaCA9XG4gICAgICBjaGFtcGlvbnNoaXBNYXRjaGVzWzBdIHx8XG4gICAgICBwcmV2Q2hhbXBpb25zaGlwTWF0Y2hlc1twcmV2Q2hhbXBpb25zaGlwTWF0Y2hlcy5sZW5ndGggLSAxXTtcblxuICAgIGlmIChcbiAgICAgIGxhc3RDaGFtcE1hdGNoICYmXG4gICAgICBsYXN0Q2hhbXBNYXRjaC5pc0NvbXBsZXRlZCAmJlxuICAgICAgbGFzdENoYW1wTWF0Y2gud2lubmVyICYmXG4gICAgICBsYXN0Q2hhbXBNYXRjaC5sb3NlclxuICAgICkge1xuICAgICAgY29uc3Qgd2lubmVyc0JyYWNrZXRUZWFtID0gbGFzdENoYW1wTWF0Y2gudGVhbTE7XG4gICAgICBjb25zdCBsb3NlcnNCcmFja2V0VGVhbSA9IGxhc3RDaGFtcE1hdGNoLnRlYW0yO1xuICAgICAgY29uc3QgbG9zZXJzQnJhY2tldFRlYW1Xb24gPVxuICAgICAgICBsb3NlcnNCcmFja2V0VGVhbSAmJiBsYXN0Q2hhbXBNYXRjaC53aW5uZXIuaWQgPT09IGxvc2Vyc0JyYWNrZXRUZWFtLmlkO1xuXG4gICAgICAvLyBJZiBsb3NlcidzIGJyYWNrZXQgdGVhbSB3b24gZmlyc3QgY2hhbXBpb25zaGlwIG1hdGNoLCB3aW5uZXIncyBicmFja2V0IHRlYW0gZ2V0cyBhbm90aGVyIGNoYW5jZVxuICAgICAgaWYgKGxvc2Vyc0JyYWNrZXRUZWFtV29uICYmIHRvdXJuYW1lbnQuY2hhbXBpb25zaGlwTWF0Y2hlc1BsYXllZCA9PT0gMSkge1xuICAgICAgICB3aW5uZXIgPSB1bmRlZmluZWQ7IC8vIE5vIHdpbm5lciB5ZXQsIG5lZWQgcmVzZXQgbWF0Y2hcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEVpdGhlciB3aW5uZXIncyBicmFja2V0IHRlYW0gd29uIGZpcnN0IG1hdGNoLCBvciB0aGlzIHdhcyB0aGUgcmVzZXQgbWF0Y2hcbiAgICAgICAgd2lubmVyID0gbGFzdENoYW1wTWF0Y2gud2lubmVyO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIC0tLSBJTkZJTklURSBSRUNVUlNJT04gR1VBUkQgLS0tXG4gIGNvbnN0IG5vTW9yZU1hdGNoZXMgPVxuICAgIChpc0NoYW1waW9uc2hpcFJvdW5kICYmIGNoYW1waW9uc2hpcE1hdGNoZXMubGVuZ3RoID09PSAwKSB8fFxuICAgICghaXNDaGFtcGlvbnNoaXBSb3VuZCAmJiBuZXh0Um91bmRNYXRjaGVzLmxlbmd0aCA9PT0gMCk7XG5cbiAgaWYgKG5vTW9yZU1hdGNoZXMpIHtcbiAgICAvLyBUb3VybmFtZW50IGlzIG92ZXIsIGRvIG5vdCBhZHZhbmNlIGZ1cnRoZXJcbiAgICByZXR1cm4ge1xuICAgICAgLi4udG91cm5hbWVudCxcbiAgICAgIHdpbm5lcixcbiAgICAgIGN1cnJlbnRSb3VuZDogdG91cm5hbWVudC5jdXJyZW50Um91bmRcbiAgICB9O1xuICB9XG5cbiAgLy8gRGVidWcgbG9nIGJlZm9yZSByZXR1cm5pbmcgdGhlIG5ldyB0b3VybmFtZW50IG9iamVjdFxuICBsb2dUb3VybmFtZW50U3RhdGUoe1xuICAgIHJvdW5kTnVtYmVyOiBuZXh0Um91bmROdW1iZXIsXG4gICAgd2lubmVyc0JyYWNrZXRUZWFtcyxcbiAgICBsb3NlcnNCcmFja2V0VGVhbXMsXG4gICAgbWF0Y2hlczogaXNDaGFtcGlvbnNoaXBSb3VuZCA/IGNoYW1waW9uc2hpcE1hdGNoZXMgOiBuZXh0Um91bmRNYXRjaGVzLFxuICAgIHdpbm5lcnNCcmFja2V0RmluYWxMb3NlcjogdG91cm5hbWVudC53aW5uZXJzQnJhY2tldEZpbmFsTG9zZXJcbiAgfSk7XG5cbiAgLy8gQ29tcG9zZSB0aGUgbmV3IHRvdXJuYW1lbnQgb2JqZWN0XG4gIHJldHVybiB7XG4gICAgLi4udG91cm5hbWVudCxcbiAgICByb3VuZHM6IFtcbiAgICAgIC4uLnRvdXJuYW1lbnQucm91bmRzLFxuICAgICAge1xuICAgICAgICByb3VuZE51bWJlcjogbmV4dFJvdW5kTnVtYmVyLFxuICAgICAgICBtYXRjaGVzOiBpc0NoYW1waW9uc2hpcFJvdW5kID8gY2hhbXBpb25zaGlwTWF0Y2hlcyA6IG5leHRSb3VuZE1hdGNoZXMsXG4gICAgICAgIGlzRG91YmxlRWxpbWluYXRpb246IHRydWUsXG4gICAgICAgIGlzQ2hhbXBpb25zaGlwUm91bmRcbiAgICAgIH1cbiAgICBdLFxuICAgIGN1cnJlbnRSb3VuZDogbmV4dFJvdW5kTnVtYmVyLFxuICAgIGVsaW1pbmF0ZWRUZWFtczogW1xuICAgICAgLi4udG91cm5hbWVudC5lbGltaW5hdGVkVGVhbXMsXG4gICAgICAuLi5uZXdseUVsaW1pbmF0ZWQuZmlsdGVyKFxuICAgICAgICAodCkgPT4gIXRvdXJuYW1lbnQuZWxpbWluYXRlZFRlYW1zLnNvbWUoKGV0KSA9PiBldC5pZCA9PT0gdC5pZClcbiAgICAgIClcbiAgICBdLFxuICAgIGNoYW1waW9uc2hpcE1hdGNoZXNQbGF5ZWQ6IGlzQ2hhbXBpb25zaGlwUm91bmRcbiAgICAgID8gdG91cm5hbWVudC5jaGFtcGlvbnNoaXBNYXRjaGVzUGxheWVkICsgMVxuICAgICAgOiB0b3VybmFtZW50LmNoYW1waW9uc2hpcE1hdGNoZXNQbGF5ZWQsXG4gICAgd2lubmVyc0JyYWNrZXRGaW5hbExvc2VyOiB0b3VybmFtZW50Lndpbm5lcnNCcmFja2V0RmluYWxMb3NlcixcbiAgICB3aW5uZXJcbiAgfTtcbn07XG4vLyBleHBvcnQgY29uc3QgYWR2YW5jZVRvTmV4dFJvdW5kID0gKHRvdXJuYW1lbnQ6IFRvdXJuYW1lbnQpOiBUb3VybmFtZW50ID0+IHtcbi8vICAgY29uc3QgY3VycmVudFJvdW5kID0gdG91cm5hbWVudC5yb3VuZHNbdG91cm5hbWVudC5yb3VuZHMubGVuZ3RoIC0gMV07XG4vLyAgIGNvbnN0IG5leHRSb3VuZE51bWJlciA9IHRvdXJuYW1lbnQuY3VycmVudFJvdW5kICsgMTtcblxuLy8gICAvLyBUcmFjayBhbGwgbG9zc2VzIGFjcm9zcyB0aGUgdG91cm5hbWVudFxuLy8gICBjb25zdCBsb3NzQ291bnRzOiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+ID0ge307XG4vLyAgIHRvdXJuYW1lbnQucm91bmRzLmZvckVhY2goKHJvdW5kKSA9PiB7XG4vLyAgICAgcm91bmQubWF0Y2hlcy5mb3JFYWNoKChtYXRjaCkgPT4ge1xuLy8gICAgICAgaWYgKG1hdGNoLmlzQ29tcGxldGVkICYmIG1hdGNoLmxvc2VyKSB7XG4vLyAgICAgICAgIGxvc3NDb3VudHNbbWF0Y2gubG9zZXIuaWRdID0gKGxvc3NDb3VudHNbbWF0Y2gubG9zZXIuaWRdIHx8IDApICsgMTtcbi8vICAgICAgIH1cbi8vICAgICB9KTtcbi8vICAgfSk7XG5cbi8vICAgLy8gR2F0aGVyIGFsbCB0ZWFtcyBldmVyIGluIHRoZSB0b3VybmFtZW50XG4vLyAgIGNvbnN0IGFsbFRlYW1zOiBUZWFtW10gPSBbXTtcbi8vICAgY29uc3QgdGVhbUlkcyA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuLy8gICBmb3IgKGNvbnN0IHJvdW5kIG9mIHRvdXJuYW1lbnQucm91bmRzKSB7XG4vLyAgICAgZm9yIChjb25zdCBtYXRjaCBvZiByb3VuZC5tYXRjaGVzKSB7XG4vLyAgICAgICBpZiAobWF0Y2gudGVhbTEgJiYgIXRlYW1JZHMuaGFzKG1hdGNoLnRlYW0xLmlkKSkge1xuLy8gICAgICAgICBhbGxUZWFtcy5wdXNoKG1hdGNoLnRlYW0xKTtcbi8vICAgICAgICAgdGVhbUlkcy5hZGQobWF0Y2gudGVhbTEuaWQpO1xuLy8gICAgICAgfVxuLy8gICAgICAgaWYgKG1hdGNoLnRlYW0yICYmICF0ZWFtSWRzLmhhcyhtYXRjaC50ZWFtMi5pZCkpIHtcbi8vICAgICAgICAgYWxsVGVhbXMucHVzaChtYXRjaC50ZWFtMik7XG4vLyAgICAgICAgIHRlYW1JZHMuYWRkKG1hdGNoLnRlYW0yLmlkKTtcbi8vICAgICAgIH1cbi8vICAgICB9XG4vLyAgIH1cblxuLy8gICAvLyBJZGVudGlmeSBuZXdseSBlbGltaW5hdGVkIHRlYW1zICgyIGxvc3Nlcylcbi8vICAgY29uc3QgbmV3bHlFbGltaW5hdGVkOiBUZWFtW10gPSBbXTtcbi8vICAgZm9yIChjb25zdCB0ZWFtIG9mIGFsbFRlYW1zKSB7XG4vLyAgICAgaWYgKFxuLy8gICAgICAgKGxvc3NDb3VudHNbdGVhbS5pZF0gfHwgMCkgPj0gMiAmJlxuLy8gICAgICAgIXRvdXJuYW1lbnQuZWxpbWluYXRlZFRlYW1zLnNvbWUoKHQpID0+IHQuaWQgPT09IHRlYW0uaWQpXG4vLyAgICAgKSB7XG4vLyAgICAgICBuZXdseUVsaW1pbmF0ZWQucHVzaCh0ZWFtKTtcbi8vICAgICB9XG4vLyAgIH1cblxuLy8gICAvLyBXaW5uZXJzOiB0ZWFtcyB3aXRoIDAgbG9zc2VzIGFuZCBub3QgZWxpbWluYXRlZFxuLy8gICBjb25zdCB3aW5uZXJzQnJhY2tldFRlYW1zID0gYWxsVGVhbXMuZmlsdGVyKFxuLy8gICAgICh0ZWFtKSA9PlxuLy8gICAgICAgKGxvc3NDb3VudHNbdGVhbS5pZF0gfHwgMCkgPT09IDAgJiZcbi8vICAgICAgICF0b3VybmFtZW50LmVsaW1pbmF0ZWRUZWFtcy5zb21lKCh0KSA9PiB0LmlkID09PSB0ZWFtLmlkKSAmJlxuLy8gICAgICAgIW5ld2x5RWxpbWluYXRlZC5zb21lKCh0KSA9PiB0LmlkID09PSB0ZWFtLmlkKVxuLy8gICApO1xuXG4vLyAgIC8vIExvc2VyczogdGVhbXMgd2l0aCAxIGxvc3MgYW5kIG5vdCBlbGltaW5hdGVkXG4vLyAgIGNvbnN0IGxvc2Vyc0JyYWNrZXRUZWFtcyA9IGFsbFRlYW1zLmZpbHRlcihcbi8vICAgICAodGVhbSkgPT5cbi8vICAgICAgIChsb3NzQ291bnRzW3RlYW0uaWRdIHx8IDApID09PSAxICYmXG4vLyAgICAgICAhdG91cm5hbWVudC5lbGltaW5hdGVkVGVhbXMuc29tZSgodCkgPT4gdC5pZCA9PT0gdGVhbS5pZCkgJiZcbi8vICAgICAgICFuZXdseUVsaW1pbmF0ZWQuc29tZSgodCkgPT4gdC5pZCA9PT0gdGVhbS5pZClcbi8vICAgKTtcblxuLy8gICBsZXQgaXNDaGFtcGlvbnNoaXBSb3VuZCA9IGZhbHNlO1xuLy8gICBsZXQgY2hhbXBpb25zaGlwTWF0Y2hlczogTWF0Y2hbXSA9IFtdO1xuLy8gICBsZXQgbmV4dFJvdW5kTWF0Y2hlczogTWF0Y2hbXSA9IFtdO1xuXG4vLyAgIGNvbnN0IHByZXZDaGFtcGlvbnNoaXBNYXRjaGVzID0gdG91cm5hbWVudC5yb3VuZHNcbi8vICAgICAuZmlsdGVyKChyKSA9PiByLmlzQ2hhbXBpb25zaGlwUm91bmQpXG4vLyAgICAgLmZsYXRNYXAoKHIpID0+IHIubWF0Y2hlcylcbi8vICAgICAuZmlsdGVyKChtKSA9PiBtLmJyYWNrZXQgPT09IFwiY2hhbXBpb25zaGlwXCIpO1xuXG4vLyAgIC8vIC0tLSBDSEFNUElPTlNISVAgTE9HSUMgLS0tXG5cbi8vICAgLy8gQ2hlY2sgaWYgYSBjaGFtcGlvbnNoaXAgbWF0Y2ggYWxyZWFkeSBoYXBwZW5lZCBhbmQgd2FzIGNvbXBsZXRlZFxuLy8gICBpZiAoXG4vLyAgICAgcHJldkNoYW1waW9uc2hpcE1hdGNoZXMubGVuZ3RoID49IDEgJiZcbi8vICAgICBwcmV2Q2hhbXBpb25zaGlwTWF0Y2hlc1twcmV2Q2hhbXBpb25zaGlwTWF0Y2hlcy5sZW5ndGggLSAxXS5pc0NvbXBsZXRlZFxuLy8gICApIHtcbi8vICAgICBjb25zdCBsYXN0Q2hhbXBNYXRjaCA9XG4vLyAgICAgICBwcmV2Q2hhbXBpb25zaGlwTWF0Y2hlc1twcmV2Q2hhbXBpb25zaGlwTWF0Y2hlcy5sZW5ndGggLSAxXTtcbi8vICAgICBjb25zdCB3aW5uZXJzQnJhY2tldFRlYW0gPSBsYXN0Q2hhbXBNYXRjaC50ZWFtMTtcbi8vICAgICBjb25zdCBsb3NlcnNCcmFja2V0VGVhbSA9IGxhc3RDaGFtcE1hdGNoLnRlYW0yO1xuXG4vLyAgICAgLy8gSWYgbG9zZXIncyBicmFja2V0IHRlYW0gd29uIHRoZSBmaXJzdCBjaGFtcGlvbnNoaXAgbWF0Y2gsIHdpbm5lcidzIGJyYWNrZXQgdGVhbSBnZXRzIGFub3RoZXIgY2hhbmNlXG4vLyAgICAgaWYgKFxuLy8gICAgICAgbGFzdENoYW1wTWF0Y2gud2lubmVyPy5pZCA9PT0gbG9zZXJzQnJhY2tldFRlYW0/LmlkICYmXG4vLyAgICAgICB0b3VybmFtZW50LmNoYW1waW9uc2hpcE1hdGNoZXNQbGF5ZWQgPT09IDFcbi8vICAgICApIHtcbi8vICAgICAgIGlzQ2hhbXBpb25zaGlwUm91bmQgPSB0cnVlO1xuLy8gICAgICAgLy8gQ3JlYXRlIHRoZSBcInJlc2V0XCIgbWF0Y2hcbi8vICAgICAgIGNoYW1waW9uc2hpcE1hdGNoZXMucHVzaChcbi8vICAgICAgICAgY3JlYXRlTWF0Y2goXG4vLyAgICAgICAgICAgYEMke25leHRSb3VuZE51bWJlcn0tMWAsXG4vLyAgICAgICAgICAgbmV4dFJvdW5kTnVtYmVyLFxuLy8gICAgICAgICAgIHdpbm5lcnNCcmFja2V0VGVhbSxcbi8vICAgICAgICAgICBsb3NlcnNCcmFja2V0VGVhbSxcbi8vICAgICAgICAgICBmYWxzZSxcbi8vICAgICAgICAgICBcImNoYW1waW9uc2hpcFwiXG4vLyAgICAgICAgIClcbi8vICAgICAgICk7XG4vLyAgICAgfSBlbHNlIHtcbi8vICAgICAgIC8vIEVpdGhlciB3aW5uZXIncyBicmFja2V0IHRlYW0gd29uIGZpcnN0IG1hdGNoLCBvciB0aGlzIHdhcyB0aGUgcmVzZXQgbWF0Y2hcbi8vICAgICAgIGlzQ2hhbXBpb25zaGlwUm91bmQgPSB0cnVlO1xuLy8gICAgICAgLy8gTm8gbmV3IG1hdGNoZXMsIHdpbm5lciB3aWxsIGJlIGRldGVybWluZWQgaW4gd2lubmVyIGRldGVjdGlvbiBsb2dpY1xuLy8gICAgIH1cbi8vICAgfVxuLy8gICAvLyBDaGVjayBpZiB3ZSdyZSByZWFkeSBmb3IgdGhlIGNoYW1waW9uc2hpcCBtYXRjaCAtIG9uZSB0ZWFtIGluIGVhY2ggYnJhY2tldCBhbmQgbG9zZXIncyBmaW5hbCBpcyBjb21wbGV0ZVxuLy8gICBlbHNlIGlmIChcbi8vICAgICB3aW5uZXJzQnJhY2tldFRlYW1zLmxlbmd0aCA9PT0gMSAmJlxuLy8gICAgIGxvc2Vyc0JyYWNrZXRUZWFtcy5sZW5ndGggPT09IDEgJiZcbi8vICAgICBjdXJyZW50Um91bmQubWF0Y2hlcy5zb21lKFxuLy8gICAgICAgKG0pID0+XG4vLyAgICAgICAgIChtLmJyYWNrZXQgPT09IFwibG9zZXJzXCIgfHwgbS5pZC5pbmNsdWRlcyhcIkxvc2Vyc0xhc3RcIikpICYmXG4vLyAgICAgICAgIG0uaXNDb21wbGV0ZWQgJiZcbi8vICAgICAgICAgbS53aW5uZXIgJiZcbi8vICAgICAgICAgbG9zZXJzQnJhY2tldFRlYW1zLnNvbWUoKHQpID0+IHQuaWQgPT09IG0ud2lubmVyIS5pZClcbi8vICAgICApXG4vLyAgICkge1xuLy8gICAgIC8vIENoYW1waW9uc2hpcCBtYXRjaDogV2lubmVyJ3MgYnJhY2tldCBjaGFtcGlvbiB2cyBMb3NlcidzIGJyYWNrZXQgY2hhbXBpb25cbi8vICAgICBpc0NoYW1waW9uc2hpcFJvdW5kID0gdHJ1ZTtcbi8vICAgICBjaGFtcGlvbnNoaXBNYXRjaGVzLnB1c2goXG4vLyAgICAgICBjcmVhdGVNYXRjaChcbi8vICAgICAgICAgYEMke25leHRSb3VuZE51bWJlcn0tMWAsXG4vLyAgICAgICAgIG5leHRSb3VuZE51bWJlcixcbi8vICAgICAgICAgd2lubmVyc0JyYWNrZXRUZWFtc1swXSwgLy8gV2lubmVyJ3MgYnJhY2tldCBjaGFtcGlvblxuLy8gICAgICAgICBsb3NlcnNCcmFja2V0VGVhbXNbMF0sIC8vIExvc2VyJ3MgYnJhY2tldCBjaGFtcGlvblxuLy8gICAgICAgICBmYWxzZSxcbi8vICAgICAgICAgXCJjaGFtcGlvbnNoaXBcIlxuLy8gICAgICAgKVxuLy8gICAgICk7XG4vLyAgIH1cbi8vICAgLy8gQ2hlY2sgaWYgd2UgaGF2ZSBhIGxvc2VyIGZyb20gd2lubmVyJ3MgYnJhY2tldCBmaW5hbCB3YWl0aW5nIHRvIHBsYXkgYWdhaW5zdCBsb3NlcidzIGJyYWNrZXQgd2lubmVyXG4vLyAgIGVsc2UgaWYgKFxuLy8gICAgIHdpbm5lcnNCcmFja2V0VGVhbXMubGVuZ3RoID09PSAxICYmIC8vIFdlIGhhdmUgYSB3aW5uZXIncyBicmFja2V0IGNoYW1waW9uXG4vLyAgICAgbG9zZXJzQnJhY2tldFRlYW1zLmxlbmd0aCA+PSAxICYmIC8vIFdlIGhhdmUgYXQgbGVhc3Qgb25lIHRlYW0gaW4gbG9zZXIncyBicmFja2V0XG4vLyAgICAgdG91cm5hbWVudC53aW5uZXJzQnJhY2tldEZpbmFsTG9zZXIgLy8gV2UgaGF2ZSBzdG9yZWQgdGhlIHdpbm5lcidzIGJyYWNrZXQgZmluYWwgbG9zZXJcbi8vICAgKSB7XG4vLyAgICAgLy8gRmluZCB0aGUgd2lubmVyIG9mIHRoZSBsb3NlcidzIGJyYWNrZXRcbi8vICAgICBjb25zdCBsb3NlcnNCcmFja2V0V2lubmVyID0gY3VycmVudFJvdW5kLm1hdGNoZXNcbi8vICAgICAgIC5maWx0ZXIoKG0pID0+IG0uYnJhY2tldCA9PT0gXCJsb3NlcnNcIiAmJiBtLmlzQ29tcGxldGVkICYmIG0ud2lubmVyKVxuLy8gICAgICAgLm1hcCgobSkgPT4gbS53aW5uZXIhKVxuLy8gICAgICAgLmZpbmQoKHdpbm5lcikgPT4gbG9zZXJzQnJhY2tldFRlYW1zLnNvbWUoKHQpID0+IHQuaWQgPT09IHdpbm5lci5pZCkpO1xuXG4vLyAgICAgaWYgKFxuLy8gICAgICAgbG9zZXJzQnJhY2tldFdpbm5lciAmJlxuLy8gICAgICAgbG9zZXJzQnJhY2tldFdpbm5lci5pZCAhPT0gdG91cm5hbWVudC53aW5uZXJzQnJhY2tldEZpbmFsTG9zZXIuaWRcbi8vICAgICApIHtcbi8vICAgICAgIC8vIE9ubHkgc2NoZWR1bGUgaWYgdGhleSdyZSBub3QgdGhlIHNhbWUgdGVhbSFcbi8vICAgICAgIG5leHRSb3VuZE1hdGNoZXMucHVzaChcbi8vICAgICAgICAgY3JlYXRlTWF0Y2goXG4vLyAgICAgICAgICAgYExvc2Vyc0xhc3QtJHtuZXh0Um91bmROdW1iZXJ9YCxcbi8vICAgICAgICAgICBuZXh0Um91bmROdW1iZXIsXG4vLyAgICAgICAgICAgdG91cm5hbWVudC53aW5uZXJzQnJhY2tldEZpbmFsTG9zZXIsXG4vLyAgICAgICAgICAgbG9zZXJzQnJhY2tldFdpbm5lcixcbi8vICAgICAgICAgICBmYWxzZSxcbi8vICAgICAgICAgICBcImxvc2Vyc1wiXG4vLyAgICAgICAgIClcbi8vICAgICAgICk7XG4vLyAgICAgfSBlbHNlIHtcbi8vICAgICAgIC8vIFdhaXQgZm9yIHRoZSBsb3NlcnMgYnJhY2tldCB0byByZXNvbHZlIHByb3Blcmx5XG4vLyAgICAgICBjcmVhdGVTdGFuZGFyZEJyYWNrZXRNYXRjaGVzKCk7XG4vLyAgICAgfVxuLy8gICB9XG4vLyAgIC8vIENoZWNrIGlmIHRoaXMgaXMgdGhlIHdpbm5lcidzIGJyYWNrZXQgZmluYWwgKGV4YWN0bHkgMiB0ZWFtcyBpbiB3aW5uZXIncyBicmFja2V0KVxuLy8gICBlbHNlIGlmICh3aW5uZXJzQnJhY2tldFRlYW1zLmxlbmd0aCA9PT0gMiAmJiBsb3NlcnNCcmFja2V0VGVhbXMubGVuZ3RoID49IDEpIHtcbi8vICAgICAvLyBDcmVhdGUgdGhlIHdpbm5lcidzIGJyYWNrZXQgZmluYWwgbWF0Y2hcbi8vICAgICBuZXh0Um91bmRNYXRjaGVzLnB1c2goXG4vLyAgICAgICBjcmVhdGVNYXRjaChcbi8vICAgICAgICAgYFcke25leHRSb3VuZE51bWJlcn0tMWAsXG4vLyAgICAgICAgIG5leHRSb3VuZE51bWJlcixcbi8vICAgICAgICAgd2lubmVyc0JyYWNrZXRUZWFtc1swXSxcbi8vICAgICAgICAgd2lubmVyc0JyYWNrZXRUZWFtc1sxXSxcbi8vICAgICAgICAgZmFsc2UsXG4vLyAgICAgICAgIFwid2lubmVyc1wiXG4vLyAgICAgICApXG4vLyAgICAgKTtcblxuLy8gICAgIC8vIENvbnRpbnVlIHdpdGggbG9zZXJzIGJyYWNrZXQgbWF0Y2hlcyBzZXBhcmF0ZWx5XG4vLyAgICAgY3JlYXRlTG9zZXJzQnJhY2tldE1hdGNoZXMoKTtcbi8vICAgfVxuLy8gICAvLyBPdGhlcndpc2UsIGNvbnRpbnVlIHdpdGggbm9ybWFsIGJyYWNrZXQgcGxheVxuLy8gICBlbHNlIHtcbi8vICAgICBjcmVhdGVTdGFuZGFyZEJyYWNrZXRNYXRjaGVzKCk7XG4vLyAgIH1cblxuLy8gICAvLyBIZWxwZXIgZnVuY3Rpb24gdG8gY3JlYXRlIHN0YW5kYXJkIGJyYWNrZXQgbWF0Y2hlc1xuLy8gICBmdW5jdGlvbiBjcmVhdGVTdGFuZGFyZEJyYWNrZXRNYXRjaGVzKCkge1xuLy8gICAgIC8vIC0tLSBXaW5uZXJzIEJyYWNrZXQgTWF0Y2hlcyAtLS1cbi8vICAgICBsZXQgbWF0Y2hDb3VudGVyID0gMTtcbi8vICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHdpbm5lcnNCcmFja2V0VGVhbXMubGVuZ3RoOyBpICs9IDIpIHtcbi8vICAgICAgIGNvbnN0IHRlYW0xID0gd2lubmVyc0JyYWNrZXRUZWFtc1tpXTtcbi8vICAgICAgIGNvbnN0IHRlYW0yID0gd2lubmVyc0JyYWNrZXRUZWFtc1tpICsgMV0gPz8gbnVsbDtcbi8vICAgICAgIGNvbnN0IGlzQnllID0gIXRlYW0yO1xuLy8gICAgICAgbmV4dFJvdW5kTWF0Y2hlcy5wdXNoKFxuLy8gICAgICAgICBjcmVhdGVNYXRjaChcbi8vICAgICAgICAgICBgVyR7bmV4dFJvdW5kTnVtYmVyfS0ke21hdGNoQ291bnRlcn1gLFxuLy8gICAgICAgICAgIG5leHRSb3VuZE51bWJlcixcbi8vICAgICAgICAgICB0ZWFtMSxcbi8vICAgICAgICAgICB0ZWFtMixcbi8vICAgICAgICAgICBpc0J5ZSxcbi8vICAgICAgICAgICBcIndpbm5lcnNcIlxuLy8gICAgICAgICApXG4vLyAgICAgICApO1xuLy8gICAgICAgbWF0Y2hDb3VudGVyKys7XG4vLyAgICAgfVxuXG4vLyAgICAgLy8gQ3JlYXRlIGxvc2VycyBicmFja2V0IG1hdGNoZXMgc2VwYXJhdGVseVxuLy8gICAgIGNyZWF0ZUxvc2Vyc0JyYWNrZXRNYXRjaGVzKCk7XG4vLyAgIH1cblxuLy8gICAvLyBIZWxwZXIgZnVuY3Rpb24gdG8gY3JlYXRlIGxvc2VycyBicmFja2V0IG1hdGNoZXNcbi8vICAgZnVuY3Rpb24gY3JlYXRlTG9zZXJzQnJhY2tldE1hdGNoZXMoKSB7XG4vLyAgICAgLy8gLS0tIExvc2VycyBCcmFja2V0IE1hdGNoZXMgLS0tXG4vLyAgICAgY29uc3QgZWxpZ2libGVMb3NlcnMgPSBhbGxUZWFtcy5maWx0ZXIoXG4vLyAgICAgICAodGVhbSkgPT5cbi8vICAgICAgICAgKGxvc3NDb3VudHNbdGVhbS5pZF0gfHwgMCkgPT09IDEgJiZcbi8vICAgICAgICAgIXRvdXJuYW1lbnQuZWxpbWluYXRlZFRlYW1zLnNvbWUoKHQpID0+IHQuaWQgPT09IHRlYW0uaWQpICYmXG4vLyAgICAgICAgICFuZXdseUVsaW1pbmF0ZWQuc29tZSgodCkgPT4gdC5pZCA9PT0gdGVhbS5pZCkgJiZcbi8vICAgICAgICAgLy8gRXhjbHVkZSB3aW5uZXIncyBicmFja2V0IGZpbmFsIGxvc2VyIGlmIGl0IGV4aXN0cyBidXQgaGFzbid0IHBsYXllZCB5ZXQgaW4gbG9zZXJzXG4vLyAgICAgICAgICEoXG4vLyAgICAgICAgICAgdG91cm5hbWVudC53aW5uZXJzQnJhY2tldEZpbmFsTG9zZXIgJiZcbi8vICAgICAgICAgICB0b3VybmFtZW50Lndpbm5lcnNCcmFja2V0RmluYWxMb3Nlci5pZCA9PT0gdGVhbS5pZFxuLy8gICAgICAgICApXG4vLyAgICAgKTtcblxuLy8gICAgIC8vIEZpbmQgdGVhbXMgcmVjZW50bHkgZHJvcHBlZCBmcm9tIHdpbm5lcnMgYnJhY2tldFxuLy8gICAgIGNvbnN0IGp1c3REcm9wcGVkRnJvbVdpbm5lcnMgPSBjdXJyZW50Um91bmQubWF0Y2hlc1xuLy8gICAgICAgLmZpbHRlcigobSkgPT4gbS5icmFja2V0ID09PSBcIndpbm5lcnNcIiAmJiBtLmxvc2VyICYmIG0uaXNDb21wbGV0ZWQpXG4vLyAgICAgICAubWFwKChtKSA9PiBtLmxvc2VyISlcbi8vICAgICAgIC5maWx0ZXIoKGxvc2VyKSA9PiBlbGlnaWJsZUxvc2Vycy5zb21lKCh0KSA9PiB0LmlkID09PSBsb3Nlci5pZCkpO1xuXG4vLyAgICAgLy8gSWYgdGhpcyBpcyB0aGUgd2lubmVyJ3MgYnJhY2tldCBmaW5hbCwgc3RvcmUgdGhlIGxvc2VyIGZvciBsYXRlciB1c2Vcbi8vICAgICBpZiAoXG4vLyAgICAgICBjdXJyZW50Um91bmQubWF0Y2hlcy5zb21lKFxuLy8gICAgICAgICAobSkgPT5cbi8vICAgICAgICAgICBtLmJyYWNrZXQgPT09IFwid2lubmVyc1wiICYmXG4vLyAgICAgICAgICAgd2lubmVyc0JyYWNrZXRUZWFtcy5sZW5ndGggPT09IDEgJiZcbi8vICAgICAgICAgICBtLmxvc2VyICYmXG4vLyAgICAgICAgICAgbS5pc0NvbXBsZXRlZFxuLy8gICAgICAgKVxuLy8gICAgICkge1xuLy8gICAgICAgLy8gVGhpcyBpcyBhIHNwZWNpYWwgY2FzZSAtIHdlIGZvdW5kIHRoZSB3aW5uZXIncyBicmFja2V0IGZpbmFsIGxvc2VyXG4vLyAgICAgICBjb25zdCB3aW5uZXJzRmluYWxMb3NlciA9IGN1cnJlbnRSb3VuZC5tYXRjaGVzXG4vLyAgICAgICAgIC5maWx0ZXIoKG0pID0+IG0uYnJhY2tldCA9PT0gXCJ3aW5uZXJzXCIgJiYgbS5pc0NvbXBsZXRlZCAmJiBtLmxvc2VyKVxuLy8gICAgICAgICAubWFwKChtKSA9PiBtLmxvc2VyISlcbi8vICAgICAgICAgLnBvcCgpO1xuXG4vLyAgICAgICBpZiAod2lubmVyc0ZpbmFsTG9zZXIpIHtcbi8vICAgICAgICAgdG91cm5hbWVudC53aW5uZXJzQnJhY2tldEZpbmFsTG9zZXIgPSB3aW5uZXJzRmluYWxMb3Nlcjtcbi8vICAgICAgIH1cbi8vICAgICB9XG5cbi8vICAgICAvLyBFeGlzdGluZyBsb3NlcnMgYnJhY2tldCB0ZWFtc1xuLy8gICAgIGNvbnN0IGV4aXN0aW5nTG9zZXJzID0gZWxpZ2libGVMb3NlcnMuZmlsdGVyKFxuLy8gICAgICAgKHQpID0+ICFqdXN0RHJvcHBlZEZyb21XaW5uZXJzLnNvbWUoKGpkKSA9PiBqZC5pZCA9PT0gdC5pZClcbi8vICAgICApO1xuXG4vLyAgICAgLy8gT3JkZXI6IG1vc3QgcmVjZW50IGRyb3AocykgZmlyc3Rcbi8vICAgICBjb25zdCBvcmRlcmVkTG9zZXJzID0gWy4uLmp1c3REcm9wcGVkRnJvbVdpbm5lcnMsIC4uLmV4aXN0aW5nTG9zZXJzXTtcblxuLy8gICAgIGlmIChvcmRlcmVkTG9zZXJzLmxlbmd0aCA+IDApIHtcbi8vICAgICAgIGlmIChvcmRlcmVkTG9zZXJzLmxlbmd0aCAlIDIgPT09IDEpIHtcbi8vICAgICAgICAgLy8gT2RkOiBieWUgZ29lcyB0byB0aGUgbW9zdCByZWNlbnQgdGVhbSBkcm9wcGVkIGZyb20gd2lubmVycyBicmFja2V0XG4vLyAgICAgICAgIGxldCB0ZWFtV2l0aEJ5ZTogVGVhbSB8IG51bGwgPSBudWxsO1xuLy8gICAgICAgICBpZiAoanVzdERyb3BwZWRGcm9tV2lubmVycy5sZW5ndGggPiAwKSB7XG4vLyAgICAgICAgICAgdGVhbVdpdGhCeWUgPVxuLy8gICAgICAgICAgICAganVzdERyb3BwZWRGcm9tV2lubmVyc1tqdXN0RHJvcHBlZEZyb21XaW5uZXJzLmxlbmd0aCAtIDFdO1xuLy8gICAgICAgICAgIC8vIFJlbW92ZSB0aGUgYnllIHRlYW0gZnJvbSBvcmRlcmVkTG9zZXJzXG4vLyAgICAgICAgICAgY29uc3QgYnllSW5kZXggPSBvcmRlcmVkTG9zZXJzLmZpbmRJbmRleChcbi8vICAgICAgICAgICAgICh0KSA9PiB0LmlkID09PSB0ZWFtV2l0aEJ5ZSEuaWRcbi8vICAgICAgICAgICApO1xuLy8gICAgICAgICAgIGlmIChieWVJbmRleCAhPT0gLTEpIG9yZGVyZWRMb3NlcnMuc3BsaWNlKGJ5ZUluZGV4LCAxKTtcbi8vICAgICAgICAgfSBlbHNlIHtcbi8vICAgICAgICAgICAvLyBEZWZlbnNpdmU6IGZhbGxiYWNrIHRvIGZpcnN0IHRlYW0gaWYgbm8gcmVjZW50IGRyb3Bcbi8vICAgICAgICAgICB0ZWFtV2l0aEJ5ZSA9IG9yZGVyZWRMb3NlcnMuc2hpZnQoKSE7XG4vLyAgICAgICAgIH1cbi8vICAgICAgICAgbmV4dFJvdW5kTWF0Y2hlcy5wdXNoKFxuLy8gICAgICAgICAgIGNyZWF0ZU1hdGNoKFxuLy8gICAgICAgICAgICAgYEwke25leHRSb3VuZE51bWJlcn0tMWAsXG4vLyAgICAgICAgICAgICBuZXh0Um91bmROdW1iZXIsXG4vLyAgICAgICAgICAgICB0ZWFtV2l0aEJ5ZSxcbi8vICAgICAgICAgICAgIG51bGwsXG4vLyAgICAgICAgICAgICB0cnVlLFxuLy8gICAgICAgICAgICAgXCJsb3NlcnNcIlxuLy8gICAgICAgICAgIClcbi8vICAgICAgICAgKTtcbi8vICAgICAgICAgLy8gUGFpciB0aGUgcmVzdFxuLy8gICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9yZGVyZWRMb3NlcnMubGVuZ3RoOyBpICs9IDIpIHtcbi8vICAgICAgICAgICBjb25zdCB0ZWFtMSA9IG9yZGVyZWRMb3NlcnNbaV07XG4vLyAgICAgICAgICAgY29uc3QgdGVhbTIgPSBvcmRlcmVkTG9zZXJzW2kgKyAxXSA/PyBudWxsO1xuLy8gICAgICAgICAgIG5leHRSb3VuZE1hdGNoZXMucHVzaChcbi8vICAgICAgICAgICAgIGNyZWF0ZU1hdGNoKFxuLy8gICAgICAgICAgICAgICBgTCR7bmV4dFJvdW5kTnVtYmVyfS0ke01hdGguZmxvb3IoaSAvIDIpICsgMn1gLFxuLy8gICAgICAgICAgICAgICBuZXh0Um91bmROdW1iZXIsXG4vLyAgICAgICAgICAgICAgIHRlYW0xLFxuLy8gICAgICAgICAgICAgICB0ZWFtMixcbi8vICAgICAgICAgICAgICAgIXRlYW0yLFxuLy8gICAgICAgICAgICAgICBcImxvc2Vyc1wiXG4vLyAgICAgICAgICAgICApXG4vLyAgICAgICAgICAgKTtcbi8vICAgICAgICAgfVxuLy8gICAgICAgfSBlbHNlIHtcbi8vICAgICAgICAgLy8gRXZlbiBudW1iZXI6IHBhaXIgYWxsXG4vLyAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3JkZXJlZExvc2Vycy5sZW5ndGg7IGkgKz0gMikge1xuLy8gICAgICAgICAgIGNvbnN0IHRlYW0xID0gb3JkZXJlZExvc2Vyc1tpXTtcbi8vICAgICAgICAgICBjb25zdCB0ZWFtMiA9IG9yZGVyZWRMb3NlcnNbaSArIDFdID8/IG51bGw7XG4vLyAgICAgICAgICAgbmV4dFJvdW5kTWF0Y2hlcy5wdXNoKFxuLy8gICAgICAgICAgICAgY3JlYXRlTWF0Y2goXG4vLyAgICAgICAgICAgICAgIGBMJHtuZXh0Um91bmROdW1iZXJ9LSR7TWF0aC5mbG9vcihpIC8gMikgKyAxfWAsXG4vLyAgICAgICAgICAgICAgIG5leHRSb3VuZE51bWJlcixcbi8vICAgICAgICAgICAgICAgdGVhbTEsXG4vLyAgICAgICAgICAgICAgIHRlYW0yLFxuLy8gICAgICAgICAgICAgICAhdGVhbTIsXG4vLyAgICAgICAgICAgICAgIFwibG9zZXJzXCJcbi8vICAgICAgICAgICAgIClcbi8vICAgICAgICAgICApO1xuLy8gICAgICAgICB9XG4vLyAgICAgICB9XG4vLyAgICAgfVxuLy8gICB9XG5cbi8vICAgLy8gLS0tIFdpbm5lciBkZXRlY3Rpb24gbG9naWMgLS0tXG4vLyAgIGxldCB3aW5uZXI6IFRlYW0gfCB1bmRlZmluZWQgPSB0b3VybmFtZW50Lndpbm5lcjtcblxuLy8gICBpZiAoaXNDaGFtcGlvbnNoaXBSb3VuZCkge1xuLy8gICAgIC8vIEZpbmQgdGhlIGxhc3QgY2hhbXBpb25zaGlwIG1hdGNoIHBsYXllZFxuLy8gICAgIGNvbnN0IGxhc3RDaGFtcE1hdGNoID1cbi8vICAgICAgIGNoYW1waW9uc2hpcE1hdGNoZXNbMF0gfHxcbi8vICAgICAgIHByZXZDaGFtcGlvbnNoaXBNYXRjaGVzW3ByZXZDaGFtcGlvbnNoaXBNYXRjaGVzLmxlbmd0aCAtIDFdO1xuXG4vLyAgICAgaWYgKFxuLy8gICAgICAgbGFzdENoYW1wTWF0Y2ggJiZcbi8vICAgICAgIGxhc3RDaGFtcE1hdGNoLmlzQ29tcGxldGVkICYmXG4vLyAgICAgICBsYXN0Q2hhbXBNYXRjaC53aW5uZXIgJiZcbi8vICAgICAgIGxhc3RDaGFtcE1hdGNoLmxvc2VyXG4vLyAgICAgKSB7XG4vLyAgICAgICBjb25zdCB3aW5uZXJzQnJhY2tldFRlYW0gPSBsYXN0Q2hhbXBNYXRjaC50ZWFtMTtcbi8vICAgICAgIGNvbnN0IGxvc2Vyc0JyYWNrZXRUZWFtID0gbGFzdENoYW1wTWF0Y2gudGVhbTI7XG4vLyAgICAgICBjb25zdCBsb3NlcnNCcmFja2V0VGVhbVdvbiA9XG4vLyAgICAgICAgIGxhc3RDaGFtcE1hdGNoLndpbm5lci5pZCA9PT0gbG9zZXJzQnJhY2tldFRlYW0uaWQ7XG5cbi8vICAgICAgIC8vIElmIGxvc2VyJ3MgYnJhY2tldCB0ZWFtIHdvbiBmaXJzdCBjaGFtcGlvbnNoaXAgbWF0Y2gsIHdpbm5lcidzIGJyYWNrZXQgdGVhbSBnZXRzIGFub3RoZXIgY2hhbmNlXG4vLyAgICAgICBpZiAobG9zZXJzQnJhY2tldFRlYW1Xb24gJiYgdG91cm5hbWVudC5jaGFtcGlvbnNoaXBNYXRjaGVzUGxheWVkID09PSAxKSB7XG4vLyAgICAgICAgIHdpbm5lciA9IHVuZGVmaW5lZDsgLy8gTm8gd2lubmVyIHlldCwgbmVlZCByZXNldCBtYXRjaFxuLy8gICAgICAgfSBlbHNlIHtcbi8vICAgICAgICAgLy8gRWl0aGVyIHdpbm5lcidzIGJyYWNrZXQgdGVhbSB3b24gZmlyc3QgbWF0Y2gsIG9yIHRoaXMgd2FzIHRoZSByZXNldCBtYXRjaFxuLy8gICAgICAgICB3aW5uZXIgPSBsYXN0Q2hhbXBNYXRjaC53aW5uZXI7XG4vLyAgICAgICB9XG4vLyAgICAgfVxuLy8gICB9XG5cbi8vICAgLy8gLS0tIElORklOSVRFIFJFQ1VSU0lPTiBHVUFSRCAtLS1cbi8vICAgY29uc3Qgbm9Nb3JlTWF0Y2hlcyA9XG4vLyAgICAgKGlzQ2hhbXBpb25zaGlwUm91bmQgJiYgY2hhbXBpb25zaGlwTWF0Y2hlcy5sZW5ndGggPT09IDApIHx8XG4vLyAgICAgKCFpc0NoYW1waW9uc2hpcFJvdW5kICYmIG5leHRSb3VuZE1hdGNoZXMubGVuZ3RoID09PSAwKTtcblxuLy8gICBpZiAobm9Nb3JlTWF0Y2hlcykge1xuLy8gICAgIC8vIFRvdXJuYW1lbnQgaXMgb3ZlciwgZG8gbm90IGFkdmFuY2UgZnVydGhlclxuLy8gICAgIHJldHVybiB7XG4vLyAgICAgICAuLi50b3VybmFtZW50LFxuLy8gICAgICAgd2lubmVyLFxuLy8gICAgICAgY3VycmVudFJvdW5kOiB0b3VybmFtZW50LmN1cnJlbnRSb3VuZFxuLy8gICAgIH07XG4vLyAgIH1cblxuLy8gICAvLyBDb21wb3NlIHRoZSBuZXcgdG91cm5hbWVudCBvYmplY3RcbiAgXG4vLyAgIHJldHVybiB7XG4vLyAgICAgLi4udG91cm5hbWVudCxcbi8vICAgICByb3VuZHM6IFtcbi8vICAgICAgIC4uLnRvdXJuYW1lbnQucm91bmRzLFxuLy8gICAgICAge1xuLy8gICAgICAgICByb3VuZE51bWJlcjogbmV4dFJvdW5kTnVtYmVyLFxuLy8gICAgICAgICBtYXRjaGVzOiBpc0NoYW1waW9uc2hpcFJvdW5kID8gY2hhbXBpb25zaGlwTWF0Y2hlcyA6IG5leHRSb3VuZE1hdGNoZXMsXG4vLyAgICAgICAgIGlzRG91YmxlRWxpbWluYXRpb246IHRydWUsXG4vLyAgICAgICAgIGlzQ2hhbXBpb25zaGlwUm91bmRcbi8vICAgICAgIH1cbi8vICAgICBdLFxuLy8gICAgIGN1cnJlbnRSb3VuZDogbmV4dFJvdW5kTnVtYmVyLFxuLy8gICAgIGVsaW1pbmF0ZWRUZWFtczogW1xuLy8gICAgICAgLi4udG91cm5hbWVudC5lbGltaW5hdGVkVGVhbXMsXG4vLyAgICAgICAuLi5uZXdseUVsaW1pbmF0ZWQuZmlsdGVyKFxuLy8gICAgICAgICAodCkgPT4gIXRvdXJuYW1lbnQuZWxpbWluYXRlZFRlYW1zLnNvbWUoKGV0KSA9PiBldC5pZCA9PT0gdC5pZClcbi8vICAgICAgIClcbi8vICAgICBdLFxuLy8gICAgIGNoYW1waW9uc2hpcE1hdGNoZXNQbGF5ZWQ6IGlzQ2hhbXBpb25zaGlwUm91bmRcbi8vICAgICAgID8gdG91cm5hbWVudC5jaGFtcGlvbnNoaXBNYXRjaGVzUGxheWVkICsgMVxuLy8gICAgICAgOiB0b3VybmFtZW50LmNoYW1waW9uc2hpcE1hdGNoZXNQbGF5ZWQsXG4vLyAgICAgd2lubmVyc0JyYWNrZXRGaW5hbExvc2VyOiB0b3VybmFtZW50Lndpbm5lcnNCcmFja2V0RmluYWxMb3Nlcixcbi8vICAgICB3aW5uZXJcbi8vICAgfTtcbi8vIH07XG5cblxuXG4vLyBpbXBvcnQgdHlwZSB7IFRlYW0gfSBmcm9tIFwiLi9tbGItdGVhbXNcIjtcblxuLy8gZXhwb3J0IGludGVyZmFjZSBNYXRjaCB7XG4vLyAgIGlkOiBzdHJpbmc7XG4vLyAgIHJvdW5kTnVtYmVyOiBudW1iZXI7XG4vLyAgIHRlYW0xOiBUZWFtIHwgbnVsbDtcbi8vICAgdGVhbTI6IFRlYW0gfCBudWxsO1xuLy8gICBpc0NvbXBsZXRlZDogYm9vbGVhbjtcbi8vICAgaXNCeWU/OiBib29sZWFuO1xuLy8gICB3aW5uZXI/OiBUZWFtO1xuLy8gICBsb3Nlcj86IFRlYW07XG4vLyAgIGJyYWNrZXQ6IFwid2lubmVyc1wiIHwgXCJsb3NlcnNcIiB8IFwiY2hhbXBpb25zaGlwXCI7XG4vLyAgIHNjb3JlOiB7IHRlYW0xU2NvcmU6IG51bWJlcjsgdGVhbTJTY29yZTogbnVtYmVyIH07XG4vLyAgIG5leHRNYXRjaElkPzogc3RyaW5nO1xuLy8gICBuZXh0TG9zZXJNYXRjaElkPzogc3RyaW5nO1xuLy8gICBlbGltaW5hdGVkTGFiZWw/OiBzdHJpbmc7IC8vIGxhYmVsIGZvciBlbGltaW5hdGVkIHRlYW1zIGluIGxvc2VycyBicmFja2V0XG4vLyAgIHJlcXVpcmVzUmVtYXRjaD86IGJvb2xlYW47IC8vIGluZGljYXRlcyBpZiBhIGNoYW1waW9uc2hpcCByZW1hdGNoIGlzIHJlcXVpcmVkXG4vLyB9XG5cbi8vIGV4cG9ydCBpbnRlcmZhY2UgUm91bmQge1xuLy8gICByb3VuZE51bWJlcjogbnVtYmVyO1xuLy8gICBtYXRjaGVzOiBNYXRjaFtdO1xuLy8gICBpc0RvdWJsZUVsaW1pbmF0aW9uOiBib29sZWFuO1xuLy8gICBpc0NoYW1waW9uc2hpcFJvdW5kOiBib29sZWFuO1xuLy8gfVxuXG4vLyBleHBvcnQgaW50ZXJmYWNlIFRvdXJuYW1lbnQge1xuLy8gICByb3VuZHM6IFJvdW5kW107XG4vLyAgIGN1cnJlbnRSb3VuZDogbnVtYmVyO1xuLy8gICBlbGltaW5hdGVkVGVhbXM6IFRlYW1bXTtcbi8vICAgY2hhbXBpb25zaGlwTWF0Y2hlc1BsYXllZDogbnVtYmVyO1xuLy8gICB3aW5uZXI/OiBUZWFtO1xuLy8gICB3aW5uZXJzQnJhY2tldEZpbmFsTG9zZXI/OiBUZWFtOyAvLyB0cmFja3MgdGhlIHdpbm5lcidzIGJyYWNrZXQgZmluYWwgbG9zZXIgZm9yIGNoYW1waW9uc2hpcCByZW1hdGNoIGxvZ2ljXG4vLyB9XG5cbi8vIGV4cG9ydCBjb25zdCBjcmVhdGVNYXRjaCA9IChcbi8vICAgaWQ6IHN0cmluZyxcbi8vICAgcm91bmROdW1iZXI6IG51bWJlcixcbi8vICAgdGVhbTE6IFRlYW0gfCBudWxsLFxuLy8gICB0ZWFtMjogVGVhbSB8IG51bGwsXG4vLyAgIGlzQnllOiBib29sZWFuID0gZmFsc2UsXG4vLyAgIGJyYWNrZXQ6IFwid2lubmVyc1wiIHwgXCJsb3NlcnNcIiB8IFwiY2hhbXBpb25zaGlwXCIgPSBcIndpbm5lcnNcIixcbi8vICAgbmV4dE1hdGNoSWQ/OiBzdHJpbmcsXG4vLyAgIG5leHRMb3Nlck1hdGNoSWQ/OiBzdHJpbmdcbi8vICk6IE1hdGNoID0+ICh7XG4vLyAgIGlkLFxuLy8gICByb3VuZE51bWJlcixcbi8vICAgdGVhbTEsXG4vLyAgIHRlYW0yLFxuLy8gICBpc0NvbXBsZXRlZDogaXNCeWUsXG4vLyAgIGlzQnllLFxuLy8gICBicmFja2V0LFxuLy8gICB3aW5uZXI6IGlzQnllID8gKHRlYW0xID8/IHRlYW0yID8/IHVuZGVmaW5lZCkgOiB1bmRlZmluZWQsXG4vLyAgIGxvc2VyOiBpc0J5ZSA/IHVuZGVmaW5lZCA6IHVuZGVmaW5lZCxcbi8vICAgc2NvcmU6IHsgdGVhbTFTY29yZTogMCwgdGVhbTJTY29yZTogMCB9LFxuLy8gICBuZXh0TWF0Y2hJZCxcbi8vICAgbmV4dExvc2VyTWF0Y2hJZCxcbi8vICAgZWxpbWluYXRlZExhYmVsOiB1bmRlZmluZWRcbi8vIH0pO1xuXG4vLyBleHBvcnQgY29uc3QgY3JlYXRlSW5pdGlhbFJvdW5kcyA9ICh0ZWFtczogVGVhbVtdKTogVG91cm5hbWVudCA9PiB7XG4vLyAgIGNvbnN0IG51bVRlYW1zID0gdGVhbXMubGVuZ3RoO1xuLy8gICBjb25zdCBtYXRjaGVzOiBNYXRjaFtdID0gW107XG4vLyAgIGNvbnN0IG51bVJvdW5kcyA9IE1hdGguY2VpbChNYXRoLmxvZzIobnVtVGVhbXMpKTtcblxuLy8gICBjb25zdCBmaXJzdFJvdW5kTWF0Y2hlcyA9IE1hdGgucG93KDIsIG51bVJvdW5kcyAtIDEpO1xuLy8gICBsZXQgbWF0Y2hDb3VudGVyID0gMTtcblxuLy8gICBmb3IgKGxldCBpID0gMDsgaSA8IGZpcnN0Um91bmRNYXRjaGVzOyBpKyspIHtcbi8vICAgICBjb25zdCB0ZWFtMSA9IHRlYW1zW2kgKiAyXSB8fCBudWxsO1xuLy8gICAgIGNvbnN0IHRlYW0yID0gdGVhbXNbaSAqIDIgKyAxXSB8fCBudWxsO1xuLy8gICAgIGNvbnN0IGlzQnllID0gIXRlYW0xIHx8ICF0ZWFtMjtcblxuLy8gICAgIGNvbnN0IG1hdGNoSWQgPSBgVzEtJHttYXRjaENvdW50ZXJ9YDtcbi8vICAgICBjb25zdCBuZXh0TWF0Y2hJZCA9IGBXMi0ke01hdGguY2VpbChtYXRjaENvdW50ZXIgLyAyKX1gO1xuLy8gICAgIGNvbnN0IG5leHRMb3Nlck1hdGNoSWQgPSBgTDEtJHtNYXRoLmNlaWwobWF0Y2hDb3VudGVyIC8gMil9YDtcblxuLy8gICAgIG1hdGNoZXMucHVzaChcbi8vICAgICAgIGNyZWF0ZU1hdGNoKFxuLy8gICAgICAgICBtYXRjaElkLFxuLy8gICAgICAgICAxLFxuLy8gICAgICAgICB0ZWFtMSxcbi8vICAgICAgICAgdGVhbTIsXG4vLyAgICAgICAgIGlzQnllLFxuLy8gICAgICAgICBcIndpbm5lcnNcIixcbi8vICAgICAgICAgbmV4dE1hdGNoSWQsXG4vLyAgICAgICAgIG5leHRMb3Nlck1hdGNoSWRcbi8vICAgICAgIClcbi8vICAgICApO1xuLy8gICAgIG1hdGNoQ291bnRlcisrO1xuLy8gICB9XG5cbi8vICAgcmV0dXJuIHtcbi8vICAgICByb3VuZHM6IFtcbi8vICAgICAgIHtcbi8vICAgICAgICAgcm91bmROdW1iZXI6IDEsXG4vLyAgICAgICAgIG1hdGNoZXMsXG4vLyAgICAgICAgIGlzRG91YmxlRWxpbWluYXRpb246IHRydWUsXG4vLyAgICAgICAgIGlzQ2hhbXBpb25zaGlwUm91bmQ6IGZhbHNlXG4vLyAgICAgICB9XG4vLyAgICAgXSxcbi8vICAgICBjdXJyZW50Um91bmQ6IDEsXG4vLyAgICAgZWxpbWluYXRlZFRlYW1zOiBbXSxcbi8vICAgICBjaGFtcGlvbnNoaXBNYXRjaGVzUGxheWVkOiAwXG4vLyAgIH07XG4vLyB9O1xuXG4vLyBleHBvcnQgY29uc3QgdXBkYXRlTWF0Y2hTY29yZSA9IChcbi8vICAgbWF0Y2g6IE1hdGNoLFxuLy8gICBuZXdTY29yZTogeyB0ZWFtMVNjb3JlOiBudW1iZXI7IHRlYW0yU2NvcmU6IG51bWJlciB9XG4vLyApOiBNYXRjaCA9PiB7XG4vLyAgIC8vIE1hcmsgbWF0Y2ggYXMgY29tcGxldGVkIGlmIGJvdGggdGVhbXMgaGF2ZSBhIHNjb3JlIGVudGVyZWQgKGV2ZW4gaWYgc2NvcmVzIGFyZSBlcXVhbClcbi8vICAgY29uc3QgaXNDb21wbGV0ZWQgPVxuLy8gICAgIHR5cGVvZiBuZXdTY29yZS50ZWFtMVNjb3JlID09PSBcIm51bWJlclwiICYmXG4vLyAgICAgdHlwZW9mIG5ld1Njb3JlLnRlYW0yU2NvcmUgPT09IFwibnVtYmVyXCIgJiZcbi8vICAgICAoIWlzTmFOKG5ld1Njb3JlLnRlYW0xU2NvcmUpICYmICFpc05hTihuZXdTY29yZS50ZWFtMlNjb3JlKSk7XG4vLyAgIGxldCB3aW5uZXI6IFRlYW0gfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG4vLyAgIGxldCBsb3NlcjogVGVhbSB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcbi8vICAgaWYgKGlzQ29tcGxldGVkKSB7XG4vLyAgICAgaWYgKG5ld1Njb3JlLnRlYW0xU2NvcmUgPiBuZXdTY29yZS50ZWFtMlNjb3JlKSB7XG4vLyAgICAgICB3aW5uZXIgPSBtYXRjaC50ZWFtMSA/IHsgLi4ubWF0Y2gudGVhbTEsIHdpbnM6IChtYXRjaC50ZWFtMS53aW5zID8/IDApICsgMSwgbG9zc2VzOiBtYXRjaC50ZWFtMS5sb3NzZXMgPz8gMCB9IDogdW5kZWZpbmVkO1xuLy8gICAgICAgbG9zZXIgPSBtYXRjaC50ZWFtMiA/IHsgLi4ubWF0Y2gudGVhbTIsIHdpbnM6IG1hdGNoLnRlYW0yLndpbnMgPz8gMCwgbG9zc2VzOiAobWF0Y2gudGVhbTIubG9zc2VzID8/IDApICsgMSB9IDogdW5kZWZpbmVkO1xuLy8gICAgIH0gZWxzZSB7XG4vLyAgICAgICB3aW5uZXIgPSBtYXRjaC50ZWFtMiA/IHsgLi4ubWF0Y2gudGVhbTIsIHdpbnM6IChtYXRjaC50ZWFtMi53aW5zID8/IDApICsgMSwgbG9zc2VzOiBtYXRjaC50ZWFtMi5sb3NzZXMgPz8gMCB9IDogdW5kZWZpbmVkO1xuLy8gICAgICAgbG9zZXIgPSBtYXRjaC50ZWFtMSA/IHsgLi4ubWF0Y2gudGVhbTEsIHdpbnM6IG1hdGNoLnRlYW0xLndpbnMgPz8gMCwgbG9zc2VzOiAobWF0Y2gudGVhbTEubG9zc2VzID8/IDApICsgMSB9IDogdW5kZWZpbmVkO1xuLy8gICAgIH1cbi8vICAgfVxuLy8gICByZXR1cm4ge1xuLy8gICAgIC4uLm1hdGNoLFxuLy8gICAgIHNjb3JlOiBuZXdTY29yZSxcbi8vICAgICBpc0NvbXBsZXRlZCxcbi8vICAgICB3aW5uZXIsXG4vLyAgICAgbG9zZXJcbi8vICAgfTtcbi8vIH07XG5cbi8vIC8vIEhlbHBlciB0byBkZWR1cGxpY2F0ZSB0ZWFtcyBieSBJRFxuLy8gZnVuY3Rpb24gZGVkdXBlVGVhbXModGVhbXM6IFRlYW1bXSk6IFRlYW1bXSB7XG4vLyAgIGNvbnN0IHNlZW4gPSBuZXcgU2V0PHN0cmluZz4oKTtcbi8vICAgcmV0dXJuIHRlYW1zLmZpbHRlcih0ZWFtID0+IHtcbi8vICAgICBpZiAoIXRlYW0pIHJldHVybiBmYWxzZTtcbi8vICAgICBpZiAoc2Vlbi5oYXModGVhbS5pZCkpIHJldHVybiBmYWxzZTtcbi8vICAgICBzZWVuLmFkZCh0ZWFtLmlkKTtcbi8vICAgICByZXR1cm4gdHJ1ZTtcbi8vICAgfSk7XG4vLyB9XG5cbi8vIC8vIEhlbHBlcjogZ2V0IGFsbCB0ZWFtcyB3aXRoIGV4YWN0bHkgTiBsb3NzZXNcbi8vIGZ1bmN0aW9uIHRlYW1zV2l0aExvc3Nlcyhsb3NzQ291bnRzOiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+LCBuOiBudW1iZXIpOiBzdHJpbmdbXSB7XG4vLyAgIHJldHVybiBPYmplY3Qua2V5cyhsb3NzQ291bnRzKS5maWx0ZXIodGVhbUlkID0+IGxvc3NDb3VudHNbdGVhbUlkXSA9PT0gbik7XG4vLyB9XG5cbi8vIGV4cG9ydCBjb25zdCBhZHZhbmNlVG9OZXh0Um91bmQgPSAodG91cm5hbWVudDogVG91cm5hbWVudCk6IFRvdXJuYW1lbnQgPT4ge1xuLy8gICBjb25zdCBjdXJyZW50Um91bmQgPSB0b3VybmFtZW50LnJvdW5kc1t0b3VybmFtZW50LnJvdW5kcy5sZW5ndGggLSAxXTtcbi8vICAgY29uc3QgbmV4dFJvdW5kTnVtYmVyID0gdG91cm5hbWVudC5jdXJyZW50Um91bmQgKyAxO1xuXG4vLyAgIC8vIFRyYWNrIGFsbCBsb3NzZXMgYW5kIHdpbnMgYWNyb3NzIHRoZSB0b3VybmFtZW50XG4vLyAgIGNvbnN0IGxvc3NDb3VudHM6IFJlY29yZDxzdHJpbmcsIG51bWJlcj4gPSB7fTtcbi8vICAgY29uc3Qgd2luc0NvdW50czogUmVjb3JkPHN0cmluZywgbnVtYmVyPiA9IHt9O1xuLy8gICB0b3VybmFtZW50LnJvdW5kcy5mb3JFYWNoKChyb3VuZCkgPT4ge1xuLy8gICAgIHJvdW5kLm1hdGNoZXMuZm9yRWFjaCgobWF0Y2gpID0+IHtcbi8vICAgICAgIGlmIChtYXRjaC5pc0NvbXBsZXRlZCAmJiBtYXRjaC5sb3Nlcikge1xuLy8gICAgICAgICBsb3NzQ291bnRzW21hdGNoLmxvc2VyLmlkXSA9IChsb3NzQ291bnRzW21hdGNoLmxvc2VyLmlkXSB8fCAwKSArIDE7XG4vLyAgICAgICB9XG4vLyAgICAgICBpZiAobWF0Y2guaXNDb21wbGV0ZWQgJiYgbWF0Y2gud2lubmVyKSB7XG4vLyAgICAgICAgIHdpbnNDb3VudHNbbWF0Y2gud2lubmVyLmlkXSA9ICh3aW5zQ291bnRzW21hdGNoLndpbm5lci5pZF0gfHwgMCkgKyAxO1xuLy8gICAgICAgfVxuLy8gICAgIH0pO1xuLy8gICB9KTtcblxuLy8gICAvLyBHYXRoZXIgYWxsIHRlYW1zIGV2ZXIgaW4gdGhlIHRvdXJuYW1lbnQsIGF0dGFjaGluZyB3aW5zXG4vLyAgIGNvbnN0IGFsbFRlYW1zOiBUZWFtW10gPSBbXTtcbi8vICAgY29uc3QgdGVhbUlkcyA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuLy8gICBmb3IgKGNvbnN0IHJvdW5kIG9mIHRvdXJuYW1lbnQucm91bmRzKSB7XG4vLyAgICAgZm9yIChjb25zdCBtYXRjaCBvZiByb3VuZC5tYXRjaGVzKSB7XG4vLyAgICAgICBpZiAobWF0Y2gudGVhbTEgJiYgIXRlYW1JZHMuaGFzKG1hdGNoLnRlYW0xLmlkKSkge1xuLy8gICAgICAgICBhbGxUZWFtcy5wdXNoKHtcbi8vICAgICAgICAgICAuLi5tYXRjaC50ZWFtMSxcbi8vICAgICAgICAgICB3aW5zOiB3aW5zQ291bnRzW21hdGNoLnRlYW0xLmlkXSB8fCAwLFxuLy8gICAgICAgICAgIGxvc3NlczogbG9zc0NvdW50c1ttYXRjaC50ZWFtMS5pZF0gfHwgMFxuLy8gICAgICAgICB9KTtcbi8vICAgICAgICAgdGVhbUlkcy5hZGQobWF0Y2gudGVhbTEuaWQpO1xuLy8gICAgICAgfVxuLy8gICAgICAgaWYgKG1hdGNoLnRlYW0yICYmICF0ZWFtSWRzLmhhcyhtYXRjaC50ZWFtMi5pZCkpIHtcbi8vICAgICAgICAgYWxsVGVhbXMucHVzaCh7XG4vLyAgICAgICAgICAgLi4ubWF0Y2gudGVhbTIsXG4vLyAgICAgICAgICAgd2luczogd2luc0NvdW50c1ttYXRjaC50ZWFtMi5pZF0gfHwgMCxcbi8vICAgICAgICAgICBsb3NzZXM6IGxvc3NDb3VudHNbbWF0Y2gudGVhbTIuaWRdIHx8IDBcbi8vICAgICAgICAgfSk7XG4vLyAgICAgICAgIHRlYW1JZHMuYWRkKG1hdGNoLnRlYW0yLmlkKTtcbi8vICAgICAgIH1cbi8vICAgICB9XG4vLyAgIH1cblxuLy8gICAvLyBJZGVudGlmeSBuZXdseSBlbGltaW5hdGVkIHRlYW1zICgyIGxvc3Nlcylcbi8vICAgY29uc3QgbmV3bHlFbGltaW5hdGVkOiBUZWFtW10gPSBbXTtcbi8vICAgZm9yIChjb25zdCB0ZWFtIG9mIGFsbFRlYW1zKSB7XG4vLyAgICAgaWYgKFxuLy8gICAgICAgKGxvc3NDb3VudHNbdGVhbS5pZF0gfHwgMCkgPj0gMiAmJlxuLy8gICAgICAgIXRvdXJuYW1lbnQuZWxpbWluYXRlZFRlYW1zLnNvbWUoKHQpID0+IHQuaWQgPT09IHRlYW0uaWQpXG4vLyAgICAgKSB7XG4vLyAgICAgICBuZXdseUVsaW1pbmF0ZWQucHVzaCh0ZWFtKTtcbi8vICAgICB9XG4vLyAgIH1cblxuLy8gICAvLyBXaW5uZXJzOiB0ZWFtcyB3aXRoIDAgbG9zc2VzIGFuZCBub3QgZWxpbWluYXRlZFxuLy8gICBjb25zdCB3aW5uZXJzQnJhY2tldFRlYW1zID0gYWxsVGVhbXNcbi8vICAgICAuZmlsdGVyKFxuLy8gICAgICAgKHRlYW0pID0+XG4vLyAgICAgICAgIChsb3NzQ291bnRzW3RlYW0uaWRdIHx8IDApID09PSAwICYmXG4vLyAgICAgICAgICF0b3VybmFtZW50LmVsaW1pbmF0ZWRUZWFtcy5zb21lKCh0KSA9PiB0LmlkID09PSB0ZWFtLmlkKSAmJlxuLy8gICAgICAgICAhbmV3bHlFbGltaW5hdGVkLnNvbWUoKHQpID0+IHQuaWQgPT09IHRlYW0uaWQpICYmXG4vLyAgICAgICAgICF0ZWFtLmlkLnN0YXJ0c1dpdGgoJ3RiZC0nKSAvLyBFeGNsdWRlIGFueSBwaGFudG9tIFRCRCB0ZWFtc1xuLy8gICAgIClcbi8vICAgICAubWFwKCh0ZWFtKSA9PiAoeyAuLi50ZWFtLCBsb3NzZXM6IGxvc3NDb3VudHNbdGVhbS5pZF0gfHwgMCwgd2luczogd2luc0NvdW50c1t0ZWFtLmlkXSB8fCAwIH0pKTtcbi8vICAgLy8gTG9zZXJzOiB0ZWFtcyB3aXRoIDEgbG9zcyBhbmQgbm90IGVsaW1pbmF0ZWRcbi8vICAgY29uc3QgbG9zZXJzQnJhY2tldFRlYW1zID0gYWxsVGVhbXNcbi8vICAgICAuZmlsdGVyKFxuLy8gICAgICAgKHRlYW0pID0+XG4vLyAgICAgICAgIChsb3NzQ291bnRzW3RlYW0uaWRdIHx8IDApID09PSAxICYmXG4vLyAgICAgICAgICF0b3VybmFtZW50LmVsaW1pbmF0ZWRUZWFtcy5zb21lKCh0KSA9PiB0LmlkID09PSB0ZWFtLmlkKSAmJlxuLy8gICAgICAgICAhbmV3bHlFbGltaW5hdGVkLnNvbWUoKHQpID0+IHQuaWQgPT09IHRlYW0uaWQpXG4vLyAgICAgKVxuLy8gICAgIC5tYXAoKHRlYW0pID0+ICh7XG4vLyAgICAgICAuLi50ZWFtLFxuLy8gICAgICAgbG9zc2VzOiBsb3NzQ291bnRzW3RlYW0uaWRdIHx8IDAsXG4vLyAgICAgICB3aW5zOiB3aW5zQ291bnRzW3RlYW0uaWRdIHx8IDBcbi8vICAgICB9KSk7XG5cbi8vICAgbGV0IGlzQ2hhbXBpb25zaGlwUm91bmQgPSBmYWxzZTtcbi8vICAgbGV0IGNoYW1waW9uc2hpcE1hdGNoZXM6IE1hdGNoW10gPSBbXTtcbi8vICAgbGV0IG5leHRSb3VuZE1hdGNoZXM6IE1hdGNoW10gPSBbXTtcblxuLy8gICBjb25zdCBwcmV2Q2hhbXBpb25zaGlwTWF0Y2hlcyA9IHRvdXJuYW1lbnQucm91bmRzXG4vLyAgICAgLmZpbHRlcigocikgPT4gci5pc0NoYW1waW9uc2hpcFJvdW5kKVxuLy8gICAgIC5mbGF0TWFwKChyKSA9PiByLm1hdGNoZXMpXG4vLyAgICAgLmZpbHRlcigobSkgPT4gbS5icmFja2V0ID09PSBcImNoYW1waW9uc2hpcFwiKTtcblxuLy8gICAvLyAtLS0gQ0hBTVBJT05TSElQIExPR0lDIC0tLVxuXG4vLyAgIC8vIENoZWNrIGlmIGEgY2hhbXBpb25zaGlwIG1hdGNoIGFscmVhZHkgaGFwcGVuZWQgYW5kIHdhcyBjb21wbGV0ZWRcbi8vICAgaWYgKFxuLy8gICAgIHByZXZDaGFtcGlvbnNoaXBNYXRjaGVzLmxlbmd0aCA+PSAxICYmXG4vLyAgICAgcHJldkNoYW1waW9uc2hpcE1hdGNoZXNbcHJldkNoYW1waW9uc2hpcE1hdGNoZXMubGVuZ3RoIC0gMV0uaXNDb21wbGV0ZWRcbi8vICAgKSB7XG4vLyAgICAgY29uc3QgbGFzdENoYW1wTWF0Y2ggPVxuLy8gICAgICAgcHJldkNoYW1waW9uc2hpcE1hdGNoZXNbcHJldkNoYW1waW9uc2hpcE1hdGNoZXMubGVuZ3RoIC0gMV07XG4vLyAgICAgY29uc3Qgd2lubmVyc0JyYWNrZXRUZWFtID0gbGFzdENoYW1wTWF0Y2gudGVhbTE7XG4vLyAgICAgY29uc3QgbG9zZXJzQnJhY2tldFRlYW0gPSBsYXN0Q2hhbXBNYXRjaC50ZWFtMjtcblxuLy8gICAgIC8vIElmIGxvc2VyJ3MgYnJhY2tldCB0ZWFtIHdvbiB0aGUgZmlyc3QgY2hhbXBpb25zaGlwIG1hdGNoLCB3aW5uZXIncyBicmFja2V0IHRlYW0gZ2V0cyBhbm90aGVyIGNoYW5jZVxuLy8gICAgIGlmIChcbi8vICAgICAgIGxhc3RDaGFtcE1hdGNoLndpbm5lcj8uaWQgPT09IGxvc2Vyc0JyYWNrZXRUZWFtPy5pZCAmJlxuLy8gICAgICAgdG91cm5hbWVudC5jaGFtcGlvbnNoaXBNYXRjaGVzUGxheWVkID09PSAxXG4vLyAgICAgKSB7XG4vLyAgICAgICBpc0NoYW1waW9uc2hpcFJvdW5kID0gdHJ1ZTtcbi8vICAgICAgIC8vIENyZWF0ZSB0aGUgXCJyZXNldFwiIG1hdGNoIHdpdGggcmVxdWlyZXNSZW1hdGNoOiB0cnVlXG4vLyAgICAgICBjaGFtcGlvbnNoaXBNYXRjaGVzLnB1c2goe1xuLy8gICAgICAgICAuLi5jcmVhdGVNYXRjaChcbi8vICAgICAgICAgICBgQyR7bmV4dFJvdW5kTnVtYmVyfS0xYCxcbi8vICAgICAgICAgICBuZXh0Um91bmROdW1iZXIsXG4vLyAgICAgICAgICAgd2lubmVyc0JyYWNrZXRUZWFtLFxuLy8gICAgICAgICAgIGxvc2Vyc0JyYWNrZXRUZWFtLFxuLy8gICAgICAgICAgIGZhbHNlLFxuLy8gICAgICAgICAgIFwiY2hhbXBpb25zaGlwXCJcbi8vICAgICAgICAgKSxcbi8vICAgICAgICAgcmVxdWlyZXNSZW1hdGNoOiB0cnVlXG4vLyAgICAgICB9KTtcblxuLy8gICAgICAgLy8gSW5jcmVtZW50IHRoZSB3aW5uZXIncyBicmFja2V0IHRlYW0ncyBsb3NzIGNvdW50IGZvciB0aGUgcmVjb3JkXG4vLyAgICAgICBpZiAod2lubmVyc0JyYWNrZXRUZWFtICYmIHR5cGVvZiB3aW5uZXJzQnJhY2tldFRlYW0ubG9zc2VzID09PSBcIm51bWJlclwiKSB7XG4vLyAgICAgICAgIHdpbm5lcnNCcmFja2V0VGVhbS5sb3NzZXMgKz0gMTtcbi8vICAgICAgIH1cbi8vICAgICB9IGVsc2Uge1xuLy8gICAgICAgLy8gRWl0aGVyIHdpbm5lcidzIGJyYWNrZXQgdGVhbSB3b24gZmlyc3QgbWF0Y2gsIG9yIHRoaXMgd2FzIHRoZSByZXNldCBtYXRjaFxuLy8gICAgICAgaXNDaGFtcGlvbnNoaXBSb3VuZCA9IHRydWU7XG4vLyAgICAgICAvLyBObyBuZXcgbWF0Y2hlcywgd2lubmVyIHdpbGwgYmUgZGV0ZXJtaW5lZCBpbiB3aW5uZXIgZGV0ZWN0aW9uIGxvZ2ljXG4vLyAgICAgfVxuLy8gICB9XG4vLyAgIC8vIENoZWNrIGlmIHdlJ3JlIHJlYWR5IGZvciB0aGUgY2hhbXBpb25zaGlwIG1hdGNoIC0gb25lIHRlYW0gaW4gZWFjaCBicmFja2V0IGFuZCBsb3NlcidzIGZpbmFsIGlzIGNvbXBsZXRlXG4vLyAgIGVsc2UgaWYgKFxuLy8gICAgIHdpbm5lcnNCcmFja2V0VGVhbXMubGVuZ3RoID09PSAxICYmXG4vLyAgICAgLy8gSWYgQU5ZIGxvc2VycyBicmFja2V0IG1hdGNoIGluIHRoZSBjdXJyZW50IHJvdW5kIGlzIGluY29tcGxldGUsIHNob3cgd2FpdGluZyBjYXJkc1xuLy8gICAgIGN1cnJlbnRSb3VuZC5tYXRjaGVzLnNvbWUoXG4vLyAgICAgICAobSkgPT5cbi8vICAgICAgICAgKG0uYnJhY2tldCA9PT0gXCJsb3NlcnNcIiB8fCBtLmlkLmluY2x1ZGVzKFwiTG9zZXJzTGFzdFwiKSkgJiZcbi8vICAgICAgICAgIW0uaXNDb21wbGV0ZWRcbi8vICAgICApXG4vLyAgICkge1xuLy8gICAgIC8vIE5vdCByZWFkeSBmb3IgY2hhbXBpb25zaGlwOiBzaG93IHdhaXRpbmcgY2FyZHMgZm9yIGJvdGhcbi8vICAgICBuZXh0Um91bmRNYXRjaGVzLnB1c2goXG4vLyAgICAgICBjcmVhdGVNYXRjaChcbi8vICAgICAgICAgYFcke25leHRSb3VuZE51bWJlcn0td2FpdGluZ2AsXG4vLyAgICAgICAgIG5leHRSb3VuZE51bWJlcixcbi8vICAgICAgICAgd2lubmVyc0JyYWNrZXRUZWFtc1swXSxcbi8vICAgICAgICAge1xuLy8gICAgICAgICAgIGlkOiBgdGJkLSR7bmV4dFJvdW5kTnVtYmVyfS13YWl0aW5nYCxcbi8vICAgICAgICAgICBuYW1lOiBcIlRCRFwiLFxuLy8gICAgICAgICAgIGNpdHk6IFwiXCIsXG4vLyAgICAgICAgICAgbG9zc2VzOiAwXG4vLyAgICAgICAgIH0sXG4vLyAgICAgICAgIHRydWUsXG4vLyAgICAgICAgIFwid2lubmVyc1wiXG4vLyAgICAgICApXG4vLyAgICAgKTtcbi8vICAgICBpZiAodG91cm5hbWVudC53aW5uZXJzQnJhY2tldEZpbmFsTG9zZXIpIHtcbi8vICAgICAgIG5leHRSb3VuZE1hdGNoZXMucHVzaChcbi8vICAgICAgICAgY3JlYXRlTWF0Y2goXG4vLyAgICAgICAgICAgYExvc2Vyc0xhc3QtJHtuZXh0Um91bmROdW1iZXJ9YCxcbi8vICAgICAgICAgICBuZXh0Um91bmROdW1iZXIsXG4vLyAgICAgICAgICAgdG91cm5hbWVudC53aW5uZXJzQnJhY2tldEZpbmFsTG9zZXIsXG4vLyAgICAgICAgICAge1xuLy8gICAgICAgICAgICAgaWQ6IGB0YmQtbG9zZXJzLSR7bmV4dFJvdW5kTnVtYmVyfWAsXG4vLyAgICAgICAgICAgICBuYW1lOiBcIlRCRFwiLFxuLy8gICAgICAgICAgICAgY2l0eTogXCJcIixcbi8vICAgICAgICAgICAgIGxvc3NlczogMFxuLy8gICAgICAgICAgIH0sXG4vLyAgICAgICAgICAgdHJ1ZSxcbi8vICAgICAgICAgICBcImxvc2Vyc1wiXG4vLyAgICAgICAgIClcbi8vICAgICAgICk7XG4vLyAgICAgfVxuLy8gICAgIGxvZ1RvdXJuYW1lbnRTdGF0ZSh7XG4vLyAgICAgICByb3VuZE51bWJlcjogbmV4dFJvdW5kTnVtYmVyLFxuLy8gICAgICAgd2lubmVyc0JyYWNrZXRUZWFtcyxcbi8vICAgICAgIGxvc2Vyc0JyYWNrZXRUZWFtcyxcbi8vICAgICAgIG1hdGNoZXM6IG5leHRSb3VuZE1hdGNoZXMsXG4vLyAgICAgICB3aW5uZXJzQnJhY2tldEZpbmFsTG9zZXI6IHRvdXJuYW1lbnQud2lubmVyc0JyYWNrZXRGaW5hbExvc2VyXG4vLyAgICAgfSk7XG4vLyAgICAgY3JlYXRlTG9zZXJzQnJhY2tldE1hdGNoZXMoKTtcbi8vICAgfVxuLy8gICAvLyBDaGVjayBpZiB3ZSBoYXZlIGEgbG9zZXIgZnJvbSB3aW5uZXIncyBicmFja2V0IGZpbmFsIHdhaXRpbmcgdG8gcGxheSBhZ2FpbnN0IGxvc2VyJ3MgYnJhY2tldCB3aW5uZXJcbi8vICAgZWxzZSBpZiAoXG4vLyAgICAgd2lubmVyc0JyYWNrZXRUZWFtcy5sZW5ndGggPT09IDEgJiZcbi8vICAgICB0b3VybmFtZW50Lndpbm5lcnNCcmFja2V0RmluYWxMb3NlclxuLy8gICApIHtcbi8vICAgICAvLyBBbHdheXMgc2hvdyB0aGUgd2FpdGluZyBjYXJkIGZvciB0aGUgbG9zZXJzIGJyYWNrZXQgZmluYWwgbG9zZXIsIGV2ZW4gaWYgdGhlIG9wcG9uZW50IGlzIFRCRFxuLy8gICAgIGxldCBsb3NlcnNCcmFja2V0V2lubmVyID0gbnVsbDtcbi8vICAgICBpZiAobG9zZXJzQnJhY2tldFRlYW1zLmxlbmd0aCA+PSAxKSB7XG4vLyAgICAgICBsb3NlcnNCcmFja2V0V2lubmVyID0gY3VycmVudFJvdW5kLm1hdGNoZXNcbi8vICAgICAgICAgLmZpbHRlcigobSkgPT4gbS5icmFja2V0ID09PSBcImxvc2Vyc1wiICYmIG0uaXNDb21wbGV0ZWQgJiYgbS53aW5uZXIpXG4vLyAgICAgICAgIC5tYXAoKG0pID0+IG0ud2lubmVyISlcbi8vICAgICAgICAgLmZpbmQoKHdpbm5lcikgPT4gbG9zZXJzQnJhY2tldFRlYW1zLnNvbWUoKHQpID0+IHQuaWQgPT09IHdpbm5lci5pZCkpO1xuLy8gICAgIH1cbi8vICAgICBjb25zdCBvcHBvbmVudCA9XG4vLyAgICAgICBsb3NlcnNCcmFja2V0V2lubmVyICYmXG4vLyAgICAgICBsb3NlcnNCcmFja2V0V2lubmVyLmlkICE9PSB0b3VybmFtZW50Lndpbm5lcnNCcmFja2V0RmluYWxMb3Nlci5pZFxuLy8gICAgICAgICA/IGxvc2Vyc0JyYWNrZXRXaW5uZXJcbi8vICAgICAgICAgOiB7XG4vLyAgICAgICAgICAgICBpZDogYHRiZC1sb3NlcnMtJHtuZXh0Um91bmROdW1iZXJ9YCxcbi8vICAgICAgICAgICAgIG5hbWU6IFwiVEJEXCIsXG4vLyAgICAgICAgICAgICBjaXR5OiBcIlwiLFxuLy8gICAgICAgICAgICAgbG9zc2VzOiAwXG4vLyAgICAgICAgICAgfTtcbi8vICAgICBjb25zdCBpc0J5ZSA9XG4vLyAgICAgICAhbG9zZXJzQnJhY2tldFdpbm5lciB8fFxuLy8gICAgICAgbG9zZXJzQnJhY2tldFdpbm5lci5pZCA9PT0gdG91cm5hbWVudC53aW5uZXJzQnJhY2tldEZpbmFsTG9zZXIuaWQ7XG4vLyAgICAgbmV4dFJvdW5kTWF0Y2hlcy5wdXNoKFxuLy8gICAgICAgY3JlYXRlTWF0Y2goXG4vLyAgICAgICAgIGBMb3NlcnNMYXN0LSR7bmV4dFJvdW5kTnVtYmVyfWAsXG4vLyAgICAgICAgIG5leHRSb3VuZE51bWJlcixcbi8vICAgICAgICAgdG91cm5hbWVudC53aW5uZXJzQnJhY2tldEZpbmFsTG9zZXIsXG4vLyAgICAgICAgIG9wcG9uZW50LFxuLy8gICAgICAgICBpc0J5ZSxcbi8vICAgICAgICAgXCJsb3NlcnNcIlxuLy8gICAgICAgKVxuLy8gICAgICk7XG4vLyAgICAgLy8gQWx3YXlzIHJlbmRlciB0aGUgd2lubmVycyBicmFja2V0IGNoYW1waW9uIGFzIGEgbm9uLXNjb3JlYWJsZSB3YWl0aW5nIGNhcmQgaWYgdGhlIGxvc2VycyBicmFja2V0IGlzIG5vdCByZXNvbHZlZFxuLy8gICAgIG5leHRSb3VuZE1hdGNoZXMucHVzaChcbi8vICAgICAgIGNyZWF0ZU1hdGNoKFxuLy8gICAgICAgICBgVyR7bmV4dFJvdW5kTnVtYmVyfS13YWl0aW5nYCxcbi8vICAgICAgICAgbmV4dFJvdW5kTnVtYmVyLFxuLy8gICAgICAgICB3aW5uZXJzQnJhY2tldFRlYW1zWzBdLFxuLy8gICAgICAgICB7XG4vLyAgICAgICAgICAgaWQ6IGB0YmQtJHtuZXh0Um91bmROdW1iZXJ9LXdhaXRpbmdgLFxuLy8gICAgICAgICAgIG5hbWU6IFwiVEJEXCIsXG4vLyAgICAgICAgICAgY2l0eTogXCJcIixcbi8vICAgICAgICAgICBsb3NzZXM6IDBcbi8vICAgICAgICAgfSxcbi8vICAgICAgICAgdHJ1ZSwgLy8gaXNCeWU6IHRydWUgdG8gZW5zdXJlIGl0J3Mgbm90IHNjb3JlYWJsZVxuLy8gICAgICAgICBcIndpbm5lcnNcIlxuLy8gICAgICAgKVxuLy8gICAgICk7XG4vLyAgICAgY3JlYXRlTG9zZXJzQnJhY2tldE1hdGNoZXMoKTtcbi8vICAgfVxuLy8gICAvLyBPdGhlcndpc2UsIGNvbnRpbnVlIHdpdGggbm9ybWFsIGJyYWNrZXQgcGxheVxuLy8gICBlbHNlIHtcbi8vICAgICAvLyBJZiBvbmx5IG9uZSB0ZWFtIGluIHdpbm5lcnMgYW5kIGxvc2VycyBicmFja2V0IGlzIG5vdCByZXNvbHZlZCwgYWx3YXlzIHNob3cgd2FpdGluZyBjYXJkc1xuLy8gICAgIGlmICh3aW5uZXJzQnJhY2tldFRlYW1zLmxlbmd0aCA9PT0gMSAmJiBsb3NlcnNCcmFja2V0VGVhbXMubGVuZ3RoID49IDEpIHtcbi8vICAgICAgIG5leHRSb3VuZE1hdGNoZXMucHVzaChcbi8vICAgICAgICAgY3JlYXRlTWF0Y2goXG4vLyAgICAgICAgICAgYFcke25leHRSb3VuZE51bWJlcn0td2FpdGluZ2AsXG4vLyAgICAgICAgICAgbmV4dFJvdW5kTnVtYmVyLFxuLy8gICAgICAgICAgIHdpbm5lcnNCcmFja2V0VGVhbXNbMF0sXG4vLyAgICAgICAgICAge1xuLy8gICAgICAgICAgICAgaWQ6IGB0YmQtJHtuZXh0Um91bmROdW1iZXJ9LXdhaXRpbmdgLFxuLy8gICAgICAgICAgICAgbmFtZTogXCJUQkRcIixcbi8vICAgICAgICAgICAgIGNpdHk6IFwiXCIsXG4vLyAgICAgICAgICAgICBsb3NzZXM6IDBcbi8vICAgICAgICAgICB9LFxuLy8gICAgICAgICAgIHRydWUsXG4vLyAgICAgICAgICAgXCJ3aW5uZXJzXCJcbi8vICAgICAgICAgKVxuLy8gICAgICAgKTtcbi8vICAgICAgIGlmICh0b3VybmFtZW50Lndpbm5lcnNCcmFja2V0RmluYWxMb3Nlcikge1xuLy8gICAgICAgICBuZXh0Um91bmRNYXRjaGVzLnB1c2goXG4vLyAgICAgICAgICAgY3JlYXRlTWF0Y2goXG4vLyAgICAgICAgICAgICBgTG9zZXJzTGFzdC0ke25leHRSb3VuZE51bWJlcn1gLFxuLy8gICAgICAgICAgICAgbmV4dFJvdW5kTnVtYmVyLFxuLy8gICAgICAgICAgICAgdG91cm5hbWVudC53aW5uZXJzQnJhY2tldEZpbmFsTG9zZXIsXG4vLyAgICAgICAgICAgICB7XG4vLyAgICAgICAgICAgICAgIGlkOiBgdGJkLWxvc2Vycy0ke25leHRSb3VuZE51bWJlcn1gLFxuLy8gICAgICAgICAgICAgICBuYW1lOiBcIlRCRFwiLFxuLy8gICAgICAgICAgICAgICBjaXR5OiBcIlwiLFxuLy8gICAgICAgICAgICAgICBsb3NzZXM6IDBcbi8vICAgICAgICAgICAgIH0sXG4vLyAgICAgICAgICAgICB0cnVlLFxuLy8gICAgICAgICAgICAgXCJsb3NlcnNcIlxuLy8gICAgICAgICAgIClcbi8vICAgICAgICAgKTtcbi8vICAgICAgIH1cbi8vICAgICB9XG4vLyAgIH1cblxuLy8gICAvLyBIZWxwZXIgZnVuY3Rpb24gdG8gY3JlYXRlIHN0YW5kYXJkIGJyYWNrZXQgbWF0Y2hlc1xuLy8gICBmdW5jdGlvbiBjcmVhdGVTdGFuZGFyZEJyYWNrZXRNYXRjaGVzKCkge1xuLy8gICAgIC8vIC0tLSBXaW5uZXJzIEJyYWNrZXQgTWF0Y2hlcyAtLS1cbi8vICAgICBsZXQgbWF0Y2hDb3VudGVyID0gMTtcbi8vICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHdpbm5lcnNCcmFja2V0VGVhbXMubGVuZ3RoOyBpICs9IDIpIHtcbi8vICAgICAgIGNvbnN0IHRlYW0xID0gd2lubmVyc0JyYWNrZXRUZWFtc1tpXTtcbi8vICAgICAgIGNvbnN0IHRlYW0yID0gd2lubmVyc0JyYWNrZXRUZWFtc1tpICsgMV0gPz8gbnVsbDtcbi8vICAgICAgIGNvbnN0IGlzQnllID0gIXRlYW0yO1xuLy8gICAgICAgbmV4dFJvdW5kTWF0Y2hlcy5wdXNoKFxuLy8gICAgICAgICBjcmVhdGVNYXRjaChcbi8vICAgICAgICAgICBgVyR7bmV4dFJvdW5kTnVtYmVyfS0ke21hdGNoQ291bnRlcn1gLFxuLy8gICAgICAgICAgIG5leHRSb3VuZE51bWJlcixcbi8vICAgICAgICAgICB0ZWFtMSxcbi8vICAgICAgICAgICB0ZWFtMixcbi8vICAgICAgICAgICBpc0J5ZSxcbi8vICAgICAgICAgICBcIndpbm5lcnNcIlxuLy8gICAgICAgICApXG4vLyAgICAgICApO1xuLy8gICAgICAgbWF0Y2hDb3VudGVyKys7XG4vLyAgICAgfVxuXG4vLyAgICAgLy8gQ3JlYXRlIGxvc2VycyBicmFja2V0IG1hdGNoZXMgc2VwYXJhdGVseVxuLy8gICAgIGNyZWF0ZUxvc2Vyc0JyYWNrZXRNYXRjaGVzKCk7XG4vLyAgIH1cblxuLy8gICAvLyBIZWxwZXIgZnVuY3Rpb24gdG8gY3JlYXRlIGxvc2VycyBicmFja2V0IG1hdGNoZXNcbi8vICAgZnVuY3Rpb24gY3JlYXRlTG9zZXJzQnJhY2tldE1hdGNoZXMoKSB7XG4vLyAgICAgLy8gLS0tIExvc2VycyBCcmFja2V0IE1hdGNoZXMgLS0tXG4vLyAgICAgY29uc3QgZWxpZ2libGVMb3NlcnMgPSBhbGxUZWFtcy5maWx0ZXIoXG4vLyAgICAgICAodGVhbSkgPT5cbi8vICAgICAgICAgKGxvc3NDb3VudHNbdGVhbS5pZF0gfHwgMCkgPT09IDEgJiZcbi8vICAgICAgICAgIXRvdXJuYW1lbnQuZWxpbWluYXRlZFRlYW1zLnNvbWUoKHQpID0+IHQuaWQgPT09IHRlYW0uaWQpICYmXG4vLyAgICAgICAgICFuZXdseUVsaW1pbmF0ZWQuc29tZSgodCkgPT4gdC5pZCA9PT0gdGVhbS5pZCkgJiZcbi8vICAgICAgICAgLy8gRXhjbHVkZSB3aW5uZXIncyBicmFja2V0IGZpbmFsIGxvc2VyIGlmIGl0IGV4aXN0cyBidXQgaGFzbid0IHBsYXllZCB5ZXQgaW4gbG9zZXJzXG4vLyAgICAgICAgICEoXG4vLyAgICAgICAgICAgdG91cm5hbWVudC53aW5uZXJzQnJhY2tldEZpbmFsTG9zZXIgJiZcbi8vICAgICAgICAgICB0b3VybmFtZW50Lndpbm5lcnNCcmFja2V0RmluYWxMb3Nlci5pZCA9PT0gdGVhbS5pZFxuLy8gICAgICAgICApXG4vLyAgICAgKTtcblxuLy8gICAgIC8vIEZpbmQgdGVhbXMgcmVjZW50bHkgZHJvcHBlZCBmcm9tIHdpbm5lcnMgYnJhY2tldFxuLy8gICAgIGNvbnN0IGp1c3REcm9wcGVkRnJvbVdpbm5lcnMgPSBjdXJyZW50Um91bmQubWF0Y2hlc1xuLy8gICAgICAgLmZpbHRlcigobSkgPT4gbS5icmFja2V0ID09PSBcIndpbm5lcnNcIiAmJiBtLmxvc2VyICYmIG0uaXNDb21wbGV0ZWQpXG4vLyAgICAgICAubWFwKChtKSA9PiBtLmxvc2VyISlcbi8vICAgICAgIC5maWx0ZXIoKGxvc2VyKSA9PiBlbGlnaWJsZUxvc2Vycy5zb21lKCh0KSA9PiB0LmlkID09PSBsb3Nlci5pZCkpO1xuXG4vLyAgICAgLy8gSWYgdGhpcyBpcyB0aGUgd2lubmVyJ3MgYnJhY2tldCBmaW5hbCwgc3RvcmUgdGhlIGxvc2VyIGZvciBsYXRlciB1c2Vcbi8vICAgICBpZiAoXG4vLyAgICAgICBjdXJyZW50Um91bmQubWF0Y2hlcy5zb21lKFxuLy8gICAgICAgICAobSkgPT5cbi8vICAgICAgICAgICBtLmJyYWNrZXQgPT09IFwid2lubmVyc1wiICYmXG4vLyAgICAgICAgICAgd2lubmVyc0JyYWNrZXRUZWFtcy5sZW5ndGggPT09IDEgJiZcbi8vICAgICAgICAgICBtLmxvc2VyICYmXG4vLyAgICAgICAgICAgbS5pc0NvbXBsZXRlZFxuLy8gICAgICAgKVxuLy8gICAgICkge1xuLy8gICAgICAgLy8gVGhpcyBpcyBhIHNwZWNpYWwgY2FzZSAtIHdlIGZvdW5kIHRoZSB3aW5uZXIncyBicmFja2V0IGZpbmFsIGxvc2VyXG4vLyAgICAgICBjb25zdCB3aW5uZXJzRmluYWxMb3NlciA9IGN1cnJlbnRSb3VuZC5tYXRjaGVzXG4vLyAgICAgICAgIC5maWx0ZXIoKG0pID0+IG0uYnJhY2tldCA9PT0gXCJ3aW5uZXJzXCIgJiYgbS5pc0NvbXBsZXRlZCAmJiBtLmxvc2VyKVxuLy8gICAgICAgICAubWFwKChtKSA9PiBtLmxvc2VyISlcbi8vICAgICAgICAgLnBvcCgpO1xuXG4vLyAgICAgICBpZiAod2lubmVyc0ZpbmFsTG9zZXIpIHtcbi8vICAgICAgICAgdG91cm5hbWVudC53aW5uZXJzQnJhY2tldEZpbmFsTG9zZXIgPSB3aW5uZXJzRmluYWxMb3Nlcjtcbi8vICAgICAgIH1cbi8vICAgICB9XG5cbi8vICAgICAvLyBFeGlzdGluZyBsb3NlcnMgYnJhY2tldCB0ZWFtc1xuLy8gICAgIGNvbnN0IGV4aXN0aW5nTG9zZXJzID0gZWxpZ2libGVMb3NlcnMuZmlsdGVyKFxuLy8gICAgICAgKHQpID0+ICFqdXN0RHJvcHBlZEZyb21XaW5uZXJzLnNvbWUoKGpkKSA9PiBqZC5pZCA9PT0gdC5pZClcbi8vICAgICApO1xuXG4vLyAgICAgLy8gT3JkZXI6IG1vc3QgcmVjZW50IGRyb3AocykgZmlyc3Rcbi8vICAgICBjb25zdCBvcmRlcmVkTG9zZXJzID0gWy4uLmp1c3REcm9wcGVkRnJvbVdpbm5lcnMsIC4uLmV4aXN0aW5nTG9zZXJzXTtcblxuLy8gICAgIGlmIChvcmRlcmVkTG9zZXJzLmxlbmd0aCA+IDApIHtcbi8vICAgICAgIGlmIChvcmRlcmVkTG9zZXJzLmxlbmd0aCAlIDIgPT09IDEpIHtcbi8vICAgICAgICAgLy8gT2RkOiBieWUgZ29lcyB0byB0aGUgbW9zdCByZWNlbnQgdGVhbSBkcm9wcGVkIGZyb20gd2lubmVycyBicmFja2V0XG4vLyAgICAgICAgIGxldCB0ZWFtV2l0aEJ5ZTogVGVhbSB8IG51bGwgPSBudWxsO1xuLy8gICAgICAgICBpZiAoanVzdERyb3BwZWRGcm9tV2lubmVycy5sZW5ndGggPiAwKSB7XG4vLyAgICAgICAgICAgdGVhbVdpdGhCeWUgPVxuLy8gICAgICAgICAgICAganVzdERyb3BwZWRGcm9tV2lubmVyc1tqdXN0RHJvcHBlZEZyb21XaW5uZXJzLmxlbmd0aCAtIDFdO1xuLy8gICAgICAgICAgIC8vIFJlbW92ZSB0aGUgYnllIHRlYW0gZnJvbSBvcmRlcmVkTG9zZXJzXG4vLyAgICAgICAgICAgY29uc3QgYnllSW5kZXggPSBvcmRlcmVkTG9zZXJzLmZpbmRJbmRleChcbi8vICAgICAgICAgICAgICh0KSA9PiB0LmlkID09PSB0ZWFtV2l0aEJ5ZSEuaWRcbi8vICAgICAgICAgICApO1xuLy8gICAgICAgICAgIGlmIChieWVJbmRleCAhPT0gLTEpIG9yZGVyZWRMb3NlcnMuc3BsaWNlKGJ5ZUluZGV4LCAxKTtcbi8vICAgICAgICAgfSBlbHNlIHtcbi8vICAgICAgICAgICAvLyBEZWZlbnNpdmU6IGZhbGxiYWNrIHRvIGZpcnN0IHRlYW0gaWYgbm8gcmVjZW50IGRyb3Bcbi8vICAgICAgICAgICB0ZWFtV2l0aEJ5ZSA9IG9yZGVyZWRMb3NlcnMuc2hpZnQoKSE7XG4vLyAgICAgICAgIH1cbi8vICAgICAgICAgbmV4dFJvdW5kTWF0Y2hlcy5wdXNoKFxuLy8gICAgICAgICAgIGNyZWF0ZU1hdGNoKFxuLy8gICAgICAgICAgICAgYEwke25leHRSb3VuZE51bWJlcn0tMWAsXG4vLyAgICAgICAgICAgICBuZXh0Um91bmROdW1iZXIsXG4vLyAgICAgICAgICAgICB0ZWFtV2l0aEJ5ZSxcbi8vICAgICAgICAgICAgIG51bGwsXG4vLyAgICAgICAgICAgICB0cnVlLFxuLy8gICAgICAgICAgICAgXCJsb3NlcnNcIlxuLy8gICAgICAgICAgIClcbi8vICAgICAgICAgKTtcbi8vICAgICAgICAgLy8gUGFpciB0aGUgcmVzdFxuLy8gICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9yZGVyZWRMb3NlcnMubGVuZ3RoOyBpICs9IDIpIHtcbi8vICAgICAgICAgICBjb25zdCB0ZWFtMSA9IG9yZGVyZWRMb3NlcnNbaV07XG4vLyAgICAgICAgICAgY29uc3QgdGVhbTIgPSBvcmRlcmVkTG9zZXJzW2kgKyAxXSA/PyBudWxsO1xuLy8gICAgICAgICAgIG5leHRSb3VuZE1hdGNoZXMucHVzaChcbi8vICAgICAgICAgICAgIGNyZWF0ZU1hdGNoKFxuLy8gICAgICAgICAgICAgICBgTCR7bmV4dFJvdW5kTnVtYmVyfS0ke01hdGguZmxvb3IoaSAvIDIpICsgMn1gLFxuLy8gICAgICAgICAgICAgICBuZXh0Um91bmROdW1iZXIsXG4vLyAgICAgICAgICAgICAgIHRlYW0xLFxuLy8gICAgICAgICAgICAgICB0ZWFtMixcbi8vICAgICAgICAgICAgICAgIXRlYW0yLFxuLy8gICAgICAgICAgICAgICBcImxvc2Vyc1wiXG4vLyAgICAgICAgICAgICApXG4vLyAgICAgICAgICAgKTtcbi8vICAgICAgICAgfVxuLy8gICAgICAgfSBlbHNlIHtcbi8vICAgICAgICAgLy8gRXZlbiBudW1iZXI6IHBhaXIgYWxsXG4vLyAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3JkZXJlZExvc2Vycy5sZW5ndGg7IGkgKz0gMikge1xuLy8gICAgICAgICAgIGNvbnN0IHRlYW0xID0gb3JkZXJlZExvc2Vyc1tpXTtcbi8vICAgICAgICAgICBjb25zdCB0ZWFtMiA9IG9yZGVyZWRMb3NlcnNbaSArIDFdID8/IG51bGw7XG4vLyAgICAgICAgICAgbmV4dFJvdW5kTWF0Y2hlcy5wdXNoKFxuLy8gICAgICAgICAgICAgY3JlYXRlTWF0Y2goXG4vLyAgICAgICAgICAgICAgIGBMJHtuZXh0Um91bmROdW1iZXJ9LSR7TWF0aC5mbG9vcihpIC8gMikgKyAxfWAsXG4vLyAgICAgICAgICAgICAgIG5leHRSb3VuZE51bWJlcixcbi8vICAgICAgICAgICAgICAgdGVhbTEsXG4vLyAgICAgICAgICAgICAgIHRlYW0yLFxuLy8gICAgICAgICAgICAgICAhdGVhbTIsXG4vLyAgICAgICAgICAgICAgIFwibG9zZXJzXCJcbi8vICAgICAgICAgICAgIClcbi8vICAgICAgICAgICApO1xuLy8gICAgICAgICB9XG4vLyAgICAgICB9XG4vLyAgICAgfVxuLy8gICB9XG5cbi8vICAgLy8gLS0tIFdpbm5lciBkZXRlY3Rpb24gbG9naWMgLS0tXG4vLyAgIGxldCB3aW5uZXI6IFRlYW0gfCB1bmRlZmluZWQgPSB0b3VybmFtZW50Lndpbm5lcjtcblxuLy8gICBpZiAoaXNDaGFtcGlvbnNoaXBSb3VuZCkge1xuLy8gICAgIC8vIEZpbmQgdGhlIGxhc3QgY2hhbXBpb25zaGlwIG1hdGNoIHBsYXllZFxuLy8gICAgIGNvbnN0IGxhc3RDaGFtcE1hdGNoID1cbi8vICAgICAgIGNoYW1waW9uc2hpcE1hdGNoZXNbMF0gfHxcbi8vICAgICAgIHByZXZDaGFtcGlvbnNoaXBNYXRjaGVzW3ByZXZDaGFtcGlvbnNoaXBNYXRjaGVzLmxlbmd0aCAtIDFdO1xuXG4vLyAgICAgaWYgKFxuLy8gICAgICAgbGFzdENoYW1wTWF0Y2ggJiZcbi8vICAgICAgIGxhc3RDaGFtcE1hdGNoLmlzQ29tcGxldGVkICYmXG4vLyAgICAgICBsYXN0Q2hhbXBNYXRjaC53aW5uZXIgJiZcbi8vICAgICAgIGxhc3RDaGFtcE1hdGNoLmxvc2VyXG4vLyAgICAgKSB7XG4vLyAgICAgICBjb25zdCB3aW5uZXJzQnJhY2tldFRlYW0gPSBsYXN0Q2hhbXBNYXRjaC50ZWFtMTtcbi8vICAgICAgIGNvbnN0IGxvc2Vyc0JyYWNrZXRUZWFtID0gbGFzdENoYW1wTWF0Y2gudGVhbTI7XG4vLyAgICAgICBjb25zdCBsb3NlcnNCcmFja2V0VGVhbVdvbiA9XG4vLyAgICAgICAgIGxvc2Vyc0JyYWNrZXRUZWFtICYmIGxhc3RDaGFtcE1hdGNoLndpbm5lci5pZCA9PT0gbG9zZXJzQnJhY2tldFRlYW0uaWQ7XG5cbi8vICAgICAgIC8vIElmIGxvc2VyJ3MgYnJhY2tldCB0ZWFtIHdvbiBmaXJzdCBjaGFtcGlvbnNoaXAgbWF0Y2gsIHdpbm5lcidzIGJyYWNrZXQgdGVhbSBnZXRzIGFub3RoZXIgY2hhbmNlXG4vLyAgICAgICBpZiAobG9zZXJzQnJhY2tldFRlYW1Xb24gJiYgdG91cm5hbWVudC5jaGFtcGlvbnNoaXBNYXRjaGVzUGxheWVkID09PSAxKSB7XG4vLyAgICAgICAgIC8vIERvIE5PVCBpbmNyZW1lbnQgdGhlIHdpbm5lcidzIGJyYWNrZXQgdGVhbSdzIGxvc3MgY291bnQgb3Igc2V0IHdpbm5lciB5ZXRcbi8vICAgICAgICAgLy8gV2FpdCBmb3IgdGhlIHJlbWF0Y2ggdG8gYmUgcGxheWVkXG4vLyAgICAgICAgIHdpbm5lciA9IHVuZGVmaW5lZDsgLy8gTm8gd2lubmVyIHlldCwgbmVlZCByZXNldCBtYXRjaFxuLy8gICAgICAgfSBlbHNlIGlmIChcbi8vICAgICAgICAgbGFzdENoYW1wTWF0Y2gucmVxdWlyZXNSZW1hdGNoICYmXG4vLyAgICAgICAgICFsYXN0Q2hhbXBNYXRjaC5pc0NvbXBsZXRlZFxuLy8gICAgICAgKSB7XG4vLyAgICAgICAgIC8vIElmIHRoZSByZW1hdGNoIGlzIHJlcXVpcmVkIGJ1dCBub3QgY29tcGxldGVkLCBkbyBub3Qgc2V0IHdpbm5lciBvciBpbmNyZW1lbnQgbG9zc2VzXG4vLyAgICAgICAgIHdpbm5lciA9IHVuZGVmaW5lZDtcbi8vICAgICAgIH0gZWxzZSB7XG4vLyAgICAgICAgIC8vIElmIHRoaXMgaXMgdGhlIHJlbWF0Y2ggYW5kIGl0J3MgY29tcGxldGVkLCBpbmNyZW1lbnQgbG9zcyBmb3Igd2lubmVyJ3MgYnJhY2tldCB0ZWFtIE9OTFkgSUYgdGhleSBsb3NlIGFnYWluXG4vLyAgICAgICAgIGlmIChcbi8vICAgICAgICAgICBsYXN0Q2hhbXBNYXRjaC5yZXF1aXJlc1JlbWF0Y2ggJiZcbi8vICAgICAgICAgICBsYXN0Q2hhbXBNYXRjaC5pc0NvbXBsZXRlZCAmJlxuLy8gICAgICAgICAgIHdpbm5lcnNCcmFja2V0VGVhbSAmJlxuLy8gICAgICAgICAgIGxhc3RDaGFtcE1hdGNoLndpbm5lci5pZCAhPT0gd2lubmVyc0JyYWNrZXRUZWFtLmlkICYmXG4vLyAgICAgICAgICAgdHlwZW9mIHdpbm5lcnNCcmFja2V0VGVhbS5sb3NzZXMgPT09IFwibnVtYmVyXCJcbi8vICAgICAgICAgKSB7XG4vLyAgICAgICAgICAgd2lubmVyc0JyYWNrZXRUZWFtLmxvc3NlcyArPSAxO1xuLy8gICAgICAgICB9XG4vLyAgICAgICAgIHdpbm5lciA9IGxhc3RDaGFtcE1hdGNoLndpbm5lcjtcbi8vICAgICAgIH1cbi8vICAgICB9XG4vLyAgIH1cblxuLy8gICAvLyAtLS0gSU5GSU5JVEUgUkVDVVJTSU9OIEdVQVJEIC0tLVxuLy8gICBjb25zdCBub01vcmVNYXRjaGVzID1cbi8vICAgICAoaXNDaGFtcGlvbnNoaXBSb3VuZCAmJiBjaGFtcGlvbnNoaXBNYXRjaGVzLmxlbmd0aCA9PT0gMCkgfHxcbi8vICAgICAoIWlzQ2hhbXBpb25zaGlwUm91bmQgJiYgbmV4dFJvdW5kTWF0Y2hlcy5sZW5ndGggPT09IDApO1xuXG4vLyAgIGlmIChub01vcmVNYXRjaGVzKSB7XG4vLyAgICAgLy8gVG91cm5hbWVudCBpcyBvdmVyLCBkbyBub3QgYWR2YW5jZSBmdXJ0aGVyXG4vLyAgICAgcmV0dXJuIHtcbi8vICAgICAgIC4uLnRvdXJuYW1lbnQsXG4vLyAgICAgICB3aW5uZXIsXG4vLyAgICAgICBjdXJyZW50Um91bmQ6IHRvdXJuYW1lbnQuY3VycmVudFJvdW5kXG4vLyAgICAgfTtcbi8vICAgfVxuLy8gICAvLyA8LS0tIFBMQUNFIFRIRSBERUJVRyBDQUxMIEhFUkUsIGp1c3QgYmVmb3JlIHJldHVybmluZyB0aGUgbmV3IHRvdXJuYW1lbnQgb2JqZWN0IVxuLy8gICBsb2dUb3VybmFtZW50U3RhdGUoe1xuLy8gICAgIHJvdW5kTnVtYmVyOiBuZXh0Um91bmROdW1iZXIsXG4vLyAgICAgd2lubmVyc0JyYWNrZXRUZWFtcyxcbi8vICAgICBsb3NlcnNCcmFja2V0VGVhbXMsXG4vLyAgICAgbWF0Y2hlczogaXNDaGFtcGlvbnNoaXBSb3VuZCA/IGNoYW1waW9uc2hpcE1hdGNoZXMgOiBuZXh0Um91bmRNYXRjaGVzLFxuLy8gICAgIHdpbm5lcnNCcmFja2V0RmluYWxMb3NlcjogdG91cm5hbWVudC53aW5uZXJzQnJhY2tldEZpbmFsTG9zZXJcbi8vICAgfSk7XG5cbi8vICAgLy8gQ29tcG9zZSB0aGUgbmV3IHRvdXJuYW1lbnQgb2JqZWN0XG4vLyAgIHJldHVybiB7XG4vLyAgICAgLi4udG91cm5hbWVudCxcbi8vICAgICByb3VuZHM6IFtcbi8vICAgICAgIC4uLnRvdXJuYW1lbnQucm91bmRzLFxuLy8gICAgICAge1xuLy8gICAgICAgICByb3VuZE51bWJlcjogbmV4dFJvdW5kTnVtYmVyLFxuLy8gICAgICAgICBtYXRjaGVzOiBpc0NoYW1waW9uc2hpcFJvdW5kID8gY2hhbXBpb25zaGlwTWF0Y2hlcyA6IG5leHRSb3VuZE1hdGNoZXMsXG4vLyAgICAgICAgIGlzRG91YmxlRWxpbWluYXRpb246IHRydWUsXG4vLyAgICAgICAgIGlzQ2hhbXBpb25zaGlwUm91bmRcbi8vICAgICAgIH1cbi8vICAgICBdLFxuLy8gICAgIGN1cnJlbnRSb3VuZDogbmV4dFJvdW5kTnVtYmVyLFxuLy8gICAgIGVsaW1pbmF0ZWRUZWFtczogW1xuLy8gICAgICAgLi4udG91cm5hbWVudC5lbGltaW5hdGVkVGVhbXMsXG4vLyAgICAgICAuLi5uZXdseUVsaW1pbmF0ZWQuZmlsdGVyKFxuLy8gICAgICAgICAodCkgPT4gIXRvdXJuYW1lbnQuZWxpbWluYXRlZFRlYW1zLnNvbWUoKGV0KSA9PiBldC5pZCA9PT0gdC5pZClcbi8vICAgICAgIClcbi8vICAgICBdLFxuLy8gICAgIGNoYW1waW9uc2hpcE1hdGNoZXNQbGF5ZWQ6IGlzQ2hhbXBpb25zaGlwUm91bmRcbi8vICAgICAgID8gdG91cm5hbWVudC5jaGFtcGlvbnNoaXBNYXRjaGVzUGxheWVkICsgMVxuLy8gICAgICAgOiB0b3VybmFtZW50LmNoYW1waW9uc2hpcE1hdGNoZXNQbGF5ZWQsXG4vLyAgICAgd2lubmVyc0JyYWNrZXRGaW5hbExvc2VyOiB0b3VybmFtZW50Lndpbm5lcnNCcmFja2V0RmluYWxMb3Nlcixcbi8vICAgICB3aW5uZXJcbi8vICAgfTtcbi8vIH07XG5cbi8vIGZ1bmN0aW9uIGxvZ1RvdXJuYW1lbnRTdGF0ZSh7XG4vLyAgIHJvdW5kTnVtYmVyLFxuLy8gICB3aW5uZXJzQnJhY2tldFRlYW1zLFxuLy8gICBsb3NlcnNCcmFja2V0VGVhbXMsXG4vLyAgIG1hdGNoZXMsXG4vLyAgIHdpbm5lcnNCcmFja2V0RmluYWxMb3NlclxuLy8gfToge1xuLy8gICByb3VuZE51bWJlcjogbnVtYmVyLFxuLy8gICB3aW5uZXJzQnJhY2tldFRlYW1zOiBhbnlbXSxcbi8vICAgbG9zZXJzQnJhY2tldFRlYW1zOiBhbnlbXSxcbi8vICAgbWF0Y2hlczogYW55W10sXG4vLyAgIHdpbm5lcnNCcmFja2V0RmluYWxMb3NlcjogYW55XG4vLyB9KSB7XG4vLyAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4vLyAgIGNvbnNvbGUubG9nKCctLS0gVE9VUk5BTUVOVCBERUJVRyAtLS0nKTtcbi8vICAgY29uc29sZS5sb2coJ1JvdW5kOicsIHJvdW5kTnVtYmVyKTtcbi8vICAgY29uc29sZS5sb2coJ1dpbm5lcnMgQnJhY2tldCBUZWFtczonLCB3aW5uZXJzQnJhY2tldFRlYW1zLm1hcCh0ID0+IGAke3QubmFtZX0gKCR7dC5pZH0pYCkuam9pbignLCAnKSk7XG4vLyAgIGNvbnNvbGUubG9nKCdMb3NlcnMgQnJhY2tldCBUZWFtczonLCBsb3NlcnNCcmFja2V0VGVhbXMubWFwKHQgPT4gYCR7dC5uYW1lfSAoJHt0LmlkfSlgKS5qb2luKCcsICcpKTtcbi8vICAgY29uc29sZS5sb2coJ01hdGNoZXM6Jyk7XG4vLyAgIG1hdGNoZXMuZm9yRWFjaChtID0+XG4vLyAgICAgY29uc29sZS5sb2coYCAgWyR7bS5icmFja2V0fV0gJHttLnRlYW0xPy5uYW1lID8/ICdUQkQnfSB2cyAke20udGVhbTI/Lm5hbWUgPz8gJ1RCRCd9IHwgaXNDb21wbGV0ZWQ6ICR7bS5pc0NvbXBsZXRlZH0gfCBpc0J5ZTogJHttLmlzQnllfWApXG4vLyAgICk7XG4vLyAgIGlmICh3aW5uZXJzQnJhY2tldEZpbmFsTG9zZXIpIHtcbi8vICAgICBjb25zb2xlLmxvZygnV2lubmVycyBCcmFja2V0IEZpbmFsIExvc2VyOicsIHdpbm5lcnNCcmFja2V0RmluYWxMb3Nlci5uYW1lLCB3aW5uZXJzQnJhY2tldEZpbmFsTG9zZXIuaWQpO1xuLy8gICB9XG4vLyAgIGNvbnNvbGUubG9nKCctLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0nKTtcbi8vIH1cblxuIl0sIm5hbWVzIjpbImxvZ1RvdXJuYW1lbnRTdGF0ZSIsImNyZWF0ZU1hdGNoIiwiaWQiLCJyb3VuZE51bWJlciIsInRlYW0xIiwidGVhbTIiLCJpc0J5ZSIsImJyYWNrZXQiLCJuZXh0TWF0Y2hJZCIsIm5leHRMb3Nlck1hdGNoSWQiLCJpc0NvbXBsZXRlZCIsIndpbm5lciIsInVuZGVmaW5lZCIsImxvc2VyIiwic2NvcmUiLCJ0ZWFtMVNjb3JlIiwidGVhbTJTY29yZSIsImVsaW1pbmF0ZWRMYWJlbCIsImNyZWF0ZUluaXRpYWxSb3VuZHMiLCJ0ZWFtcyIsIm51bVRlYW1zIiwibGVuZ3RoIiwibWF0Y2hlcyIsIm51bVJvdW5kcyIsIk1hdGgiLCJjZWlsIiwibG9nMiIsImZpcnN0Um91bmRNYXRjaGVzIiwicG93IiwibWF0Y2hDb3VudGVyIiwiaSIsIm1hdGNoSWQiLCJwdXNoIiwicm91bmRzIiwiaXNEb3VibGVFbGltaW5hdGlvbiIsImlzQ2hhbXBpb25zaGlwUm91bmQiLCJjdXJyZW50Um91bmQiLCJlbGltaW5hdGVkVGVhbXMiLCJjaGFtcGlvbnNoaXBNYXRjaGVzUGxheWVkIiwidXBkYXRlTWF0Y2hTY29yZSIsIm1hdGNoIiwibmV3U2NvcmUiLCJ3aW5zIiwibG9zc2VzIiwiZGVkdXBlVGVhbXMiLCJzZWVuIiwiU2V0IiwiZmlsdGVyIiwidGVhbSIsImhhcyIsImFkZCIsInRlYW1zV2l0aExvc3NlcyIsImxvc3NDb3VudHMiLCJuIiwiT2JqZWN0Iiwia2V5cyIsInRlYW1JZCIsImFkdmFuY2VUb05leHRSb3VuZCIsInRvdXJuYW1lbnQiLCJuZXh0Um91bmROdW1iZXIiLCJ3aW5zQ291bnRzIiwiZm9yRWFjaCIsInJvdW5kIiwiYWxsVGVhbXMiLCJ0ZWFtSWRzIiwibmV3bHlFbGltaW5hdGVkIiwic29tZSIsInQiLCJ3aW5uZXJzQnJhY2tldFRlYW1zIiwic3RhcnRzV2l0aCIsIm1hcCIsImxvc2Vyc0JyYWNrZXRUZWFtcyIsIndpbm5lcnNCcmFja2V0RmluYWxMb3NlciIsImNoYW1waW9uc2hpcE1hdGNoZXMiLCJuZXh0Um91bmRNYXRjaGVzIiwicHJldkNoYW1waW9uc2hpcE1hdGNoZXMiLCJyIiwiZmxhdE1hcCIsIm0iLCJsYXN0Q2hhbXBNYXRjaCIsIndpbm5lcnNCcmFja2V0VGVhbSIsImxvc2Vyc0JyYWNrZXRUZWFtIiwiaW5jbHVkZXMiLCJsb3NlcnNCcmFja2V0V2lubmVyIiwicG9wIiwicHJldmlvdXNSb3VuZE1hdGNoZXMiLCJwcmV2SGFkU2FtZU1hdGNoIiwiaWRzIiwiQm9vbGVhbiIsInNvcnQiLCJjdXJySWRzIiwiZmxvb3IiLCJjcmVhdGVMb3NlcnNCcmFja2V0TWF0Y2hlcyIsImNyZWF0ZVN0YW5kYXJkQnJhY2tldE1hdGNoZXMiLCJlbGlnaWJsZUxvc2VycyIsImp1c3REcm9wcGVkRnJvbVdpbm5lcnMiLCJ3aW5uZXJzRmluYWxMb3NlciIsImV4aXN0aW5nTG9zZXJzIiwiamQiLCJvcmRlcmVkTG9zZXJzIiwidGVhbVdpdGhCeWUiLCJieWVJbmRleCIsImZpbmRJbmRleCIsInNwbGljZSIsInNoaWZ0IiwibG9zZXJzQnJhY2tldFRlYW1Xb24iLCJub01vcmVNYXRjaGVzIiwiZXQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./types/tournament/matches.ts\n"));

/***/ })

});